var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all4) => {
  for (var name29 in all4)
    __defProp(target, name29, { get: all4[name29], enumerable: true });
};
var __copyProps = (to, from58, except, desc) => {
  if (from58 && typeof from58 === "object" || typeof from58 === "function") {
    for (let key of __getOwnPropNames(from58))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from58[key], enumerable: !(desc = __getOwnPropDesc(from58, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/pvtsutils/build/index.js
var require_build = __commonJS({
  "node_modules/pvtsutils/build/index.js"(exports) {
    "use strict";
    var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    var BufferSourceConverter2 = class _BufferSourceConverter {
      static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
      static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
      }
      static toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
      static toView(data, type) {
        if (data.constructor === type) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
      static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
      static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
      static isEqual(a, b) {
        const aView = _BufferSourceConverter.toUint8Array(a);
        const bView = _BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (let i = 0; i < aView.length; i++) {
          if (aView[i] !== bView[i]) {
            return false;
          }
        }
        return true;
      }
      static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
          buffers = args[0];
        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
          buffers = args[0];
        } else {
          if (args[args.length - 1] instanceof Function) {
            buffers = args.slice(0, args.length - 1);
          } else {
            buffers = args;
          }
        }
        let size = 0;
        for (const buffer3 of buffers) {
          size += buffer3.byteLength;
        }
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer3 of buffers) {
          const view = this.toUint8Array(buffer3);
          res.set(view, offset);
          offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) {
          return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
      }
    };
    var STRING_TYPE = "string";
    var HEX_REGEX = /^[0-9a-f]+$/i;
    var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
    var Utf8Converter = class {
      static fromString(text) {
        const s2 = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s2.length);
        for (let i = 0; i < s2.length; i++) {
          uintArray[i] = s2.charCodeAt(i);
        }
        return uintArray.buffer;
      }
      static toString(buffer3) {
        const buf3 = BufferSourceConverter2.toUint8Array(buffer3);
        let encodedString = "";
        for (let i = 0; i < buf3.length; i++) {
          encodedString += String.fromCharCode(buf3[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    };
    var Utf16Converter = class {
      static toString(buffer3, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter2.toArrayBuffer(buffer3);
        const dataView3 = new DataView(arrayBuffer);
        let res = "";
        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
          const code33 = dataView3.getUint16(i, littleEndian);
          res += String.fromCharCode(code33);
        }
        return res;
      }
      static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView3 = new DataView(res);
        for (let i = 0; i < text.length; i++) {
          dataView3.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
      }
    };
    var Convert2 = class _Convert {
      static isHex(data) {
        return typeof data === STRING_TYPE && HEX_REGEX.test(data);
      }
      static isBase64(data) {
        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
      }
      static isBase64Url(data) {
        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
      }
      static ToString(buffer3, enc = "utf8") {
        const buf3 = BufferSourceConverter2.toUint8Array(buffer3);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf3);
          case "binary":
            return this.ToBinary(buf3);
          case "hex":
            return this.ToHex(buf3);
          case "base64":
            return this.ToBase64(buf3);
          case "base64url":
            return this.ToBase64Url(buf3);
          case "utf16le":
            return Utf16Converter.toString(buf3, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf3);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static FromString(str, enc = "utf8") {
        if (!str) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          case "utf16le":
            return Utf16Converter.fromString(str, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static ToBase64(buffer3) {
        const buf3 = BufferSourceConverter2.toUint8Array(buffer3);
        if (typeof btoa !== "undefined") {
          const binary = this.ToString(buf3, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf3).toString("base64");
        }
      }
      static FromBase64(base6430) {
        const formatted = this.formatString(base6430);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
      static FromBase64Url(base64url30) {
        const formatted = this.formatString(base64url30);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
      static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text);
          case "utf8":
            return Utf8Converter.fromString(text);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static ToUtf8String(buffer3, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer3);
          case "utf8":
            return Utf8Converter.toString(buffer3);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer3);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer3, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
          resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
      }
      static ToBinary(buffer3) {
        const buf3 = BufferSourceConverter2.toUint8Array(buffer3);
        let res = "";
        for (let i = 0; i < buf3.length; i++) {
          res += String.fromCharCode(buf3[i]);
        }
        return res;
      }
      static ToHex(buffer3) {
        const buf3 = BufferSourceConverter2.toUint8Array(buffer3);
        let result = "";
        const len = buf3.length;
        for (let i = 0; i < len; i++) {
          const byte = buf3[i];
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16);
        }
        return result;
      }
      static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i = 0; i < formatted.length; i = i + 2) {
          const c = formatted.slice(i, i + 2);
          res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
      }
      static ToUtf16String(buffer3, littleEndian = false) {
        return Utf16Converter.toString(buffer3, littleEndian);
      }
      static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
      }
      static Base64Padding(base6430) {
        const padCount = 4 - base6430.length % 4;
        if (padCount < 4) {
          for (let i = 0; i < padCount; i++) {
            base6430 += "=";
          }
        }
        return base6430;
      }
      static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    };
    Convert2.DEFAULT_UTF8_ENCODING = "utf8";
    function assign(target, ...sources) {
      const res = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
          res[prop] = obj[prop];
        }
      }
      return res;
    }
    function combine(...buf3) {
      const totalByteLength = buf3.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
      const res = new Uint8Array(totalByteLength);
      let currentPos = 0;
      buf3.map((item) => new Uint8Array(item)).forEach((arr) => {
        for (const item2 of arr) {
          res[currentPos++] = item2;
        }
      });
      return res.buffer;
    }
    function isEqual(bytes1, bytes22) {
      if (!(bytes1 && bytes22)) {
        return false;
      }
      if (bytes1.byteLength !== bytes22.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b2 = new Uint8Array(bytes22);
      for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.BufferSourceConverter = BufferSourceConverter2;
    exports.Convert = Convert2;
    exports.assign = assign;
    exports.combine = combine;
    exports.isEqual = isEqual;
  }
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports, module2) {
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes3) {
        if (!Array.isArray(bytes3) && !ArrayBuffer.isView(bytes3)) {
          return false;
        }
        for (var i = 0; i < bytes3.length; i++) {
          if (!Number.isInteger(bytes3[i]) || bytes3[i] < 0 || bytes3[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m2, n) {
        return (m2 & 65535) * n + (((m2 >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m2, n) {
        return m2 << n | m2 >>> 32 - n;
      }
      function _x86Fmix(h2) {
        h2 ^= h2 >>> 16;
        h2 = _x86Multiply(h2, 2246822507);
        h2 ^= h2 >>> 13;
        h2 = _x86Multiply(h2, 3266489909);
        h2 ^= h2 >>> 16;
        return h2;
      }
      function _x64Add(m2, n) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m2[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m2[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m2[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m2[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m2, n) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m2[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m2[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m2[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m2[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m2[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m2[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m2[0] * n[3] + m2[1] * n[2] + m2[2] * n[1] + m2[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m2, n) {
        n %= 64;
        if (n === 32) {
          return [m2[1], m2[0]];
        } else if (n < 32) {
          return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n | m2[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m2[1] << n | m2[0] >>> 32 - n, m2[0] << n | m2[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m2, n) {
        n %= 64;
        if (n === 0) {
          return m2;
        } else if (n < 32) {
          return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n];
        } else {
          return [m2[1] << n - 32, 0];
        }
      }
      function _x64Xor(m2, n) {
        return [m2[0] ^ n[0], m2[1] ^ n[1]];
      }
      function _x64Fmix(h2) {
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        h2 = _x64Multiply(h2, [4283543511, 3981806797]);
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        h2 = _x64Multiply(h2, [3301882366, 444984403]);
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        return h2;
      }
      library.x86.hash32 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 4;
        var blocks = bytes3.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes3[i + 2] << 16;
          case 2:
            k1 ^= bytes3[i + 1] << 8;
          case 1:
            k1 ^= bytes3[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes3.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 16;
        var blocks = bytes3.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24;
          k2 = bytes3[i + 4] | bytes3[i + 5] << 8 | bytes3[i + 6] << 16 | bytes3[i + 7] << 24;
          k3 = bytes3[i + 8] | bytes3[i + 9] << 8 | bytes3[i + 10] << 16 | bytes3[i + 11] << 24;
          k4 = bytes3[i + 12] | bytes3[i + 13] << 8 | bytes3[i + 14] << 16 | bytes3[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes3[i + 14] << 16;
          case 14:
            k4 ^= bytes3[i + 13] << 8;
          case 13:
            k4 ^= bytes3[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes3[i + 11] << 24;
          case 11:
            k3 ^= bytes3[i + 10] << 16;
          case 10:
            k3 ^= bytes3[i + 9] << 8;
          case 9:
            k3 ^= bytes3[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes3[i + 7] << 24;
          case 7:
            k2 ^= bytes3[i + 6] << 16;
          case 6:
            k2 ^= bytes3[i + 5] << 8;
          case 5:
            k2 ^= bytes3[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes3[i + 3] << 24;
          case 3:
            k1 ^= bytes3[i + 2] << 16;
          case 2:
            k1 ^= bytes3[i + 1] << 8;
          case 1:
            k1 ^= bytes3[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes3.length;
        h2 ^= bytes3.length;
        h3 ^= bytes3.length;
        h4 ^= bytes3.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 16;
        var blocks = bytes3.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes3[i + 4] | bytes3[i + 5] << 8 | bytes3[i + 6] << 16 | bytes3[i + 7] << 24, bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24];
          k2 = [bytes3[i + 12] | bytes3[i + 13] << 8 | bytes3[i + 14] << 16 | bytes3[i + 15] << 24, bytes3[i + 8] | bytes3[i + 9] << 8 | bytes3[i + 10] << 16 | bytes3[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes3[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes3[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes3.length]);
        h2 = _x64Xor(h2, [0, bytes3.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports = module2.exports = library;
        }
        exports.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports);
  }
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports, module2) {
    module2.exports = require_murmurHash3js();
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names3 = [], events2, name29;
      if (this._eventsCount === 0) return names3;
      for (name29 in events2 = this._events) {
        if (has.call(events2, name29)) names3.push(prefix ? name29.slice(1) : name29);
      }
      if (Object.getOwnPropertySymbols) {
        return names3.concat(Object.getOwnPropertySymbols(events2));
      }
      return names3;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length30 = listeners.length, j;
        for (i = 0; i < length30; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length30 = listeners.length; i < length30; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module2) {
    module2.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache30 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache30[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache30;
          cache30 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache30[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache30[key] !== void 0)
            cache30[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache30[key];
          if (v !== void 0) return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache30[key] !== void 0) cache30[key] = value;
          else update(key, value);
        },
        clear: function() {
          cache30 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code33, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code33 === "object") {
        props = code33;
        code33 = "";
      }
      if (code33) {
        props.code = code33;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output3 = assign(new ErrClass(), props);
        return output3;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d2;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d2 = long & 255;
        return [a, b, c, d2].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob2(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob2 = function(s2) {
        var base45, dmax, i, n, start2;
        n = 0;
        base45 = 10;
        dmax = "9";
        i = 0;
        if (s2.length > 1 && s2[i] === "0") {
          if (s2[i + 1] === "x" || s2[i + 1] === "X") {
            i += 2;
            base45 = 16;
          } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
            i++;
            base45 = 8;
            dmax = "7";
          }
        }
        start2 = i;
        while (i < s2.length) {
          if ("0" <= s2[i] && s2[i] <= dmax) {
            n = n * base45 + (chr(s2[i]) - chr0) >>> 0;
          } else if (base45 === 16) {
            if ("a" <= s2[i] && s2[i] <= "f") {
              n = n * base45 + (10 + chr(s2[i]) - chra) >>> 0;
            } else if ("A" <= s2[i] && s2[i] <= "F") {
              n = n * base45 + (10 + chr(s2[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start2) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// node_modules/timestamp-nano/dist/timestamp.min.js
var require_timestamp_min = __commonJS({
  "node_modules/timestamp-nano/dist/timestamp.min.js"(exports, module2) {
    var Timestamp = function() {
      "undefined" != typeof module2 && (module2.exports = d2);
      var l = 86400, s2 = 3200, T = 146097 * s2 / 400, e = l * T, f = 1e3 * e, c = 864e13, g = 4294967296, h2 = 1e6, u = "000000000", m2 = Math.trunc || function(n2) {
        var t2 = n2 - n2 % 1;
        return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
      }, n = d2.prototype, o = (d2.fromDate = function(n2) {
        return new d2(+n2);
      }, d2.fromInt64BE = r(0, 1, 2, 3, 0, 4), d2.fromInt64LE = r(3, 2, 1, 0, 4, 0), d2.fromString = function(n2) {
        var e2, r2 = new d2(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
          var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
          return r2.year = n3 - t2, t2;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
          return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
        }).replace(/\.\d+$/, function(n3) {
          return r2.nano = +(n3 + u).substr(1, 9), "";
        }).split(/\D+/);
        1 < n2.length ? n2[1]-- : n2[1] = 0;
        if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2)) throw new TypeError("Invalid Date");
        return p(r2);
      }, d2.fromTimeT = function(n2) {
        return y2(n2, 0);
      }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
        return this.nano += +n2 || 0, this;
      }, n.getNano = function() {
        var n2 = p(this);
        return (n2.time % 1e3 * h2 + +n2.nano + 1e9) % 1e9;
      }, n.getTimeT = function() {
        var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
        n2 && (t2 += n2 * T * l / s2);
        return t2;
      }, n.getYear = function() {
        return this.toDate().getUTCFullYear() + this.year;
      }, n.toDate = function() {
        return M(p(this).time);
      }, n.toJSON = function() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }, n.toString = function(n2) {
        var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
          return C(r2.getUTCHours());
        }, L: function() {
          return D(r2.getUTCMilliseconds(), 3);
        }, M: function() {
          return C(r2.getUTCMinutes());
        }, N: function() {
          return D(t2.getNano(), 9);
        }, S: function() {
          return C(r2.getUTCSeconds());
        }, Y: function() {
          var n3 = t2.getYear();
          return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
        }, a: function() {
          return a[r2.getUTCDay()];
        }, b: function() {
          return i[r2.getUTCMonth()];
        }, d: function() {
          return C(r2.getUTCDate());
        }, e: function() {
          return function(n3) {
            return (9 < n3 ? "" : " ") + (0 | n3);
          }(r2.getUTCDate());
        }, m: function() {
          return C(r2.getUTCMonth() + 1);
        } };
        return function e2(n3) {
          return n3.replace(/%./g, function(n4) {
            var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
            return r3 ? e2(r3) : t3 ? t3() : n4;
          });
        }(n2 || o);
      }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
      return d2;
      function d2(n2, t2, r2) {
        var e2 = this;
        if (!(e2 instanceof d2)) return new d2(n2, t2, r2);
        e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
      }
      function p(n2) {
        var t2, r2, e2, u2 = n2.year, o2 = n2.time, i2 = n2.nano, a2 = ((i2 < 0 || h2 <= i2) && (i2 -= (r2 = Math.floor(i2 / h2)) * h2, o2 += r2, r2 = 1), u2 % s2);
        return (o2 < -c || c < o2 || a2) && ((t2 = m2(o2 / f)) && (u2 += t2 * s2, o2 -= t2 * f), (e2 = M(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m2((u2 -= a2) / s2)) * f, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s2, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i2), n2;
      }
      function M(n2) {
        var t2 = /* @__PURE__ */ new Date(0);
        return t2.setTime(n2), t2;
      }
      function y2(n2, t2) {
        n2 = +n2 || 0;
        var r2 = m2((t2 = (t2 | 0) * g) / e) + m2(n2 / e), t2 = t2 % e + n2 % e, n2 = m2(t2 / e);
        return n2 && (r2 += n2, t2 -= n2 * e), new d2(1e3 * t2, 0, r2 * s2);
      }
      function t(e2, u2, o2, i2, a2, f2) {
        return function(n2, t2) {
          var r2 = p(this);
          n2 = n2 || new Array(8);
          w2(n2, t2 |= 0);
          var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s2), u3 = m2(r2 / g) + m2(e3 / g), r2 = r2 % g + e3 % g, e3 = Math.floor(r2 / g);
          e3 && (u3 += e3, r2 -= e3 * g);
          return c2(n2, t2 + a2, u3), c2(n2, t2 + f2, r2), n2;
        };
        function c2(n2, t2, r2) {
          n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i2] = 255 & r2;
        }
      }
      function r(r2, e2, u2, o2, i2, a2) {
        return function(n2, t2) {
          w2(n2, t2 |= 0);
          var r3 = f2(n2, t2 + i2);
          return y2(f2(n2, t2 + a2), r3);
        };
        function f2(n2, t2) {
          return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
        }
      }
      function w2(n2, t2) {
        n2 = n2 && n2.length;
        if (null == n2) throw new TypeError("Invalid Buffer");
        if (n2 < t2 + 8) throw new RangeError("Out of range");
      }
      function C(n2) {
        return (9 < n2 ? "" : "0") + (0 | n2);
      }
      function D(n2, t2) {
        return (u + (0 | n2)).substr(-t2);
      }
    }();
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports, module2) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron2;
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name29, value) => Object.defineProperty(object, name29, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol3 of symbols) {
          if (propertyIsEnumerable.call(value, symbol3)) {
            keys.push(symbol3);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge2(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge2(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module2.exports = function(...options2) {
      const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options2) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge2(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate(getLength, string27, byteLength) {
      if (typeof string27 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string27.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string27.charCodeAt(i);
        segment = string27[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string27.charCodeAt(i + 1))) {
          i += 1;
          segment += string27[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string27.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string27.slice(0, i - segment.length + 1);
        }
      }
      return string27;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string27) {
      if (typeof string27 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string27.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string27.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser2 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module2) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser();
    module2.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module2) {
    "use strict";
    var truncate = require_browser2();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module2.exports = function(input, options2) {
      var replacement = options2 && options2.replacement || "";
      var output3 = sanitize2(input, replacement);
      if (replacement === "") {
        return output3;
      }
      return sanitize2(output3, "");
    };
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options2, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options2);
        return () => this.removeEventListener(event, push, options2);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// node_modules/helia/dist/src/index.js
var src_exports9 = {};
__export(src_exports9, {
  DEFAULT_SESSION_MAX_PROVIDERS: () => DEFAULT_SESSION_MAX_PROVIDERS,
  DEFAULT_SESSION_MIN_PROVIDERS: () => DEFAULT_SESSION_MIN_PROVIDERS,
  createHelia: () => createHelia,
  libp2pDefaults: () => libp2pDefaults
});
module.exports = __toCommonJS(src_exports9);

// node_modules/@libp2p/interface/dist/src/connection/index.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/interface/dist/src/content-routing/index.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/interface/dist/src/peer-discovery/index.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/interface/dist/src/peer-id/index.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[peerIdSymbol]);
}

// node_modules/@libp2p/interface/dist/src/peer-routing/index.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/@libp2p/interface/dist/src/peer-store/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/@libp2p/interface/dist/src/transport/index.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class _AbortError extends Error {
  code;
  type;
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
    this.code = _AbortError.code;
    this.type = _AbortError.type;
  }
  static code = "ABORT_ERR";
  static type = "aborted";
};
var CodeError = class extends Error {
  code;
  props;
  constructor(message2, code33, props) {
    super(message2);
    this.code = code33;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};
var AggregateCodeError = class extends AggregateError {
  code;
  props;
  constructor(errors, message2, code33, props) {
    super(errors, message2);
    this.code = code33;
    this.name = props?.name ?? "AggregateCodeError";
    this.props = props ?? {};
  }
};
var ERR_TIMEOUT = "ERR_TIMEOUT";
var ERR_INVALID_MESSAGE = "ERR_INVALID_MESSAGE";

// node_modules/@libp2p/interface/dist/src/events.browser.js
function setMaxListeners() {
}

// node_modules/@libp2p/interface/dist/src/events.js
var setMaxListeners2 = (n, ...eventTargets) => {
  try {
    setMaxListeners(n, ...eventTargets);
  } catch {
  }
};

// node_modules/@libp2p/interface/dist/src/event-target.js
var TypedEventEmitter = class extends EventTarget {
  #listeners = /* @__PURE__ */ new Map();
  constructor() {
    super();
    setMaxListeners2(Infinity, this);
  }
  listenerCount(type) {
    const listeners = this.#listeners.get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options2) {
    super.addEventListener(type, listener, options2);
    let list = this.#listeners.get(type);
    if (list == null) {
      list = [];
      this.#listeners.set(type, list);
    }
    list.push({
      callback: listener,
      once: (options2 !== true && options2 !== false && options2?.once) ?? false
    });
  }
  removeEventListener(type, listener, options2) {
    super.removeEventListener(type.toString(), listener ?? null, options2);
    let list = this.#listeners.get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    this.#listeners.set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = this.#listeners.get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    this.#listeners.set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
var CustomEvent = globalThis.CustomEvent;

// node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStart != null) {
      await s2.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.start();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStart != null) {
      await s2.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStop != null) {
      await s2.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.stop();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStop != null) {
      await s2.afterStop();
    }
  }));
}

// node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

// node_modules/@helia/bitswap/node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/it-pushable/node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  buffer;
  mask;
  top;
  btm;
  next;
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  size;
  hwm;
  head;
  tail;
  constructor(options2 = {}) {
    this.hwm = options2.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
var AbortError2 = class extends Error {
  type;
  code;
  constructor(message2, code33) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code33 ?? "ABORT_ERR";
  }
};
function pushable(options2 = {}) {
  const getNext = (buffer3) => {
    const next = buffer3.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options2);
}
function _pushable(getNext, options2) {
  options2 = options2 ?? {};
  let onEnd = options2.onEnd;
  let buffer3 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain6 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer3.isEmpty()) {
        return getNext(buffer3);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer3.push(next);
          try {
            resolve(getNext(buffer3));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer3.isEmpty()) {
        queueMicrotask(() => {
          drain6.resolve();
          drain6 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer3.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer3 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer3.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if (options2?.objectMode !== true && value?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer3 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer3.size;
    },
    onEmpty: async (options3) => {
      const signal = options3?.signal;
      signal?.throwIfAborted();
      if (buffer3.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError2());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain6.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal?.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}

// node_modules/race-event/dist/src/index.js
var AbortError3 = class extends Error {
  type;
  code;
  constructor(message2, code33) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.name = "AbortError";
    this.code = code33 ?? "ABORT_ERR";
  }
};
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError3(opts?.errorMessage, opts?.errorCode);
  if (signal?.aborted === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      signal?.removeEventListener("abort", abortListener);
      emitter.removeEventListener(eventName, eventListener);
      if (opts?.errorEvent != null) {
        emitter.removeEventListener(opts.errorEvent, errorEventListener);
      }
    }
    const eventListener = (evt) => {
      try {
        if (opts?.filter?.(evt) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      reject(evt.detail);
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    signal?.addEventListener("abort", abortListener);
    emitter.addEventListener(eventName, eventListener);
    if (opts?.errorEvent != null) {
      emitter.addEventListener(opts.errorEvent, errorEventListener);
    }
  });
}

// node_modules/race-signal/dist/src/index.js
var AbortError4 = class extends Error {
  type;
  code;
  constructor(message2, code33, name29) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.name = name29 ?? "AbortError";
    this.code = code33 ?? "ABORT_ERR";
  }
};
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    return Promise.reject(new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName));
  }
  let listener;
  const error = new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/@libp2p/utils/node_modules/p-defer/index.js
function pDefer2() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient = class {
  deferred;
  signal;
  constructor(signal) {
    this.signal = signal;
    this.deferred = pDefer2();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  id;
  fn;
  options;
  recipients;
  status;
  timeline;
  controller;
  constructor(fn, options2) {
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners2(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    const recipient = new JobRecipient(options2.signal);
    this.recipients.push(recipient);
    options2.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue = class extends TypedEventEmitter {
  concurrency;
  queue;
  pending;
  sort;
  constructor(init = {}) {
    super();
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      init.metrics?.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
  }
  tryToStartAnother() {
    if (this.size === 0) {
      queueMicrotask(() => {
        this.safeDispatchEvent("empty");
      });
      if (this.running === 0) {
        queueMicrotask(() => {
          this.safeDispatchEvent("idle");
        });
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    options2?.signal?.throwIfAborted();
    const job = new Job(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("error", { detail: err });
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options2?.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options2?.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options2?.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    options2?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new CodeError("Queue aborted", "ERR_QUEUE_ABORTED"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("error", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    options2?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("error", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      options2?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue {
  has(peerId2) {
    return this.find(peerId2) != null;
  }
  find(peerId2) {
    return this.queue.find((job) => {
      return peerId2.equals(job.options.peerId);
    });
  }
};

// node_modules/@helia/bitswap/node_modules/it-drain/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default = drain;

// node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  return new Uint8Array(size);
}

// node_modules/uint8-varint/dist/src/index.js
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var MSB = 128;
var REST = 127;
function encodingLength(value) {
  if (value < N1) {
    return 1;
  }
  if (value < N2) {
    return 2;
  }
  if (value < N3) {
    return 3;
  }
  if (value < N4) {
    return 4;
  }
  if (value < N5) {
    return 5;
  }
  if (value < N6) {
    return 6;
  }
  if (value < N7) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value, buf3, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf3[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 7: {
      buf3[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 6: {
      buf3[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 5: {
      buf3[offset++] = value & 255 | MSB;
      value /= 128;
    }
    case 4: {
      buf3[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 3: {
      buf3[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 2: {
      buf3[offset++] = value & 255 | MSB;
      value >>>= 7;
    }
    case 1: {
      buf3[offset++] = value & 255;
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf3;
}
function encodeUint8ArrayList(value, buf3, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf3.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 7: {
      buf3.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 6: {
      buf3.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 5: {
      buf3.set(offset++, value & 255 | MSB);
      value /= 128;
    }
    case 4: {
      buf3.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 3: {
      buf3.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 2: {
      buf3.set(offset++, value & 255 | MSB);
      value >>>= 7;
    }
    case 1: {
      buf3.set(offset++, value & 255);
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf3;
}
function decodeUint8Array(buf3, offset) {
  let b = buf3[offset];
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 1];
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 2];
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 3];
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 4];
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 5];
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 6];
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf3[offset + 7];
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf3, offset) {
  let b = buf3.get(offset);
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 1);
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 2);
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 3);
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 4);
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 5);
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 6);
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf3.get(offset + 7);
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function encode(value, buf3, offset = 0) {
  if (buf3 == null) {
    buf3 = allocUnsafe(encodingLength(value));
  }
  if (buf3 instanceof Uint8Array) {
    return encodeUint8Array(value, buf3, offset);
  } else {
    return encodeUint8ArrayList(value, buf3, offset);
  }
}
function decode(buf3, offset = 0) {
  if (buf3 instanceof Uint8Array) {
    return decodeUint8Array(buf3, offset);
  } else {
    return decodeUint8ArrayList(buf3, offset);
  }
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js
function alloc(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe2(size = 0) {
  return new Uint8Array(size);
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf3) {
  return buf3;
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js
function concat(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe2(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output3);
}

// node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js
function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/uint8arraylist/dist/src/index.js
var symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf3 of bufs) {
    const bufEnd = offset + buf3.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf3,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value?.[symbol]);
}
var Uint8ArrayList = class _Uint8ArrayList {
  bufs;
  length;
  [symbol] = true;
  constructor(...data) {
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length30 = 0;
    for (const buf3 of bufs) {
      if (buf3 instanceof Uint8Array) {
        length30 += buf3.byteLength;
        this.bufs.push(buf3);
      } else if (isUint8ArrayList(buf3)) {
        length30 += buf3.byteLength;
        this.bufs.push(...buf3.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length30;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length30 = 0;
    for (const buf3 of bufs.reverse()) {
      if (buf3 instanceof Uint8Array) {
        length30 += buf3.byteLength;
        this.bufs.unshift(buf3);
      } else if (isUint8ArrayList(buf3)) {
        length30 += buf3.byteLength;
        this.bufs.unshift(...buf3.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length30;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf3, offset = 0) {
    if (buf3 instanceof Uint8Array) {
      for (let i = 0; i < buf3.length; i++) {
        this.set(offset + i, buf3[i]);
      }
    } else if (isUint8ArrayList(buf3)) {
      for (let i = 0; i < buf3.length; i++) {
        this.set(offset + i, buf3.get(i));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes3) {
    bytes3 = Math.trunc(bytes3);
    if (Number.isNaN(bytes3) || bytes3 <= 0) {
      return;
    }
    if (bytes3 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes3 >= this.bufs[0].byteLength) {
        bytes3 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes3);
        this.length -= bytes3;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length30 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length30);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length30 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length30);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length30 } = this._subList(beginInclusive, endExclusive);
    const list = new _Uint8ArrayList();
    list.length = length30;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i = 0; i < this.bufs.length; i++) {
      const buf3 = this.bufs[i];
      const bufStart = offset;
      const bufEnd = bufStart + buf3.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf3);
          break;
        }
        const start2 = beginInclusive - bufStart;
        bufs.push(buf3.subarray(start2, start2 + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf3);
          continue;
        }
        bufs.push(buf3.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf3);
          break;
        }
        bufs.push(buf3.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf3);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i = offset; i <= lastIndex; i += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf3 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf3 = allocUnsafe2(1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt8(0, value);
    this.write(buf3, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf3 = alloc(2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf3 = alloc(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf3 = alloc(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getUint8(byteOffset) {
    const buf3 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf3 = allocUnsafe2(1);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint8(0, value);
    this.write(buf3, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf3 = alloc(2);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf3 = alloc(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf3 = alloc(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf3 = alloc(4);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf3 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf3 = alloc(8);
    const view = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf3, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof _Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i = 0; i < this.bufs.length; i++) {
      if (!equals(this.bufs[i], other.bufs[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length30) {
    const list = new _Uint8ArrayList();
    list.bufs = bufs;
    if (length30 == null) {
      length30 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length30;
    return list;
  }
};

// node_modules/it-length-prefixed/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe3(size = 0) {
  return new Uint8Array(size);
}

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length30) => {
  const lengthLength = encodingLength(length30);
  const lengthBuf = allocUnsafe3(lengthLength);
  encode(length30, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode2(source, options2) {
  options2 = options2 ?? {};
  const encodeLength = options2.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length30 = encodeLength(chunk.byteLength);
    if (length30 instanceof Uint8Array) {
      yield length30;
    } else {
      yield* length30;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode2.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength = options2.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError = class extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError = class extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};
var UnexpectedEOFError = class extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// node_modules/it-length-prefixed/dist/src/decode.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf3) => {
  const length30 = decode(buf3);
  defaultDecoder.bytes = encodingLength(length30);
  return length30;
};
defaultDecoder.bytes = 0;
function decode2(source, options2) {
  const buffer3 = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer3.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer3);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer3.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer3.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer3.byteLength < dataLength) {
          break;
        }
        const data = buffer3.sublist(0, dataLength);
        buffer3.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const buf3 of source) {
        buffer3.append(buf3);
        yield* maybeYield();
      }
      if (buffer3.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf3 of source) {
      buffer3.append(buf3);
      yield* maybeYield();
    }
    if (buffer3.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
decode2.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength = l;
  };
  return decode2(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// node_modules/@helia/bitswap/node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default2 = peekable;

// node_modules/@helia/bitswap/node_modules/it-map/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map(source, func2) {
  let index = 0;
  if (isAsyncIterable3(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val, index++);
      }
    }();
  }
  const peekable8 = src_default2(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = func2(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable8) {
        yield func2(val, index++);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable8) {
      yield fn(val, index++);
    }
  }();
}
var src_default3 = map;

// node_modules/it-merge/dist/src/index.js
function isAsyncIterable4(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable4(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return function* () {
      for (const source of syncSources) {
        yield* source;
      }
    }();
  }
  return async function* () {
    const output3 = pushable({
      objectMode: true
    });
    void Promise.resolve().then(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output3.push(item);
          }
        }));
        output3.end();
      } catch (err) {
        output3.end(err);
      }
    });
    yield* output3;
  }();
}
var src_default4 = merge;

// node_modules/@helia/bitswap/node_modules/it-pipe/dist/src/index.js
function pipe(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable(first4) || isAsyncIterable5(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable5 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable5(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@helia/bitswap/node_modules/it-take/dist/src/index.js
function isAsyncIterable6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable6(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default5 = take;

// node_modules/progress-events/dist/src/index.js
var CustomProgressEvent = class extends Event {
  type;
  detail;
  constructor(type, detail) {
    super(type);
    this.type = type;
    this.detail = detail;
  }
};

// node_modules/@helia/bitswap/dist/src/constants.js
var BITSWAP_120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DEFAULT_MAX_INBOUND_STREAMS = 1024;
var DEFAULT_MAX_OUTBOUND_STREAMS = 1024;
var DEFAULT_MESSAGE_RECEIVE_TIMEOUT = 5e3;
var DEFAULT_MESSAGE_SEND_DELAY = 10;
var DEFAULT_MESSAGE_SEND_CONCURRENCY = 50;
var DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS = false;
var DEFAULT_MAX_PROVIDERS_PER_REQUEST = 3;
var DEFAULT_MAX_OUTGOING_MESSAGE_SIZE = 1024 * 1024 * 4;
var DEFAULT_MAX_INCOMING_MESSAGE_SIZE = DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;

// node_modules/protons-runtime/dist/src/utils/float.js
var f32 = new Float32Array([-0]);
var f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf3, pos) {
  f32[0] = val;
  buf3[pos] = f8b[0];
  buf3[pos + 1] = f8b[1];
  buf3[pos + 2] = f8b[2];
  buf3[pos + 3] = f8b[3];
}
function readFloatLE(buf3, pos) {
  f8b[0] = buf3[pos];
  f8b[1] = buf3[pos + 1];
  f8b[2] = buf3[pos + 2];
  f8b[3] = buf3[pos + 3];
  return f32[0];
}
var f64 = new Float64Array([-0]);
var d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf3, pos) {
  f64[0] = val;
  buf3[pos] = d8b[0];
  buf3[pos + 1] = d8b[1];
  buf3[pos + 2] = d8b[2];
  buf3[pos + 3] = d8b[3];
  buf3[pos + 4] = d8b[4];
  buf3[pos + 5] = d8b[5];
  buf3[pos + 6] = d8b[6];
  buf3[pos + 7] = d8b[7];
}
function readDoubleLE(buf3, pos) {
  d8b[0] = buf3[pos];
  d8b[1] = buf3[pos + 1];
  d8b[2] = buf3[pos + 2];
  d8b[3] = buf3[pos + 3];
  d8b[4] = buf3[pos + 4];
  d8b[5] = buf3[pos + 5];
  d8b[6] = buf3[pos + 6];
  d8b[7] = buf3[pos + 7];
  return f64[0];
}

// node_modules/protons-runtime/dist/src/utils/longbits.js
var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
var LongBits = class _LongBits {
  lo;
  hi;
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned = false) {
    if (!unsigned && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned = false) {
    if (unsigned) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned = false) {
    return this.toBigInt(unsigned).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value) {
    if (value === 0n) {
      return zero;
    }
    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value));
    }
    const negative = value < 0n;
    if (negative) {
      value = -value;
    }
    let hi = value >> 32n;
    let lo = value - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new _LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value) {
    if (value === 0) {
      return zero;
    }
    const sign2 = value < 0;
    if (sign2) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new _LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value) {
    if (typeof value === "number") {
      return _LongBits.fromNumber(value);
    }
    if (typeof value === "bigint") {
      return _LongBits.fromBigInt(value);
    }
    if (typeof value === "string") {
      return _LongBits.fromBigInt(BigInt(value));
    }
    return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
  }
};
var zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var TWO_32 = 4294967296n;

// node_modules/protons-runtime/dist/src/utils/utf8.js
function length(string27) {
  let len = 0;
  let c = 0;
  for (let i = 0; i < string27.length; ++i) {
    c = string27.charCodeAt(i);
    if (c < 128) {
      len += 1;
    } else if (c < 2048) {
      len += 2;
    } else if ((c & 64512) === 55296 && (string27.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else {
      len += 3;
    }
  }
  return len;
}
function read(buffer3, start2, end) {
  const len = end - start2;
  if (len < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i = 0;
  let t;
  while (start2 < end) {
    t = buffer3[start2++];
    if (t < 128) {
      chunk[i++] = t;
    } else if (t > 191 && t < 224) {
      chunk[i++] = (t & 31) << 6 | buffer3[start2++] & 63;
    } else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (buffer3[start2++] & 63) << 12 | (buffer3[start2++] & 63) << 6 | buffer3[start2++] & 63) - 65536;
      chunk[i++] = 55296 + (t >> 10);
      chunk[i++] = 56320 + (t & 1023);
    } else {
      chunk[i++] = (t & 15) << 12 | (buffer3[start2++] & 63) << 6 | buffer3[start2++] & 63;
    }
    if (i > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (parts != null) {
    if (i > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}
function write(string27, buffer3, offset) {
  const start2 = offset;
  let c1;
  let c2;
  for (let i = 0; i < string27.length; ++i) {
    c1 = string27.charCodeAt(i);
    if (c1 < 128) {
      buffer3[offset++] = c1;
    } else if (c1 < 2048) {
      buffer3[offset++] = c1 >> 6 | 192;
      buffer3[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string27.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer3[offset++] = c1 >> 18 | 240;
      buffer3[offset++] = c1 >> 12 & 63 | 128;
      buffer3[offset++] = c1 >> 6 & 63 | 128;
      buffer3[offset++] = c1 & 63 | 128;
    } else {
      buffer3[offset++] = c1 >> 12 | 224;
      buffer3[offset++] = c1 >> 6 & 63 | 128;
      buffer3[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start2;
}

// node_modules/protons-runtime/dist/src/utils/reader.js
function indexOutOfRange(reader, writeLength) {
  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf3, end) {
  return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
}
var Uint8ArrayReader = class {
  buf;
  pos;
  len;
  _slice = Uint8Array.prototype.subarray;
  constructor(buffer3) {
    this.buf = buffer3;
    this.pos = 0;
    this.len = buffer3.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value = 4294967295;
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length30 = this.uint32();
    const start2 = this.pos;
    const end = this.pos + length30;
    if (end > this.len) {
      throw indexOutOfRange(this, length30);
    }
    this.pos += length30;
    return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes3 = this.bytes();
    return read(bytes3, 0, bytes3.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length30) {
    if (typeof length30 === "number") {
      if (this.pos + length30 > this.len) {
        throw indexOutOfRange(this, length30);
      }
      this.pos += length30;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      /* istanbul ignore next */
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits2 = new LongBits(0, 0);
    let i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits2;
        }
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits2;
      }
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits2;
        }
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits2;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits2;
        }
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits2;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength(value);
    return value;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
};
function createReader(buf3) {
  return new Uint8ArrayReader(buf3 instanceof Uint8Array ? buf3 : buf3.subarray());
}

// node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf3, codec, opts) {
  const reader = createReader(buf3);
  return codec.decode(reader, void 0, opts);
}

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe4(size = 0) {
  return new Uint8Array(size);
}

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bytes.js
var empty = new Uint8Array(0);
function equals2(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString(str) {
  return new TextEncoder().encode(str);
}
function toString(b) {
  return new TextDecoder().decode(b);
}

// node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name29, prefix, baseEncode);
    this.decoder = new Decoder(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec(name29, prefix, encode116, decode144);
}
function baseX({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default(alphabet27, name29);
  return from({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce(decode144(text))
  });
}
function decode3(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode3(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc4648({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from({
    prefix,
    name: name29,
    encode(input) {
      return encode3(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode4(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode4(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode4,
  decode: decode4
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString(buf3),
  decode: (str) => fromString(str)
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode5;
var MSB2 = 128;
var REST2 = 127;
var MSBALL = ~REST2;
var INT = Math.pow(2, 31);
function encode5(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode5.bytes = offset - oldOffset + 1;
  return out;
}
var decode5 = read2;
var MSB$1 = 128;
var REST$1 = 127;
function read2(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode5,
  encodingLength: length2
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/protons-runtime/node_modules/multiformats/dist/src/varint.js
function decode6(data, offset = 0) {
  const code33 = varint_default.decode(data, offset);
  return [code33, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength2(int) {
  return varint_default.encodingLength(int);
}

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/digest.js
function create(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength2(code33);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo(code33, bytes3, 0);
  encodeTo(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest(code33, size, digest27, bytes3);
}
function decode7(multihash) {
  const bytes3 = coerce(multihash);
  const [code33, sizeOffset] = decode6(bytes3);
  const [size, digestOffset] = decode6(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code33, size, digest27, bytes3);
}
function equals3(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals2(a.bytes, data.bytes);
  }
}
var Digest = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
var code = 0;
var name = "identity";
var encode6 = coerce;
function digest(input) {
  return create(code, encode6(input));
}
var identity2 = { code, name, encode: encode6, digest };

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/hasher.js
function from2({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher(name29, code33, encode116);
}
var Hasher = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest27) => create(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/protons-runtime/node_modules/multiformats/dist/src/cid.js
function format(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV0(bytes3, baseCache(link), base45 ?? base58btc.encoder);
    default:
      return toStringV1(bytes3, baseCache(link), base45 ?? base32.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache28 = cache.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals3(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format(this, base45);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID(version3, code33, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode7(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode6(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base45 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base45 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV0(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version3, code33, multihash) {
  const codeOffset = encodingLength2(version3);
  const hashOffset = codeOffset + encodingLength2(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes3, 0);
  encodeTo(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/protons-runtime/node_modules/multiformats/dist/src/basics.js
var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports2 };

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string = createCodec("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe4(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/protons-runtime/node_modules/uint8arrays/dist/src/from-string.js
function fromString2(string27, encoding = "utf8") {
  const base45 = bases_default[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/protons-runtime/dist/src/utils/pool.js
function pool(size) {
  const SIZE = size ?? 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return function poolAlloc(size2) {
    if (size2 < 1 || size2 > MAX) {
      return allocUnsafe4(size2);
    }
    if (offset + size2 > SIZE) {
      slab = allocUnsafe4(SIZE);
      offset = 0;
    }
    const buf3 = slab.subarray(offset, offset += size2);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf3;
  };
}

// node_modules/protons-runtime/dist/src/utils/writer.js
var Op = class {
  /**
   * Function to call
   */
  fn;
  /**
   * Value byte length
   */
  len;
  /**
   * Next operation
   */
  next;
  /**
   * Value to write
   */
  val;
  constructor(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
};
function noop() {
}
var State = class {
  /**
   * Current head
   */
  head;
  /**
   * Current tail
   */
  tail;
  /**
   * Current buffer length
   */
  len;
  /**
   * Next state
   */
  next;
  constructor(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
};
var bufferPool = pool();
function alloc2(size) {
  if (globalThis.Buffer != null) {
    return allocUnsafe4(size);
  }
  return bufferPool(size);
}
var Uint8ArrayWriter = class {
  /**
   * Current length
   */
  len;
  /**
   * Operations head
   */
  head;
  /**
   * Operations tail
   */
  tail;
  /**
   * Linked forked states
   */
  states;
  constructor() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value) {
    const bits2 = LongBits.fromBigInt(value);
    return this._push(writeVarint64, bits2.length(), bits2);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value) {
    return this._push(encodeUint8Array, encodingLength(value), value);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value) {
    return this.uint64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value) {
    return this.uint64(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value) {
    return this.uint64Number(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value) {
    return this.uint64String(value);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value) {
    const bits2 = LongBits.fromBigInt(value).zzEncode();
    return this._push(writeVarint64, bits2.length(), bits2);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value) {
    const bits2 = LongBits.fromNumber(value).zzEncode();
    return this._push(writeVarint64, bits2.length(), bits2);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value) {
    return this.sint64(BigInt(value));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value) {
    return this.fixed32(value);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value) {
    const bits2 = LongBits.fromBigInt(value);
    return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value) {
    const bits2 = LongBits.fromNumber(value);
    return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value) {
    return this.fixed64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value) {
    return this.fixed64(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value) {
    return this.fixed64Number(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value) {
    return this.fixed64String(value);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value) {
    return this._push(writeFloatLE, 4, value);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value) {
    return this._push(writeDoubleLE, 8, value);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value) {
    const len = value.length >>> 0;
    if (len === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len)._push(writeBytes, len, value);
  }
  /**
   * Writes a string
   */
  string(value) {
    const len = length(value);
    return len !== 0 ? this.uint32(len)._push(write, len, value) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len = this.len;
    this.reset().uint32(len);
    if (len !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf3 = alloc2(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf3, pos);
      pos += head.len;
      head = head.next;
    }
    return buf3;
  }
};
function writeByte(val, buf3, pos) {
  buf3[pos] = val & 255;
}
function writeVarint32(val, buf3, pos) {
  while (val > 127) {
    buf3[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf3[pos] = val;
}
var VarintOp = class extends Op {
  next;
  constructor(len, val) {
    super(writeVarint32, len, val);
    this.next = void 0;
  }
};
function writeVarint64(val, buf3, pos) {
  while (val.hi !== 0) {
    buf3[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf3[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf3[pos++] = val.lo;
}
function writeFixed32(val, buf3, pos) {
  buf3[pos] = val & 255;
  buf3[pos + 1] = val >>> 8 & 255;
  buf3[pos + 2] = val >>> 16 & 255;
  buf3[pos + 3] = val >>> 24;
}
function writeBytes(val, buf3, pos) {
  buf3.set(val, pos);
}
if (globalThis.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value) {
    const len = value.length >>> 0;
    this.uint32(len);
    if (len > 0) {
      this._push(writeBytesBuffer, len, value);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value) {
    const len = globalThis.Buffer.byteLength(value);
    this.uint32(len);
    if (len > 0) {
      this._push(writeStringBuffer, len, value);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf3, pos) {
  buf3.set(val, pos);
}
function writeStringBuffer(val, buf3, pos) {
  if (val.length < 40) {
    write(val, buf3, pos);
  } else if (buf3.utf8Write != null) {
    buf3.utf8Write(val, pos);
  } else {
    buf3.set(fromString2(val), pos);
  }
}
function createWriter() {
  return new Uint8ArrayWriter();
}

// node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w2 = createWriter();
  codec.encode(message2, w2, {
    lengthDelimited: false
  });
  return w2.finish();
}

// node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name29, type, encode116, decode144) {
  return {
    name: name29,
    type,
    encode: encode116,
    decode: decode144
  };
}

// node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode116 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode144 = function enumDecode(reader) {
    const val = reader.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode116, decode144);
}

// node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode116, decode144) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode116, decode144);
}

// node_modules/protons-runtime/dist/src/index.js
var CodeError2 = class extends Error {
  code;
  constructor(message2, code33) {
    super(message2);
    this.code = code33;
  }
};

// node_modules/@helia/bitswap/node_modules/uint8arrays/dist/src/alloc.js
function alloc3(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe5(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@helia/bitswap/dist/src/pb/message.js
var WantType;
(function(WantType2) {
  WantType2["WantBlock"] = "WantBlock";
  WantType2["WantHave"] = "WantHave";
})(WantType || (WantType = {}));
var __WantTypeValues;
(function(__WantTypeValues2) {
  __WantTypeValues2[__WantTypeValues2["WantBlock"] = 0] = "WantBlock";
  __WantTypeValues2[__WantTypeValues2["WantHave"] = 1] = "WantHave";
})(__WantTypeValues || (__WantTypeValues = {}));
(function(WantType2) {
  WantType2.codec = () => {
    return enumeration(__WantTypeValues);
  };
})(WantType || (WantType = {}));
var WantlistEntry;
(function(WantlistEntry2) {
  let _codec;
  WantlistEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.cid);
        }
        if (obj.priority != null && obj.priority !== 0) {
          w2.uint32(16);
          w2.int32(obj.priority);
        }
        if (obj.cancel != null) {
          w2.uint32(24);
          w2.bool(obj.cancel);
        }
        if (obj.wantType != null) {
          w2.uint32(32);
          WantType.codec().encode(obj.wantType, w2);
        }
        if (obj.sendDontHave != null) {
          w2.uint32(40);
          w2.bool(obj.sendDontHave);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          cid: alloc3(0),
          priority: 0
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.priority = reader.int32();
              break;
            }
            case 3: {
              obj.cancel = reader.bool();
              break;
            }
            case 4: {
              obj.wantType = WantType.codec().decode(reader);
              break;
            }
            case 5: {
              obj.sendDontHave = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WantlistEntry2.encode = (obj) => {
    return encodeMessage(obj, WantlistEntry2.codec());
  };
  WantlistEntry2.decode = (buf3, opts) => {
    return decodeMessage(buf3, WantlistEntry2.codec(), opts);
  };
})(WantlistEntry || (WantlistEntry = {}));
var Wantlist;
(function(Wantlist2) {
  let _codec;
  Wantlist2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.entries != null) {
          for (const value of obj.entries) {
            w2.uint32(10);
            WantlistEntry.codec().encode(value, w2);
          }
        }
        if (obj.full != null) {
          w2.uint32(16);
          w2.bool(obj.full);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          entries: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.entries != null && obj.entries.length === opts.limits.entries) {
                throw new CodeError2('decode error - map field "entries" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.entries.push(WantlistEntry.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.entries$
              }));
              break;
            }
            case 2: {
              obj.full = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Wantlist2.encode = (obj) => {
    return encodeMessage(obj, Wantlist2.codec());
  };
  Wantlist2.decode = (buf3, opts) => {
    return decodeMessage(buf3, Wantlist2.codec(), opts);
  };
})(Wantlist || (Wantlist = {}));
var Block;
(function(Block2) {
  let _codec;
  Block2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.prefix != null && obj.prefix.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.prefix);
        }
        if (obj.data != null && obj.data.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          prefix: alloc3(0),
          data: alloc3(0)
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.prefix = reader.bytes();
              break;
            }
            case 2: {
              obj.data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Block2.encode = (obj) => {
    return encodeMessage(obj, Block2.codec());
  };
  Block2.decode = (buf3, opts) => {
    return decodeMessage(buf3, Block2.codec(), opts);
  };
})(Block || (Block = {}));
var BlockPresenceType;
(function(BlockPresenceType2) {
  BlockPresenceType2["HaveBlock"] = "HaveBlock";
  BlockPresenceType2["DontHaveBlock"] = "DontHaveBlock";
})(BlockPresenceType || (BlockPresenceType = {}));
var __BlockPresenceTypeValues;
(function(__BlockPresenceTypeValues2) {
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["HaveBlock"] = 0] = "HaveBlock";
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["DontHaveBlock"] = 1] = "DontHaveBlock";
})(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));
(function(BlockPresenceType2) {
  BlockPresenceType2.codec = () => {
    return enumeration(__BlockPresenceTypeValues);
  };
})(BlockPresenceType || (BlockPresenceType = {}));
var BlockPresence;
(function(BlockPresence2) {
  let _codec;
  BlockPresence2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.cid);
        }
        if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {
          w2.uint32(16);
          BlockPresenceType.codec().encode(obj.type, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          cid: alloc3(0),
          type: BlockPresenceType.HaveBlock
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.type = BlockPresenceType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BlockPresence2.encode = (obj) => {
    return encodeMessage(obj, BlockPresence2.codec());
  };
  BlockPresence2.decode = (buf3, opts) => {
    return decodeMessage(buf3, BlockPresence2.codec(), opts);
  };
})(BlockPresence || (BlockPresence = {}));
var BitswapMessage;
(function(BitswapMessage2) {
  let _codec;
  BitswapMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.wantlist != null) {
          w2.uint32(10);
          Wantlist.codec().encode(obj.wantlist, w2);
        }
        if (obj.blocks != null) {
          for (const value of obj.blocks) {
            w2.uint32(26);
            Block.codec().encode(value, w2);
          }
        }
        if (obj.blockPresences != null) {
          for (const value of obj.blockPresences) {
            w2.uint32(34);
            BlockPresence.codec().encode(value, w2);
          }
        }
        if (obj.pendingBytes != null && obj.pendingBytes !== 0) {
          w2.uint32(40);
          w2.int32(obj.pendingBytes);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          blocks: [],
          blockPresences: [],
          pendingBytes: 0
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.wantlist = Wantlist.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.wantlist
              });
              break;
            }
            case 3: {
              if (opts.limits?.blocks != null && obj.blocks.length === opts.limits.blocks) {
                throw new CodeError2('decode error - map field "blocks" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.blocks.push(Block.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.blocks$
              }));
              break;
            }
            case 4: {
              if (opts.limits?.blockPresences != null && obj.blockPresences.length === opts.limits.blockPresences) {
                throw new CodeError2('decode error - map field "blockPresences" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.blockPresences.push(BlockPresence.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.blockPresences$
              }));
              break;
            }
            case 5: {
              obj.pendingBytes = reader.int32();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BitswapMessage2.encode = (obj) => {
    return encodeMessage(obj, BitswapMessage2.codec());
  };
  BitswapMessage2.decode = (buf3, opts) => {
    return decodeMessage(buf3, BitswapMessage2.codec(), opts);
  };
})(BitswapMessage || (BitswapMessage = {}));

// node_modules/@helia/bitswap/dist/src/utils/merge-messages.js
function mergeMessages(existingMessage, newMessage) {
  for (const [key, entry] of newMessage.wantlist.entries()) {
    const existingEntry = existingMessage.wantlist.get(key);
    if (existingEntry != null) {
      if (existingEntry.priority > entry.priority) {
        entry.priority = existingEntry.priority;
      }
      entry.cancel = entry.cancel ?? existingEntry.cancel;
      entry.wantType = entry.wantType ?? existingEntry.wantType;
      entry.sendDontHave = entry.sendDontHave ?? existingEntry.sendDontHave;
    }
    existingMessage.wantlist.set(key, entry);
  }
  for (const [key, blockPresence] of newMessage.blockPresences.entries()) {
    existingMessage.blockPresences.set(key, blockPresence);
  }
  for (const [key, block] of newMessage.blocks.entries()) {
    existingMessage.blocks.set(key, block);
  }
  if (newMessage.full && !existingMessage.full) {
    existingMessage.full = true;
  }
  return existingMessage;
}

// node_modules/@helia/bitswap/dist/src/utils/split-message.js
var MAX_BLOCK_SIZE = 4193648;
var MAX_ENCODED_BLOCK_SIZE = MAX_BLOCK_SIZE + 16;
function* splitMessage(message2, maxSize) {
  const wantListEntries = [...message2.wantlist.values()];
  const blockPresences = [...message2.blockPresences.values()];
  const blocks = [...message2.blocks.values()];
  let wantListIndex = 0;
  let blockPresencesIndex = 0;
  let blocksIndex = 0;
  let doneSending = false;
  while (true) {
    const subMessage = {
      wantlist: {
        full: message2.full ?? false,
        entries: []
      },
      blockPresences: [],
      blocks: [],
      pendingBytes: 0
    };
    let size = BitswapMessage.encode(subMessage).byteLength;
    let { added, hasMore, newSize } = addToMessage(blocks, subMessage.blocks, blocksIndex, maxSize, size, calculateEncodedBlockSize);
    blocksIndex += added;
    size = newSize;
    const haveMoreBlocks = hasMore;
    ({ added, hasMore, newSize } = addToMessage(blockPresences, subMessage.blockPresences, blockPresencesIndex, maxSize, size, calculateEncodedBlockPresenceSize));
    blockPresencesIndex += added;
    size = newSize;
    const haveMorePresences = hasMore;
    ({ added, hasMore, newSize } = addToMessage(wantListEntries, subMessage.wantlist.entries, wantListIndex, maxSize, size, calculateEncodedWantlistEntrySize));
    wantListIndex += added;
    size = newSize;
    const haveMoreWantlistEntries = hasMore;
    doneSending = !haveMoreBlocks && !haveMorePresences && !haveMoreWantlistEntries;
    if (!doneSending) {
      subMessage.wantlist.full = false;
    }
    yield BitswapMessage.encode(subMessage);
    if (doneSending) {
      break;
    }
  }
}
function addToMessage(input, output3, start2, maxSize, size, calculateSize) {
  let added = 0;
  let hasMore = false;
  for (let i = start2; i < input.length; i++) {
    const item = input[i];
    const itemSize = calculateSize(item);
    if (itemSize > MAX_ENCODED_BLOCK_SIZE) {
      throw new CodeError("Cannot send block as after encoding it is over the max message size", "ERR_BLOCK_TOO_LARGE");
    }
    const newSize = size + itemSize;
    if (newSize > maxSize) {
      hasMore = true;
      break;
    }
    output3.push(item);
    added++;
    size = newSize;
  }
  return { hasMore, added, newSize: size };
}
function calculateEncodedBlockSize(block) {
  return calculateLength(3, Block.encode(block));
}
function calculateEncodedBlockPresenceSize(blockPresence) {
  return calculateLength(4, BlockPresence.encode(blockPresence));
}
function calculateEncodedWantlistEntrySize(entry) {
  return calculateLength(1, WantlistEntry.encode(entry));
}
function calculateLength(fieldNumber, data) {
  const fieldNumberLength = encodingLength(fieldNumber);
  const dataLengthLength = encodingLength(data.byteLength);
  return fieldNumberLength + dataLengthLength + data.byteLength;
}

// node_modules/@helia/bitswap/dist/src/network.js
var Network = class extends TypedEventEmitter {
  log;
  libp2p;
  routing;
  protocols;
  running;
  maxInboundStreams;
  maxOutboundStreams;
  messageReceiveTimeout;
  registrarIds;
  metrics;
  sendQueue;
  runOnTransientConnections;
  maxOutgoingMessageSize;
  maxIncomingMessageSize;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("helia:bitswap:network");
    this.libp2p = components.libp2p;
    this.routing = components.routing;
    this.protocols = init.protocols ?? [BITSWAP_120];
    this.registrarIds = [];
    this.running = false;
    this._onStream = this._onStream.bind(this);
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this.messageReceiveTimeout = init.messageReceiveTimeout ?? DEFAULT_MESSAGE_RECEIVE_TIMEOUT;
    this.runOnTransientConnections = init.runOnTransientConnections ?? DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS;
    this.maxIncomingMessageSize = init.maxIncomingMessageSize ?? DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;
    this.maxOutgoingMessageSize = init.maxOutgoingMessageSize ?? init.maxIncomingMessageSize ?? DEFAULT_MAX_INCOMING_MESSAGE_SIZE;
    this.metrics = {
      blocksSent: components.metrics?.registerCounter("helia_bitswap_sent_blocks_total"),
      dataSent: components.metrics?.registerCounter("helia_bitswap_sent_data_bytes_total")
    };
    this.sendQueue = new PeerQueue({
      concurrency: init.messageSendConcurrency ?? DEFAULT_MESSAGE_SEND_CONCURRENCY,
      metrics: components.metrics,
      metricName: "helia_bitswap_message_send_queue"
    });
    this.sendQueue.addEventListener("error", (evt) => {
      this.log.error("error sending wantlist to peer", evt.detail);
    });
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.libp2p.handle(this.protocols, this._onStream, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnections
    });
    const topology = {
      onConnect: (peerId2) => {
        this.safeDispatchEvent("peer:connected", {
          detail: peerId2
        });
      },
      onDisconnect: (peerId2) => {
        this.safeDispatchEvent("peer:disconnected", {
          detail: peerId2
        });
      }
    };
    this.registrarIds = [];
    for (const protocol of this.protocols) {
      this.registrarIds.push(await this.libp2p.register(protocol, topology));
    }
    this.libp2p.getConnections().forEach((conn) => {
      this.safeDispatchEvent("peer:connected", {
        detail: conn.remotePeer
      });
    });
  }
  async stop() {
    this.running = false;
    await this.libp2p.unhandle(this.protocols);
    if (this.registrarIds != null) {
      for (const id of this.registrarIds) {
        this.libp2p.unregister(id);
      }
      this.registrarIds = [];
    }
  }
  /**
   * Handles incoming bitswap messages
   */
  _onStream(info) {
    if (!this.running) {
      return;
    }
    const { stream, connection } = info;
    Promise.resolve().then(async () => {
      this.log("incoming new bitswap %s stream from %p", stream.protocol, connection.remotePeer);
      const abortListener = () => {
        if (stream.status === "open") {
          stream.abort(new CodeError(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`, "ERR_TIMEOUT"));
        } else {
          this.log("stream aborted with status %s", stream.status);
        }
      };
      let signal = AbortSignal.timeout(this.messageReceiveTimeout);
      setMaxListeners2(Infinity, signal);
      signal.addEventListener("abort", abortListener);
      await stream.closeWrite();
      await pipe(stream, (source) => decode2(source, {
        maxDataLength: this.maxIncomingMessageSize
      }), async (source) => {
        for await (const data of source) {
          try {
            const message2 = BitswapMessage.decode(data);
            this.log("incoming new bitswap %s message from %p on stream", stream.protocol, connection.remotePeer, stream.id);
            this.safeDispatchEvent("bitswap:message", {
              detail: {
                peer: connection.remotePeer,
                message: message2
              }
            });
            signal.removeEventListener("abort", abortListener);
            signal = AbortSignal.timeout(this.messageReceiveTimeout);
            setMaxListeners2(Infinity, signal);
            signal.addEventListener("abort", abortListener);
          } catch (err) {
            this.log.error("error reading incoming bitswap message from %p on stream", connection.remotePeer, stream.id, err);
            stream.abort(err);
            break;
          }
        }
      });
    }).catch((err) => {
      this.log.error("error handling incoming stream from %p", connection.remotePeer, err);
      stream.abort(err);
    });
  }
  /**
   * Find bitswap providers for a given `cid`.
   */
  async *findProviders(cid, options2) {
    options2?.onProgress?.(new CustomProgressEvent("bitswap:network:find-providers", cid));
    for await (const provider of this.routing.findProviders(cid, options2)) {
      const dialable = await this.libp2p.isDialable(provider.multiaddrs, {
        runOnTransientConnection: this.runOnTransientConnections
      });
      if (!dialable) {
        continue;
      }
      yield provider;
    }
  }
  /**
   * Find the providers of a given `cid` and connect to them.
   */
  async findAndConnect(cid, options2) {
    await src_default(src_default3(src_default5(this.findProviders(cid, options2), options2?.maxProviders ?? DEFAULT_MAX_PROVIDERS_PER_REQUEST), async (provider) => this.connectTo(provider.id, options2))).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Connect to the given peer
   * Send the given msg (instance of Message) to the given peer
   */
  async sendMessage(peerId2, message2, options2) {
    if (!this.running) {
      throw new Error("network isn't running");
    }
    const existingJob = this.sendQueue.queue.find((job) => {
      return peerId2.equals(job.options.peerId) && job.status === "queued";
    });
    if (existingJob != null) {
      existingJob.options.message = mergeMessages(existingJob.options.message, message2);
      await existingJob.join({
        signal: options2?.signal
      });
      return;
    }
    await this.sendQueue.add(async (options3) => {
      const message3 = options3?.message;
      if (message3 == null) {
        throw new CodeError("No message to send", "ERR_NO_MESSAGE");
      }
      this.log("sendMessage to %p", peerId2);
      options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist", peerId2));
      const stream = await this.libp2p.dialProtocol(peerId2, BITSWAP_120, options3);
      await stream.closeRead();
      try {
        await pipe(splitMessage(message3, this.maxOutgoingMessageSize), (source) => encode2(source), stream);
        await stream.close(options3);
      } catch (err) {
        options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist:error", { peer: peerId2, error: err }));
        this.log.error("error sending message to %p", peerId2, err);
        stream.abort(err);
      }
      this._updateSentStats(message3.blocks);
    }, {
      peerId: peerId2,
      signal: options2?.signal,
      message: message2
    });
  }
  /**
   * Connects to another peer
   */
  async connectTo(peer, options2) {
    if (!this.running) {
      throw new CodeError("Network isn't running", "ERR_NOT_STARTED");
    }
    options2?.onProgress?.(new CustomProgressEvent("bitswap:network:dial", peer));
    const [connection] = await Promise.all([
      this.libp2p.dial(peer, options2),
      raceEvent(this.libp2p, "peer:identify", options2?.signal, {
        filter: (evt) => {
          if (!evt.detail.peerId.equals(peer)) {
            return false;
          }
          if (evt.detail.protocols.includes(BITSWAP_120)) {
            return true;
          }
          throw new CodeError(`${peer} did not support ${BITSWAP_120}`, "ERR_BITSWAP_UNSUPPORTED_BY_PEER");
        }
      })
    ]);
    return connection;
  }
  _updateSentStats(blocks) {
    let bytes3 = 0;
    for (const block of blocks.values()) {
      bytes3 += block.data.byteLength;
    }
    this.metrics.dataSent?.increment(bytes3);
    this.metrics.blocksSent?.increment(blocks.size);
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bytes.js
var empty2 = new Uint8Array(0);
function equals4(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString3(str) {
  return new TextEncoder().encode(str);
}
function toString2(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src2 = base3;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base.js
var Encoder2 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or2(left, right) {
  return new ComposedDecoder2({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec2 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name29, prefix, baseEncode);
    this.decoder = new Decoder2(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from3({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec2(name29, prefix, encode116, decode144);
}
function baseX2({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default2(alphabet27, name29);
  return from3({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce2(decode144(text))
  });
}
function decode8(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode7(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46482({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from3({
    prefix,
    name: name29,
    encode(input) {
      return encode7(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode8(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base22
});
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode8(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode9(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode8,
  decode: decode9
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var identity3 = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString2(buf3),
  decode: (str) => fromString3(str)
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/varint.js
var encode_12 = encode9;
var MSB3 = 128;
var REST3 = 127;
var MSBALL2 = ~REST3;
var INT2 = Math.pow(2, 31);
function encode9(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode9.bytes = offset - oldOffset + 1;
  return out;
}
var decode10 = read3;
var MSB$12 = 128;
var REST$12 = 127;
function read3(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode10,
  encodingLength: length3
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/varint.js
function decode11(data, offset = 0) {
  const code33 = varint_default2.decode(data, offset);
  return [code33, varint_default2.decode.bytes];
}
function encodeTo2(int, target, offset = 0) {
  varint_default2.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default2.encodingLength(int);
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/digest.js
function create2(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength3(code33);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo2(code33, bytes3, 0);
  encodeTo2(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest2(code33, size, digest27, bytes3);
}
function decode12(multihash) {
  const bytes3 = coerce2(multihash);
  const [code33, sizeOffset] = decode11(bytes3);
  const [size, digestOffset] = decode11(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code33, size, digest27, bytes3);
}
function equals5(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals4(a.bytes, data.bytes);
  }
}
var Digest2 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/identity.js
var code2 = 0;
var name2 = "identity";
var encode10 = coerce2;
function digest2(input) {
  return create2(code2, encode10(input));
}
var identity4 = { code: code2, name: name2, encode: encode10, digest: digest2 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2562,
  sha512: () => sha5122
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/hasher.js
function from4({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher2(name29, code33, encode116);
}
var Hasher2 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest27) => create2(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha2(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2562 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5122 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/cid.js
function format2(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV02(bytes3, baseCache2(link), base45 ?? base58btc2.encoder);
    default:
      return toStringV12(bytes3, baseCache2(link), base45 ?? base322.encoder);
  }
}
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache28 = cache2.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID2 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create2(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals5(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format2(this, base45);
  }
  toJSON() {
    return { "/": format2(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID2(version3, code33, multihash.bytes));
    } else if (value[cidSymbol2] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode12(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID2(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE2, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode11(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE2;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes2(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes2(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base45 ?? base58btc2;
      return [base58btc2.prefix, decoder.decode(source)];
    }
    case base322.prefix: {
      const decoder = base45 ?? base322;
      return [base322.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV02(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV12(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
function encodeCID2(version3, code33, multihash) {
  const codeOffset = encodingLength3(version3);
  const hashOffset = codeOffset + encodingLength3(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version3, bytes3, 0);
  encodeTo2(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js
function equals6(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe6(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec3(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string2 = createCodec3("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii2 = createCodec3("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe6(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases2.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases2
};
var bases_default2 = BASES2;

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/from-string.js
function fromString4(string27, encoding = "utf8") {
  const base45 = bases_default2[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/to-string.js
function toString3(array, encoding = "utf8") {
  const base45 = bases_default2[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/peer-id/dist/src/index.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases2).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases2.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  type;
  multihash;
  privateKey;
  publicKey;
  string;
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [peerIdSymbol] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc2.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID2.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals6(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals6(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  type = "RSA";
  publicKey;
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  type = "Ed25519";
  publicKey;
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  type = "secp256k1";
  publicKey;
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.publicKey = init.multihash.digest;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var URLPeerIdImpl = class {
  type = "url";
  multihash;
  privateKey;
  publicKey;
  url;
  constructor(url) {
    this.url = url.toString();
    this.multihash = identity4.digest(fromString4(this.url));
  }
  [inspect]() {
    return `PeerId(${this.url})`;
  }
  [peerIdSymbol] = true;
  toString() {
    return this.toCID().toString();
  }
  toCID() {
    return CID2.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.multihash);
  }
  toBytes() {
    return this.toCID().bytes;
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString3(other);
    }
    return other.toString() === this.toString();
  }
};
function peerIdFromPeerId(other) {
  if (other.type === "RSA") {
    return new RSAPeerIdImpl(other);
  }
  if (other.type === "Ed25519") {
    return new Ed25519PeerIdImpl(other);
  }
  if (other.type === "secp256k1") {
    return new Secp256k1PeerIdImpl(other);
  }
  throw new CodeError("Not a PeerId", "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode12(base58btc2.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf3) {
  try {
    const multihash = decode12(buf3);
    if (multihash.code === identity4.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2562.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID2.decode(buf3));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {
    const url = toString3(cid.multihash.digest);
    return new URLPeerIdImpl(new URL(url));
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2562.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity4.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create2(identity4.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create2(identity4.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha2562.digest(publicKey), publicKey, privateKey });
}

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map6) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map6(val)
      };
    }
  };
  return iterator;
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  map;
  constructor(map6) {
    this.map = /* @__PURE__ */ new Map();
    if (map6 != null) {
      for (const [key, value] of map6.entries()) {
        this.map.set(key.toString(), value);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), value);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  set;
  constructor(set) {
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId2 = peerIdFromString(val[0]);
      return [peerId2, peerId2];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output3 = new _PeerSet();
    for (const peerId2 of other) {
      if (this.has(peerId2)) {
        output3.add(peerId2);
      }
    }
    return output3;
  }
  difference(other) {
    const output3 = new _PeerSet();
    for (const peerId2 of this) {
      if (!other.has(peerId2)) {
        output3.add(peerId2);
      }
    }
    return output3;
  }
  union(other) {
    const output3 = new _PeerSet();
    for (const peerId2 of other) {
      output3.add(peerId2);
    }
    for (const peerId2 of this) {
      output3.add(peerId2);
    }
    return output3;
  }
};

// node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js
var webcrypto_browser_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto?.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};

// node_modules/@libp2p/crypto/dist/src/hmac/lengths.js
var lengths_default = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};

// node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js
var hashTypes = {
  SHA1: "SHA-1",
  SHA256: "SHA-256",
  SHA512: "SHA-512"
};
var sign = async (key, data) => {
  const buf3 = await webcrypto_browser_default.get().subtle.sign({ name: "HMAC" }, key, data);
  return new Uint8Array(buf3, 0, buf3.byteLength);
};
async function create3(hashType, secret) {
  const hash2 = hashTypes[hashType];
  const key = await webcrypto_browser_default.get().subtle.importKey("raw", secret, {
    name: "HMAC",
    hash: { name: hash2 }
  }, false, ["sign"]);
  return {
    async digest(data) {
      return sign(key, data);
    },
    length: lengths_default[hashType]
  };
}

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var keys_exports2 = {};
__export(keys_exports2, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateEphemeralKeyPair: () => ephemeral_keys_default,
  generateKeyPair: () => generateKeyPair4,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed2,
  importKey: () => importKey,
  keyStretcher: () => keyStretcher,
  keysPBM: () => keys_exports,
  marshalPrivateKey: () => marshalPrivateKey,
  marshalPublicKey: () => marshalPublicKey2,
  supportedKeys: () => supportedKeys,
  unmarshalPrivateKey: () => unmarshalPrivateKey3,
  unmarshalPublicKey: () => unmarshalPublicKey2
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc3,
  base58flickr: () => base58flickr3
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bytes.js
var empty3 = new Uint8Array(0);
function equals7(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString5(str) {
  return new TextEncoder().encode(str);
}
function toString4(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/base-x.js
function base4(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src3 = base4;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base.js
var Encoder3 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or3(left, right) {
  return new ComposedDecoder3({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec3 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name29, prefix, baseEncode);
    this.decoder = new Decoder3(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from5({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec3(name29, prefix, encode116, decode144);
}
function baseX3({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default3(alphabet27, name29);
  return from5({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce3(decode144(text))
  });
}
function decode13(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode11(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46483({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from5({
    prefix,
    name: name29,
    encode(input) {
      return encode11(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode13(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/varint.js
var encode_13 = encode12;
var MSB4 = 128;
var REST4 = 127;
var MSBALL3 = ~REST4;
var INT3 = Math.pow(2, 31);
function encode12(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode12.bytes = offset - oldOffset + 1;
  return out;
}
var decode14 = read4;
var MSB$13 = 128;
var REST$13 = 127;
function read4(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length4 = function(value) {
  return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode14,
  encodingLength: length4
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/varint.js
function decode15(data, offset = 0) {
  const code33 = varint_default3.decode(data, offset);
  return [code33, varint_default3.decode.bytes];
}
function encodeTo3(int, target, offset = 0) {
  varint_default3.encode(int, target, offset);
  return target;
}
function encodingLength4(int) {
  return varint_default3.encodingLength(int);
}

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/digest.js
function create4(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength4(code33);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo3(code33, bytes3, 0);
  encodeTo3(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest3(code33, size, digest27, bytes3);
}
function decode16(multihash) {
  const bytes3 = coerce3(multihash);
  const [code33, sizeOffset] = decode15(bytes3);
  const [size, digestOffset] = decode15(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code33, size, digest27, bytes3);
}
function equals8(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals7(a.bytes, data.bytes);
  }
}
var Digest3 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/identity.js
var code3 = 0;
var name3 = "identity";
var encode13 = coerce3;
function digest3(input) {
  return create4(code3, encode13(input));
}
var identity5 = { code: code3, name: name3, encode: encode13, digest: digest3 };

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2563,
  sha512: () => sha5123
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/hasher.js
function from6({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher3(name29, code33, encode116);
}
var Hasher3 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest27) => create4(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha3(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2563 = from6({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5123 = from6({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/equals.js
function equals9(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe7(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf3) {
  return buf3;
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe7(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output3);
}

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});
var base103 = baseX3({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
var base163 = rfc46483({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc46483({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base23
});
var base23 = rfc46483({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = alphabet3.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes3 = alphabet3.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode14(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
function decode17(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes3[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji3 = from5({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode14,
  decode: decode17
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base323,
  base32hex: () => base32hex3,
  base32hexpad: () => base32hexpad3,
  base32hexpadupper: () => base32hexpadupper3,
  base32hexupper: () => base32hexupper3,
  base32pad: () => base32pad3,
  base32padupper: () => base32padupper3,
  base32upper: () => base32upper3,
  base32z: () => base32z3
});
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base363,
  base36upper: () => base36upper3
});
var base363 = baseX3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
var base83 = rfc46483({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});
var identity6 = from5({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString4(buf3),
  decode: (str) => fromString5(str)
});

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/cid.js
function format3(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV03(bytes3, baseCache3(link), base45 ?? base58btc3.encoder);
    default:
      return toStringV13(bytes3, baseCache3(link), base45 ?? base323.encoder);
  }
}
var cache3 = /* @__PURE__ */ new WeakMap();
function baseCache3(cid) {
  const baseCache28 = cache3.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID3 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create4(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals8(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format3(this, base45);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID3(version3, code33, multihash.bytes));
    } else if (value[cidSymbol3] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode16(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID3(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE3, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode15(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE3;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes3(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes3(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base45 ?? base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base45 ?? base323;
      return [base323.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV03(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
function encodeCID3(version3, code33, multihash) {
  const codeOffset = encodingLength4(version3);
  const hashOffset = codeOffset + encodingLength4(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version3, bytes3, 0);
  encodeTo3(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/basics.js
var bases3 = { ...identity_exports6, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports5 };

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec4(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string3 = createCodec4("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii3 = createCodec4("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe7(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases3.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases3
};
var bases_default3 = BASES3;

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/from-string.js
function fromString6(string27, encoding = "utf8") {
  const base45 = bases_default3[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/crypto/dist/src/util.js
function base64urlToBuffer(str, len) {
  let buf3 = fromString6(str, "base64urlpad");
  if (len != null) {
    if (buf3.length > len)
      throw new Error("byte array longer than desired length");
    buf3 = concat2([new Uint8Array(len - buf3.length), buf3]);
  }
  return buf3;
}
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h2.outputLen);
  number(h2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word2, shift) => word2 << 32 - shift | word2 >>> shift;
var rotl = (word2, shift) => word2 << shift | word2 >>> 32 - shift >>> 0;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take4 = Math.min(blockLen - this.pos, len - pos);
      if (take4 === blockLen) {
        const dataView3 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView3, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take4), this.pos);
      this.pos += take4;
      pos += take4;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length30, finished, destroyed, pos } = this;
    to.length = length30;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length30 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
};

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
var toBig = (h2, l) => BigInt(h2 >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h2, _l, s2) => h2 >>> s2;
var shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
var rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
var rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
var rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
var rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
var rotr32H = (_h, l) => l;
var rotr32L = (h2, _l) => h2;
var rotlSH = (h2, l, s2) => h2 << s2 | l >>> 32 - s2;
var rotlSL = (h2, l, s2) => l << s2 | h2 >>> 32 - s2;
var rotlBH = (h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2;
var rotlBL = (h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2;
function add(Ah, Al, Bh, Bl3) {
  const l = (Al >>> 0) + (Bl3 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl3, Cl) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl3, Cl, Dl) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl3, Cl, Dl, El) => (Al >>> 0) + (Bl3 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl3 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl3 ^ Al & Cl ^ Bl3 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl3 | 0;
      Bh = Ah | 0;
      Bl3 = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl3 } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl3 | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl3, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha5124 = /* @__PURE__ */ wrapConstructor(() => new SHA512());

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes2,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(`${title} must be valid boolean, got "${value}".`);
}
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  abytes(bytes3);
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  abytes(bytes3);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h2 = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v = h2();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h2();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators2, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators2))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn) {
  const map6 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map6.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map6.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number4, modulo) {
  if (number4 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
  }
  let a = mod(number4, modulo);
  let b = modulo;
  let x = _0n2, y2 = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n, Q1div2);
    let b = Fp3.pow(n, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m2 = 1;
      for (let t2 = Fp3.sqr(b); m2 < r; m2++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g, _1n2 << BigInt(r - m2 - 1));
      g = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b = Fp3.mul(b, g);
      r = m2;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp3, n) {
      const n2 = Fp3.mul(n, _2n2);
      const v = Fp3.pow(n2, c1);
      const nv = Fp3.mul(n, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n2), v);
      const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map6, val) => {
    map6[val] = "function";
    return map6;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d2 = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d2);
    d2 = f.sqr(d2);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length30 = getFieldBytesLength(fieldOrder);
  return length30 + Math.ceil(length30 / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF(c, bits2) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW = (W) => {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits2)
      throw new Error(`Wrong window size=${W}, should be [1..${bits2}]`);
  };
  const opts = (W) => {
    validateW(W);
    const windows = Math.ceil(bits2 / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d2 = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base45 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base45 = p;
        points.push(base45);
        for (let i = 1; i < windowSize; i++) {
          base45 = base45.add(p);
          points.push(base45);
        }
        p = base45.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, n, transform) {
      const W = pointWindowSizes.get(P) || 1;
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return this.wNAF(W, comp, n);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n3 << BigInt(nByteLength * 8) - _1n4;
  const modP = Fp3.create;
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u * Fp3.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n4 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes3) => bytes3);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n) {
    aInRange("coordinate " + title, n, _0n4, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y2, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d: d2 } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y: y2 } = p || {};
      aCoordinate("x", x);
      aCoordinate("y", y2);
      return new Point2(x, y2, _1n4, modP(x * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n3 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d: d2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A2 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F2 = modP(B2 - A2);
        if (F2 === _0n4)
          return this.double();
        const C2 = modP(Z1 * _2n3 * T2);
        const D2 = modP(T1 * _2n3 * Z2);
        const E2 = D2 + C2;
        const G3 = B2 + A2;
        const H2 = D2 - C2;
        const X32 = modP(E2 * F2);
        const Y32 = modP(G3 * H2);
        const T32 = modP(E2 * H2);
        const Z32 = modP(F2 * G3);
        return new Point2(X32, Y32, Z32, T32);
      }
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n4, CURVE_ORDER);
      const { p, f } = this.wNAF(n);
      return Point2.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      const n = scalar;
      aInRange("scalar", n, _0n4, CURVE_ORDER);
      if (n === _0n4)
        return I;
      if (this.equals(I) || n === _1n4)
        return this;
      if (this.equals(G))
        return this.wNAF(n).p;
      return wnaf.unsafeLadder(this, n);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a } = CURVE;
      const len = Fp3.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y2, _0n4, max);
      const y22 = modP(y2 * y2);
      const u = modP(y22 - _1n4);
      const v = modP(d2 * y22 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x, y: y2 } = this.toAffine();
      const bytes3 = numberToBytesLE(y2, Fp3.BYTES);
      bytes3[bytes3.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes3;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
  const { BASE: G, ZERO: I } = Point2;
  const wnaf = wNAF(Point2, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options2 = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options2.context, prefix, msg);
    const R = G.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
    const s2 = modN(r + k * scalar);
    aInRange("signature.s", s2, _0n4, CURVE_ORDER);
    const res = concatBytes2(R, numberToBytesLE(s2, Fp3.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options2 = verifyOpts) {
    const { context, zip215 } = options2;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
  }
  G._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes3(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify,
    ExtendedPoint: Point2,
    utils
  };
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P } = CURVE;
  const modP = (n) => mod(n, P);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes3) => bytes3);
  const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, _0n5, P);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    let sw;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  function encodeUCoordinate(u) {
    return numberToBytesLE(modP(u), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u[31] &= 127;
    return bytesToNumberLE(u);
  }
  function decodeScalar(n) {
    const bytes3 = ensureBytes("scalar", n);
    const len = bytes3.length;
    if (len !== montgomeryBytes && len !== fieldLen)
      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
    return bytesToNumberLE(adjustScalarBytes2(bytes3));
  }
  function scalarMult(scalar, u) {
    const pointU = decodeUCoordinate(u);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n5)
      throw new Error("Invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n4, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes3) {
  bytes3[0] &= 248;
  bytes3[31] &= 127;
  bytes3[31] |= 64;
  return bytes3;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow3, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n3,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha5124,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var x25519 = /* @__PURE__ */ (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
    return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
  },
  adjustScalarBytes,
  randomBytes
}))();

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function hashAndSign(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
function hashAndVerify(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create5(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest27 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto3 = webcrypto_browser_default.get();
  keyLength *= 8;
  async function encrypt(data, password) {
    const salt = crypto3.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto3.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString6(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto3.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest27 } };
        const runtimeDerivedEmptyPassword = await crypto3.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto3.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto3.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest27 } };
      const rawKey = await crypto3.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto3.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto3.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat2([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString6(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest27 } };
        const runtimeDerivedEmptyPassword = await crypto3.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto3.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto3.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest27 } };
      const rawKey = await crypto3.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto3.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto3.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt,
    decrypt
  };
  return cipher;
}

// node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter(privateKey, password) {
  const cipher = create5();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base643.encode(encryptedKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var keys_exports = {};
__export(keys_exports, {
  KeyType: () => KeyType,
  PrivateKey: () => PrivateKey,
  PublicKey: () => PublicKey
});
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader);
              break;
            case 2:
              obj.Data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf3) => {
    return decodeMessage(buf3, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader);
              break;
            case 2:
              obj.Data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf3) => {
    return decodeMessage(buf3, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var Ed25519PublicKey = class {
  _key;
  constructor(key) {
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  verify(data, sig) {
    return hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  hash() {
    const p = sha2563.digest(this.bytes);
    if (isPromise(p)) {
      return p.then(({ bytes: bytes3 }) => bytes3);
    }
    return p.bytes;
  }
};
var Ed25519PrivateKey = class {
  _key;
  _publicKey;
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  sign(message2) {
    return hashAndSign(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  async hash() {
    const p = sha2563.digest(this.bytes);
    let bytes3;
    if (isPromise(p)) {
      ({ bytes: bytes3 } = await p);
    } else {
      bytes3 = p.bytes;
    }
    return bytes3;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = identity5.digest(this.public.bytes);
    return base58btc3.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format28 = "libp2p-key") {
    if (format28 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format28}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey(bytes3) {
  if (bytes3.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes3 = ensureKey(bytes3, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes3.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes3.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes3 = ensureKey(bytes3, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes3.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes3.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes3) {
  bytes3 = ensureKey(bytes3, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes3);
}
async function generateKeyPair() {
  const { privateKey, publicKey } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed) {
  const { privateKey, publicKey } = generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length30) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length30) {
    throw new CodeError(`Key must be a Uint8Array of length ${length30}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}

// node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/to-string.js
function toString5(array, encoding = "utf8") {
  const base45 = bases_default3[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js
var bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes = Object.keys(bits);
var names = curveTypes.join(" / ");
async function generateEphmeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const pair2 = await webcrypto_browser_default.get().subtle.generateKey({
    name: "ECDH",
    namedCurve: curve
  }, true, ["deriveBits"]);
  const genSharedKey = async (theirPub, forcePrivate) => {
    let privateKey;
    if (forcePrivate != null) {
      privateKey = await webcrypto_browser_default.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
        name: "ECDH",
        namedCurve: curve
      }, false, ["deriveBits"]);
    } else {
      privateKey = pair2.privateKey;
    }
    const key = await webcrypto_browser_default.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
      name: "ECDH",
      namedCurve: curve
    }, false, []);
    const buffer3 = await webcrypto_browser_default.get().subtle.deriveBits({
      name: "ECDH",
      // @ts-expect-error namedCurve is missing from the types
      namedCurve: curve,
      public: key
    }, privateKey, bits[curve]);
    return new Uint8Array(buffer3, 0, buffer3.byteLength);
  };
  const publicKey = await webcrypto_browser_default.get().subtle.exportKey("jwk", pair2.publicKey);
  const ecdhKey = {
    key: marshalPublicKey(publicKey),
    genSharedKey
  };
  return ecdhKey;
}
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
function marshalPublicKey(jwk) {
  if (jwk.crv == null || jwk.x == null || jwk.y == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  if (jwk.crv !== "P-256" && jwk.crv !== "P-384" && jwk.crv !== "P-521") {
    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[jwk.crv];
  return concat2([
    Uint8Array.from([4]),
    // uncompressed point
    base64urlToBuffer(jwk.x, byteLen),
    base64urlToBuffer(jwk.y, byteLen)
  ], 1 + byteLen * 2);
}
function unmarshalPublicKey(curve, key) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, "ERR_INVALID_CURVE");
  }
  const byteLen = curveLengths[curve];
  if (!equals9(key.subarray(0, 1), Uint8Array.from([4]))) {
    throw new CodeError("Cannot unmarshal public key - invalid key format", "ERR_INVALID_KEY_FORMAT");
  }
  return {
    kty: "EC",
    crv: curve,
    x: toString5(key.subarray(1, byteLen + 1), "base64url"),
    y: toString5(key.subarray(1 + byteLen), "base64url"),
    ext: true
  };
}
var unmarshalPrivateKey = (curve, key) => ({
  ...unmarshalPublicKey(curve, key.public),
  d: toString5(key.private, "base64url")
});

// node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js
var ephemeral_keys_default = generateEphmeralKeyPair;

// node_modules/@libp2p/crypto/dist/src/keys/importer.js
async function importer(privateKey, password) {
  const encryptedKey = base643.decode(privateKey);
  const cipher = create5();
  return cipher.decrypt(encryptedKey, password);
}

// node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js
var cipherMap = {
  "AES-128": {
    ivSize: 16,
    keySize: 16
  },
  "AES-256": {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    keySize: 32
  }
};
async function keyStretcher(cipherType, hash2, secret) {
  const cipher = cipherMap[cipherType];
  if (cipher == null) {
    const allowed = Object.keys(cipherMap).join(" / ");
    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, "ERR_INVALID_CIPHER_TYPE");
  }
  if (hash2 == null) {
    throw new CodeError("missing hash type", "ERR_MISSING_HASH_TYPE");
  }
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed = fromString6("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m2 = await create3(hash2, secret);
  let a = await m2.digest(seed);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m2.digest(concat2([a, seed]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a = await m2.digest(a);
  }
  const half = resultLength / 2;
  const resultBuffer = concat2(result);
  const r1 = resultBuffer.subarray(0, half);
  const r2 = resultBuffer.subarray(half, resultLength);
  const createKey = (res) => ({
    iv: res.subarray(0, ivSize),
    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),
    macKey: res.subarray(ivSize + cipherKeySize)
  });
  return {
    k1: createKey(r1),
    k2: createKey(r2)
  };
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports = {};
__export(rsa_class_exports, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair2,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes2(length30) {
  if (isNaN(length30) || length30 <= 0) {
    throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return randomBytes(length30);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  exportToPem: () => exportToPem,
  importFromPem: () => importFromPem,
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf3) {
    exists(this);
    this.iHash.update(buf3);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash2, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/asn1js/build/index.es.js
var pvtsutils = __toESM(require_build());

// node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1; i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value, base45, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base45);
  for (let i = 1; i < 8; i++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1; j >= 0; j--) {
        const basis = Math.pow(2, j * base45);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base45);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf3 = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf3[0] === 255 && buf3[1] & 128;
    const condition2 = buf3[0] === 0 && (buf3[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0; i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf3[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0; j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf3[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i = 1; i < 8; i++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0; k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0; i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i = 0; i < dif; i++) {
    padding[i] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
var log2 = Math.log(2);

// node_modules/asn1js/build/index.es.js
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat3(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0; i < buffers.length; i++) {
    const buffer3 = buffers[i];
    outputLength += buffer3.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0; i < buffers.length; i++) {
    const buffer3 = buffers[i];
    retView.set(new Uint8Array(buffer3), prevLength);
    prevLength += buffer3.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
var ViewWriter = class {
  constructor() {
    this.items = [];
  }
  write(buf3) {
    this.items.push(buf3);
  }
  final() {
    return concat3(this.items);
  }
};
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a2;
  return _a2 = class Some extends BaseClass {
    constructor(...args) {
      var _a3;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
      this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: pvtsutils.Convert.ToHex(this.valueHexView)
      };
    }
  }, _a2.NAME = "hexBlock", _a2;
}
var LocalBaseBlock = class {
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
};
LocalBaseBlock.NAME = "baseBlock";
var ValueBlock = class extends LocalBaseBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(sizeOnly, writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
};
ValueBlock.NAME = "valueBlock";
var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a2, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
      this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number4 = this.tagNumber;
        number4 &= 31;
        firstOctet |= number4;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0; i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0; i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0; i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0; i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
};
LocalIdentificationBlock.NAME = "identificationBlock";
var LocalLengthBlock = class extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a2, _b, _c;
    super();
    this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0; i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
};
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};
var BaseBlock = class extends LocalBaseBlock {
  constructor({ name: name29 = EMPTY_STRING, optional: optional2 = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name29;
    this.optional = optional2;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return pvtsutils.Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
};
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}
var BaseStringBlock = class extends BaseBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
};
BaseStringBlock.NAME = "BaseStringBlock";
var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
};
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
var Primitive = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
};
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length30) {
  if (indefiniteLength) {
    return 1;
  }
  return length30;
}
var LocalConstructedValueBlock = class extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    for (let i = 0; i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
};
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
var Constructed = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
  }
};
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
var LocalEndOfContentValueBlock = class extends ValueBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    return inputOffset;
  }
  toBER(sizeOnly) {
    return EMPTY_BUFFER;
  }
};
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
var EndOfContent = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
};
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
var Null = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
};
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
var Boolean2 = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
};
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";
var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0; i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
};
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
var OctetString = class _OctetString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf3 = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf3.byteLength) {
          const asn = localFromBER(buf3, 0, buf3.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _OctetString) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return pvtsutils.BufferSourceConverter.concat(array);
  }
};
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf3 = intBuffer.subarray(1);
      try {
        if (buf3.byteLength) {
          const asn = localFromBER(buf3, 0, buf3.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
};
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
var BitString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits2 = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits2.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits2.join("");
      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
    }
  }
};
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first4, second3) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first4);
  const secondView = new Uint8Array(second3);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max; i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length; p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1; i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first4, second3) {
  let b = 0;
  const firstView = new Uint8Array(first4);
  const secondView = new Uint8Array(second3);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== void 0) {
      this.valueDec = value;
    }
  }
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0; i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0; i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
};
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;
var Integer = class _Integer extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter();
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first4 = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first4[0] |= 128;
      const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first4)}`);
      const secondInt = firstInt + bigIntValue;
      const second3 = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));
      second3[0] |= 128;
      writer.write(second3);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _Integer({
      valueHex: writer.final()
    });
    return res;
  }
  convertToDER() {
    const integer = new _Integer({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _Integer({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
};
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
var Enumerated = class extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
};
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits2 = BigInt(value).toString(2);
    while (bits2.length % 7) {
      bits2 = "0" + bits2;
    }
    const bytes3 = new Uint8Array(bits2.length / 7);
    for (let i = 0; i < bytes3.length; i++) {
      bytes3[i] = parseInt(bits2.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes3.length ? 128 : 0);
    }
    this.fromBER(bytes3.buffer, 0, bytes3.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = pvtsutils.Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
};
LocalSidValueBlock.NAME = "sidBlock";
var LocalObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat3(retBuffers);
  }
  fromString(string27) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string27.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string27.substring(pos1);
      else
        sid = string27.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
};
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
var ObjectIdentifier = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = pvtsutils.Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
};
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat3(retBuffers);
  }
  fromString(string27) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string27.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string27.substring(pos1);
      else
        sid = string27.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock();
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
};
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
var RelativeObjectIdentifier = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
var Sequence = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
};
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
var Set2 = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
};
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";
var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalStringValueBlock.NAME = "StringValueBlock";
var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
};
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
var LocalSimpleStringBlock = class extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0; i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
};
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
};
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
var Utf8String = class extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
};
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));
  }
};
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
var BmpString = class extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
};
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0; i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0; i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1; j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
};
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
var UniversalString = class extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
};
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
var NumericString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
};
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
var PrintableString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
};
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
var TeletexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
};
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
var VideotexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
};
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
var IA5String = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
};
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
var GraphicString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
};
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
var VisibleString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
};
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
var GeneralString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
};
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
var CharacterString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
};
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
var UTCTime = class extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0; i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer3 = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer3);
    for (let i = 0; i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer3;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser2 = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser2.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2e3 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
};
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
var GeneralizedTime = class extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser2;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number4 = new Number(inputString[inputString.length - 1]);
      if (isNaN(number4.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number4 = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number4.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number4;
        if (differenceString.length === 4) {
          number4 = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number4.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number4;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser2 = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1e3 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser2.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1; j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
};
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
var DATE = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
};
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
var TimeOfDay = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
};
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
var DateTime = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
};
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
var Duration = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
};
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
var TIME = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
};
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
function pkcs1ToJwk(bytes3) {
  const { result } = fromBER(bytes3);
  const values = result.valueBlock.value;
  const key = {
    n: toString5(bnToBuf(values[1].toBigInt()), "base64url"),
    e: toString5(bnToBuf(values[2].toBigInt()), "base64url"),
    d: toString5(bnToBuf(values[3].toBigInt()), "base64url"),
    p: toString5(bnToBuf(values[4].toBigInt()), "base64url"),
    q: toString5(bnToBuf(values[5].toBigInt()), "base64url"),
    dp: toString5(bnToBuf(values[6].toBigInt()), "base64url"),
    dq: toString5(bnToBuf(values[7].toBigInt()), "base64url"),
    qi: toString5(bnToBuf(values[8].toBigInt()), "base64url"),
    kty: "RSA",
    alg: "RS256"
  };
  return key;
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const root = new Sequence({
    value: [
      new Integer({ value: 0 }),
      Integer.fromBigInt(bufToBn(fromString6(jwk.n, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.e, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.d, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.p, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.q, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.dp, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.dq, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString6(jwk.qi, "base64url")))
    ]
  });
  const der = root.toBER();
  return new Uint8Array(der, 0, der.byteLength);
}
function pkixToJwk(bytes3) {
  const { result } = fromBER(bytes3);
  const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;
  return {
    kty: "RSA",
    n: toString5(bnToBuf(values[0].toBigInt()), "base64url"),
    e: toString5(bnToBuf(values[1].toBigInt()), "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const root = new Sequence({
    value: [
      new Sequence({
        value: [
          // rsaEncryption
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // this appears to be a bug in asn1js.js - this should really be a Sequence
      // and not a BitString but it generates the same bytes as node-forge so 🤷‍♂️
      new BitString({
        valueHex: new Sequence({
          value: [
            Integer.fromBigInt(bufToBn(fromString6(jwk.n, "base64url"))),
            Integer.fromBigInt(bufToBn(fromString6(jwk.e, "base64url")))
          ]
        }).toBER()
      })
    ]
  });
  const der = root.toBER();
  return new Uint8Array(der, 0, der.byteLength);
}
function bnToBuf(bn) {
  let hex = bn.toString(16);
  if (hex.length % 2 > 0) {
    hex = `0${hex}`;
  }
  const len = hex.length / 2;
  const u8 = new Uint8Array(len);
  let i = 0;
  let j = 0;
  while (i < len) {
    u8[i] = parseInt(hex.slice(j, j + 2), 16);
    i += 1;
    j += 2;
  }
  return u8;
}
function bufToBn(u8) {
  const hex = [];
  u8.forEach(function(i) {
    let h2 = i.toString(16);
    if (h2.length % 2 > 0) {
      h2 = `0${h2}`;
    }
    hex.push(h2);
  });
  return BigInt("0x" + hex.join(""));
}
var SALT_LENGTH = 16;
var KEY_SIZE = 32;
var ITERATIONS = 1e4;
async function exportToPem(privateKey, password) {
  const crypto3 = webcrypto_browser_default.get();
  const keyWrapper = new Sequence({
    value: [
      // version (0)
      new Integer({ value: 0 }),
      // privateKeyAlgorithm
      new Sequence({
        value: [
          // rsaEncryption OID
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // PrivateKey
      new OctetString({
        valueHex: privateKey.marshal()
      })
    ]
  });
  const keyBuf = keyWrapper.toBER();
  const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
  const salt = randomBytes2(SALT_LENGTH);
  const encryptionKey = await pbkdf2Async(sha5124, password, salt, {
    c: ITERATIONS,
    dkLen: KEY_SIZE
  });
  const iv = randomBytes2(16);
  const cryptoKey = await crypto3.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt"]);
  const encrypted = await crypto3.subtle.encrypt({
    name: "AES-CBC",
    iv
  }, cryptoKey, keyArr);
  const pbkdf2Params = new Sequence({
    value: [
      // salt
      new OctetString({ valueHex: salt }),
      // iteration count
      new Integer({ value: ITERATIONS }),
      // key length
      new Integer({ value: KEY_SIZE }),
      // AlgorithmIdentifier
      new Sequence({
        value: [
          // hmacWithSHA512
          new ObjectIdentifier({ value: "1.2.840.113549.2.11" }),
          new Null()
        ]
      })
    ]
  });
  const encryptionAlgorithm = new Sequence({
    value: [
      // pkcs5PBES2
      new ObjectIdentifier({
        value: "1.2.840.113549.1.5.13"
      }),
      new Sequence({
        value: [
          // keyDerivationFunc
          new Sequence({
            value: [
              // pkcs5PBKDF2
              new ObjectIdentifier({
                value: "1.2.840.113549.1.5.12"
              }),
              // PBKDF2-params
              pbkdf2Params
            ]
          }),
          // encryptionScheme
          new Sequence({
            value: [
              // aes256-CBC
              new ObjectIdentifier({
                value: "2.16.840.1.101.3.4.1.42"
              }),
              // iv
              new OctetString({
                valueHex: iv
              })
            ]
          })
        ]
      })
    ]
  });
  const finalWrapper = new Sequence({
    value: [
      encryptionAlgorithm,
      new OctetString({ valueHex: encrypted })
    ]
  });
  const finalWrapperBuf = finalWrapper.toBER();
  const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
  return [
    "-----BEGIN ENCRYPTED PRIVATE KEY-----",
    ...toString5(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
    "-----END ENCRYPTED PRIVATE KEY-----"
  ].join("\n");
}
async function importFromPem(pem, password) {
  const crypto3 = webcrypto_browser_default.get();
  let plaintext;
  if (pem.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
    const key = fromString6(pem.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key);
    const { iv, salt, iterations, keySize: keySize2, cipherText } = findEncryptedPEMData(result);
    const encryptionKey = await pbkdf2Async(sha5124, password, salt, {
      c: iterations,
      dkLen: keySize2
    });
    const cryptoKey = await crypto3.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["decrypt"]);
    const decrypted = toUint8Array(await crypto3.subtle.decrypt({
      name: "AES-CBC",
      iv
    }, cryptoKey, cipherText));
    const { result: decryptedResult } = fromBER(decrypted);
    plaintext = findPEMData(decryptedResult);
  } else if (pem.includes("-----BEGIN PRIVATE KEY-----")) {
    const key = fromString6(pem.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key);
    plaintext = findPEMData(result);
  } else {
    throw new CodeError("Could not parse private key from PEM data", "ERR_INVALID_PARAMETERS");
  }
  return unmarshalRsaPrivateKey(plaintext);
}
function findEncryptedPEMData(root) {
  const encryptionAlgorithm = root.valueBlock.value[0];
  const scheme = encryptionAlgorithm.valueBlock.value[0].toString();
  if (scheme !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") {
    throw new CodeError("Only pkcs5PBES2 encrypted private keys are supported", "ERR_INVALID_PARAMS");
  }
  const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];
  const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();
  if (keyDerivationFuncName !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") {
    throw new CodeError("Only pkcs5PBKDF2 key derivation functions are supported", "ERR_INVALID_PARAMS");
  }
  const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];
  const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());
  let iterations = ITERATIONS;
  let keySize2 = KEY_SIZE;
  if (pbkdf2Params.valueBlock.value.length === 3) {
    iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());
    keySize2 = Number(pbkdf2Params.valueBlock.value[2].toBigInt());
  } else if (pbkdf2Params.valueBlock.value.length === 2) {
    throw new CodeError("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key", "ERR_INVALID_PARAMS");
  }
  const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];
  const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();
  if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.2.840.113549.3.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.3.14.3.2.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") {
  } else {
    throw new CodeError("Only AES-CBC encryption schemes are supported", "ERR_INVALID_PARAMS");
  }
  const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());
  return {
    cipherText: toUint8Array(root.valueBlock.value[1].getValue()),
    salt,
    iterations,
    keySize: keySize2,
    iv
  };
}
function findPEMData(seq) {
  return toUint8Array(seq.valueBlock.value[2].getValue());
}
function toUint8Array(buf3) {
  return new Uint8Array(buf3, 0, buf3.byteLength);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js
async function generateKey2(bits2) {
  const pair2 = await webcrypto_browser_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits2,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey2(key) {
  const privateKey = await webcrypto_browser_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign2(key, msg) {
  const privateKey = await webcrypto_browser_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_browser_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify2(key, sig, msg) {
  const publicKey = await webcrypto_browser_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_browser_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
}
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return Promise.all([
    webcrypto_browser_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_browser_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return webcrypto_browser_default.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function keySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new CodeError("invalid key type", "ERR_INVALID_KEY_TYPE");
  } else if (jwk.n == null) {
    throw new CodeError("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
  }
  const bytes3 = fromString6(jwk.n, "base64url");
  return bytes3.length * 8;
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var MAX_RSA_KEY_SIZE = 8192;
var RsaPublicKey = class {
  _key;
  constructor(key) {
    this._key = key;
  }
  verify(data, sig) {
    return hashAndVerify2(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  hash() {
    const p = sha2563.digest(this.bytes);
    if (isPromise(p)) {
      return p.then(({ bytes: bytes3 }) => bytes3);
    }
    return p.bytes;
  }
};
var RsaPrivateKey = class {
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes2(16);
  }
  sign(message2) {
    return hashAndSign2(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  hash() {
    const p = sha2563.digest(this.bytes);
    if (isPromise(p)) {
      return p.then(({ bytes: bytes3 }) => bytes3);
    }
    return p.bytes;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString5(hash2, "base58btc");
  }
  /**
   * Exports the key as libp2p-key - a aes-gcm encrypted value with the key
   * derived from the password.
   *
   * To export it as a password protected PEM file, please use the `exportPEM`
   * function from `@libp2p/rsa`.
   */
  async export(password, format28 = "pkcs-8") {
    if (format28 === "pkcs-8") {
      return rsa_utils_exports.exportToPem(this, password);
    } else if (format28 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format28}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey(bytes3) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes3);
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes3) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes3);
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey2(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair2(bits2) {
  if (bits2 > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await generateKey2(bits2);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2564 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s: s2 };
  },
  hexFromSig(sig) {
    const slice3 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s2 = slice3(h2(sig.s));
    const r = slice3(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r}02${sl}${s2}`;
  }
};
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
var _3n3 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n7, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, N);
    aInRange("private key", num, _1n7, N);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y2, pz: z } = p;
    if (Fp3.eql(z, Fp3.ONE))
      return { x, y: y2 };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z);
    const ax = Fp3.mul(x, iz);
    const ay = Fp3.mul(y2, iz);
    const zz = Fp3.mul(z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp3.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y: y2 } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp3.sqr(y2);
    const right = weierstrassEquation(x);
    if (!Fp3.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y: y2 } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
      if (is0(x) && is0(y2))
        return Point2.ZERO;
      return new Point2(x, y2, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp3.mul(b, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n3);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange("scalar", sc, _0n7, CURVE.n);
      const I = Point2.ZERO;
      if (sc === _0n7)
        return I;
      if (sc === _1n7)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, sc);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n7 || k2 > _0n7) {
        if (k1 & _1n7)
          k1p = k1p.add(d2);
        if (k2 & _1n7)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n7;
        k2 >>= _1n7;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n7, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n7 || a2 === _1n7 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n7)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n7)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes4(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts3(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts3(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n7, Fp3.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3;
        try {
          y3 = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n7) === _1n7;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number4) {
    const HALF = CURVE_ORDER >> _1n7;
    return number4 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b, from58, to) => bytesToNumberBE(b.slice(from58, to));
  class Signature {
    constructor(r, s2, recovery) {
      this.r = r;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s: s2 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s2);
    }
    assertValidity() {
      aInRange("r", this.r, _1n7, CURVE_ORDER);
      aInRange("s", this.s, _1n7, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length30 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length30), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n7, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes3(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n7)
        return;
      const s2 = modN(ik * modN(m2 + r * d2));
      if (s2 === _0n7)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n7);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes2(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s3 } = sg;
        _sig = new Signature(r2, s3);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is3 = invN(s2);
    const u1 = modN(h2 * is3);
    const u2 = modN(r * is3);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create30 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create30(defHash), create: create30 });
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n8 = BigInt(1);
var _2n6 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n6) / b;
function sqrtMod(y2) {
  const P = secp256k1P;
  const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P;
  const b3 = b2 * b2 * y2 % P;
  const b6 = pow2(b3, _3n4, P) * b3 % P;
  const b9 = pow2(b6, _3n4, P) * b3 % P;
  const b11 = pow2(b9, _2n6, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n4, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n6, P);
  if (!Fp2.eql(Fp2.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2564);
var _0n8 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js
function generateKey3() {
  return secp256k1.utils.randomPrivateKey();
}
function hashAndSign3(key, msg) {
  const p = sha2563.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest: digest27 }) => secp256k1.sign(digest27, key).toDERRawBytes()).catch((err) => {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    });
  }
  try {
    return secp256k1.sign(p.digest, key).toDERRawBytes();
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
function hashAndVerify3(key, sig, msg) {
  const p = sha2563.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p)) {
    return p.then(({ digest: digest27 }) => secp256k1.verify(sig, digest27, key)).catch((err) => {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    });
  }
  try {
    return secp256k1.verify(sig, p.digest, key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var Secp256k1PublicKey = class {
  _key;
  constructor(key) {
    validatePublicKey(key);
    this._key = key;
  }
  verify(data, sig) {
    return hashAndVerify3(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  async hash() {
    const p = sha2563.digest(this.bytes);
    let bytes3;
    if (isPromise(p)) {
      ({ bytes: bytes3 } = await p);
    } else {
      bytes3 = p.bytes;
    }
    return bytes3;
  }
};
var Secp256k1PrivateKey = class {
  _key;
  _publicKey;
  constructor(key, publicKey) {
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  sign(message2) {
    return hashAndSign3(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals9(this.bytes, key.bytes);
  }
  hash() {
    const p = sha2563.digest(this.bytes);
    if (isPromise(p)) {
      return p.then(({ bytes: bytes3 }) => bytes3);
    }
    return p.bytes;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString5(hash2, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format28 = "libp2p-key") {
    if (format28 === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format28}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey(bytes3) {
  return new Secp256k1PrivateKey(bytes3);
}
function unmarshalSecp256k1PublicKey(bytes3) {
  return new Secp256k1PublicKey(bytes3);
}
async function generateKeyPair3() {
  const privateKeyBytes = generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var supportedKeys = {
  rsa: rsa_class_exports,
  ed25519: ed25519_class_exports,
  secp256k1: secp256k1_class_exports
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair4(type, bits2) {
  return typeToKey(type).generateKeyPair(bits2 ?? 2048);
}
async function generateKeyPairFromSeed2(type, seed, bits2) {
  if (type.toLowerCase() !== "ed25519") {
    throw new CodeError("Seed key derivation is unimplemented for RSA or secp256k1", "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  }
  return generateKeyPairFromSeed(seed);
}
function unmarshalPublicKey2(buf3) {
  const decoded = PublicKey.decode(buf3);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "unknown");
  }
}
function marshalPublicKey2(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey3(buf3) {
  const decoded = PrivateKey.decode(buf3);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key = await importer(encryptedKey, password);
    return await unmarshalPrivateKey3(key);
  } catch (_) {
  }
  if (!encryptedKey.includes("BEGIN")) {
    throw new CodeError("Encrypted key was not a libp2p-key or a PEM file", "ERR_INVALID_IMPORT_FORMAT");
  }
  return importFromPem(encryptedKey, password);
}

// node_modules/@noble/hashes/esm/sha1.js
var SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha1 = /* @__PURE__ */ wrapConstructor(() => new SHA1());

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var hashName = {
  sha1,
  "sha2-256": sha2564,
  "sha2-512": sha5124
};
function pbkdf22(password, salt, iterations, keySize2, hash2) {
  if (hash2 !== "sha1" && hash2 !== "sha2-256" && hash2 !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw new CodeError(`Hash '${hash2}' is unknown or not supported. Must be ${types}`, "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash2];
  const dek = pbkdf2(hasher, password, salt, {
    c: iterations,
    dkLen: keySize2
  });
  return base643.encode(dek).substring(1);
}

// node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);

// node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/alloc.js
function alloc4(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe8(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports4 = {};
__export(base10_exports4, {
  base10: () => base104
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bytes.js
var empty4 = new Uint8Array(0);
function equals10(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce4(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString7(str) {
  return new TextEncoder().encode(str);
}
function toString6(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/vendor/base-x.js
function base5(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src4 = base5;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base.js
var Encoder4 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or4(left, right) {
  return new ComposedDecoder4({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec4 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name29, prefix, baseEncode);
    this.decoder = new Decoder4(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from7({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec4(name29, prefix, encode116, decode144);
}
function baseX4({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default4(alphabet27, name29);
  return from7({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce4(decode144(text))
  });
}
function decode18(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode15(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46484({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from7({
    prefix,
    name: name29,
    encode(input) {
      return encode15(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode18(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base10.js
var base104 = baseX4({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports4 = {};
__export(base16_exports4, {
  base16: () => base164,
  base16upper: () => base16upper4
});
var base164 = rfc46484({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper4 = rfc46484({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports4 = {};
__export(base2_exports4, {
  base2: () => base24
});
var base24 = rfc46484({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports4 = {};
__export(base256emoji_exports4, {
  base256emoji: () => base256emoji4
});
var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars4 = alphabet4.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes4 = alphabet4.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode16(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars4[c];
    return p;
  }, "");
}
function decode19(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes4[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji4 = from7({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode16,
  decode: decode19
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports4 = {};
__export(base32_exports4, {
  base32: () => base324,
  base32hex: () => base32hex4,
  base32hexpad: () => base32hexpad4,
  base32hexpadupper: () => base32hexpadupper4,
  base32hexupper: () => base32hexupper4,
  base32pad: () => base32pad4,
  base32padupper: () => base32padupper4,
  base32upper: () => base32upper4,
  base32z: () => base32z4
});
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports4 = {};
__export(base36_exports4, {
  base36: () => base364,
  base36upper: () => base36upper4
});
var base364 = baseX4({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper4 = baseX4({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports4 = {};
__export(base58_exports4, {
  base58btc: () => base58btc4,
  base58flickr: () => base58flickr4
});
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports4 = {};
__export(base64_exports4, {
  base64: () => base644,
  base64pad: () => base64pad4,
  base64url: () => base64url4,
  base64urlpad: () => base64urlpad4
});
var base644 = rfc46484({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad4 = rfc46484({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url4 = rfc46484({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad4 = rfc46484({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports4 = {};
__export(base8_exports4, {
  base8: () => base84
});
var base84 = rfc46484({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports7 = {};
__export(identity_exports7, {
  identity: () => identity7
});
var identity7 = from7({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString6(buf3),
  decode: (str) => fromString7(str)
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder4 = new TextDecoder();

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports8 = {};
__export(identity_exports8, {
  identity: () => identity8
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/vendor/varint.js
var encode_14 = encode17;
var MSB5 = 128;
var REST5 = 127;
var MSBALL4 = ~REST5;
var INT4 = Math.pow(2, 31);
function encode17(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode17.bytes = offset - oldOffset + 1;
  return out;
}
var decode20 = read5;
var MSB$14 = 128;
var REST$14 = 127;
function read5(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read5.bytes = counter - offset;
  return res;
}
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length5 = function(value) {
  return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
};
var varint4 = {
  encode: encode_14,
  decode: decode20,
  encodingLength: length5
};
var _brrp_varint4 = varint4;
var varint_default4 = _brrp_varint4;

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/varint.js
function decode21(data, offset = 0) {
  const code33 = varint_default4.decode(data, offset);
  return [code33, varint_default4.decode.bytes];
}
function encodeTo4(int, target, offset = 0) {
  varint_default4.encode(int, target, offset);
  return target;
}
function encodingLength5(int) {
  return varint_default4.encodingLength(int);
}

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/digest.js
function create6(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength5(code33);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo4(code33, bytes3, 0);
  encodeTo4(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest4(code33, size, digest27, bytes3);
}
function decode22(multihash) {
  const bytes3 = coerce4(multihash);
  const [code33, sizeOffset] = decode21(bytes3);
  const [size, digestOffset] = decode21(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code33, size, digest27, bytes3);
}
function equals11(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals10(a.bytes, data.bytes);
  }
}
var Digest4 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/identity.js
var code4 = 0;
var name4 = "identity";
var encode18 = coerce4;
function digest4(input) {
  return create6(code4, encode18(input));
}
var identity8 = { code: code4, name: name4, encode: encode18, digest: digest4 };

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports4 = {};
__export(sha2_browser_exports4, {
  sha256: () => sha2565,
  sha512: () => sha5125
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/hasher.js
function from8({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher4(name29, code33, encode116);
}
var Hasher4 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest27) => create6(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha4(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2565 = from8({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5125 = from8({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/cid.js
function format4(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV04(bytes3, baseCache4(link), base45 ?? base58btc4.encoder);
    default:
      return toStringV14(bytes3, baseCache4(link), base45 ?? base324.encoder);
  }
}
var cache4 = /* @__PURE__ */ new WeakMap();
function baseCache4(cid) {
  const baseCache28 = cache4.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID4 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create6(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals11(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format4(this, base45);
  }
  toJSON() {
    return { "/": format4(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID4(version3, code33, multihash.bytes));
    } else if (value[cidSymbol4] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode22(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE4) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID4(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE4, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode21(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE4;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes4(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes4(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc4;
      return [
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base45 ?? base58btc4;
      return [base58btc4.prefix, decoder.decode(source)];
    }
    case base324.prefix: {
      const decoder = base45 ?? base324;
      return [base324.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV04(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV14(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
function encodeCID4(version3, code33, multihash) {
  const codeOffset = encodingLength5(version3);
  const hashOffset = codeOffset + encodingLength5(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version3, bytes3, 0);
  encodeTo4(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/utils/node_modules/multiformats/dist/src/basics.js
var bases4 = { ...identity_exports7, ...base2_exports4, ...base8_exports4, ...base10_exports4, ...base16_exports4, ...base32_exports4, ...base36_exports4, ...base58_exports4, ...base64_exports4, ...base256emoji_exports4 };
var hashes4 = { ...sha2_browser_exports4, ...identity_exports8 };

// node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec5(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string4 = createCodec5("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii4 = createCodec5("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe8(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES4 = {
  utf8: string4,
  "utf-8": string4,
  hex: bases4.base16,
  latin1: ascii4,
  ascii: ascii4,
  binary: ascii4,
  ...bases4
};
var bases_default4 = BASES4;

// node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/from-string.js
function fromString8(string27, encoding = "utf8") {
  const base45 = bases_default4[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var LN2_SQUARED = Math.LN2 * Math.LN2;
var BloomFilter = class {
  seeds;
  bits;
  buffer;
  constructor(options2 = {}) {
    if (options2.seeds != null) {
      this.seeds = options2.seeds;
    } else {
      this.seeds = generateSeeds(options2.hashes ?? 8);
    }
    this.bits = options2.bits ?? 1024;
    this.buffer = alloc4(Math.ceil(this.bits / 8));
  }
  /**
   * Add an item to the filter
   */
  add(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = import_murmurhash3js_revisited.default.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      this.setbit(bit);
    }
  }
  /**
   * Test if the filter has an item. If it returns false it definitely does not
   * have the item. If it returns true, it probably has the item but there's
   * an `errorRate` chance it doesn't.
   */
  has(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = import_murmurhash3js_revisited.default.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      const isSet = this.getbit(bit);
      if (!isSet) {
        return false;
      }
    }
    return true;
  }
  /**
   * Reset the filter
   */
  clear() {
    this.buffer.fill(0);
  }
  setbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    let bitfield = this.buffer[pos];
    bitfield |= 1 << shift;
    this.buffer[pos] = bitfield;
  }
  getbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    const bitfield = this.buffer[pos];
    return (bitfield & 1 << shift) !== 0;
  }
};
function createBloomFilter(itemcount, errorRate = 5e-3) {
  const opts = optimize(itemcount, errorRate);
  return new BloomFilter(opts);
}
function optimize(itemCount, errorRate = 5e-3) {
  const bits2 = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
  const hashes27 = Math.round(bits2 / itemCount * Math.LN2);
  return { bits: bits2, hashes: hashes27 };
}
function generateSeeds(count) {
  let buf3;
  let j;
  const seeds = [];
  for (let i = 0; i < count; i++) {
    buf3 = new Uint8ArrayList(randomBytes2(4));
    seeds[i] = buf3.getUint32(0, true);
    for (j = 0; j < i; j++) {
      if (seeds[i] === seeds[j]) {
        i--;
        break;
      }
    }
  }
  return seeds;
}

// node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/equals.js
function equals12(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
var MAX_FINGERPRINT_SIZE = 64;
var Fingerprint = class {
  fp;
  h;
  seed;
  constructor(buf3, hash2, seed, fingerprintSize = 2) {
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash2.hashV(buf3, seed);
    const fp = alloc4(fingerprintSize);
    for (let i = 0; i < fp.length; i++) {
      fp[i] = fnv[i];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash2;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!(other?.fp instanceof Uint8Array)) {
      return false;
    }
    return equals12(this.fp, other.fp);
  }
};

// node_modules/@libp2p/utils/dist/src/filters/utils.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

// node_modules/@libp2p/utils/dist/src/filters/bucket.js
var Bucket = class {
  contents;
  constructor(size) {
    this.contents = new Array(size).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i = 0; i < this.contents.length; i++) {
      if (this.contents[i] == null) {
        this.contents[i] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i];
    this.contents[i] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
};

// node_modules/@sindresorhus/fnv1a/index.js
var FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
var FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
var cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
  const fnvPrime = FNV_PRIMES[size];
  let hash2 = FNV_OFFSETS[size];
  for (let index = 0; index < uint8Array.length; index++) {
    hash2 ^= BigInt(uint8Array[index]);
    hash2 = BigInt.asUintN(size, hash2 * fnvPrime);
  }
  return hash2;
}
function fnv1aEncodeInto(string27, size, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size];
  let hash2 = FNV_OFFSETS[size];
  let remaining = string27;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash2 ^= BigInt(utf8Buffer[index]);
      hash2 = BigInt.asUintN(size, hash2 * fnvPrime);
    }
  }
  return hash2;
}
function fnv1a(value, { size = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value, size, utf8Buffer);
    }
    value = cachedEncoder.encode(value);
  }
  return fnv1aUint8Array(value, size);
}

// node_modules/@libp2p/utils/dist/src/filters/hashes.js
var import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited(), 1);
var fnv1a2 = {
  hash: (input) => {
    return Number(fnv1a(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a2.hash(input, seed));
  }
};
function numberToBuffer(num) {
  let hex = num.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString8(hex, "base16");
}

// node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
var maxCuckooCount = 500;
var CuckooFilter = class {
  bucketSize;
  filterSize;
  fingerprintSize;
  buckets;
  count;
  hash;
  seed;
  constructor(init) {
    this.filterSize = init.filterSize;
    this.bucketSize = init.bucketSize ?? 4;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand = [j, k];
    let i = rand[getRandomInt(0, rand.length - 1)];
    if (this.buckets[i] == null) {
      this.buckets[i] = new Bucket(this.bucketSize);
    }
    for (let n = 0; n < maxCuckooCount; n++) {
      const swapped = this.buckets[i].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i = (i ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i] == null) {
        this.buckets[i] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.has(fingerprint) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return this.buckets[k]?.has(fingerprint) ?? false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.remove(fingerprint) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = this.buckets[k]?.remove(fingerprint) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
};
var MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize2(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load2 = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load2);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}

// node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
var ScalableCuckooFilter = class {
  filterSize;
  bucketSize;
  fingerprintSize;
  scale;
  filterSeries;
  hash;
  seed;
  constructor(init) {
    this.bucketSize = init.bucketSize ?? 4;
    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.scale = init.scale ?? 2;
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString8(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
};
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options2) {
  return new ScalableCuckooFilter({
    ...optimize2(maxItems, errorRate),
    ...options2 ?? {}
  });
}

// node_modules/@libp2p/peer-collections/dist/src/filter.js
var PeerFilter = class {
  filter;
  constructor(size, errorRate) {
    this.filter = createScalableCuckooFilter(size, errorRate);
  }
  has(peerId2) {
    return this.filter.has(peerId2.toBytes());
  }
  add(peerId2) {
    this.filter.add(peerId2.toBytes());
  }
  remove(peerId2) {
    this.filter.remove?.(peerId2.toBytes());
  }
};
function peerFilter(size, errorRate = 1e-3) {
  return new PeerFilter(size, errorRate);
}

// node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  metric;
  constructor(init) {
    super();
    const { name: name29, metrics } = init;
    this.metric = metrics.registerMetric(name29);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name: name29, metrics } = config;
  let map6;
  if (metrics != null) {
    map6 = new TrackedPeerMap({ name: name29, metrics });
  } else {
    map6 = new PeerMap();
  }
  return map6;
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports5 = {};
__export(base32_exports5, {
  base32: () => base325,
  base32hex: () => base32hex5,
  base32hexpad: () => base32hexpad5,
  base32hexpadupper: () => base32hexpadupper5,
  base32hexupper: () => base32hexupper5,
  base32pad: () => base32pad5,
  base32padupper: () => base32padupper5,
  base32upper: () => base32upper5,
  base32z: () => base32z5
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bytes.js
var empty5 = new Uint8Array(0);
function equals13(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce5(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString9(str) {
  return new TextEncoder().encode(str);
}
function toString7(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/vendor/base-x.js
function base6(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src5 = base6;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default5 = _brrp__multiformats_scope_baseX5;

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base.js
var Encoder5 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or5(this, decoder);
  }
};
var ComposedDecoder5 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or5(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or5(left, right) {
  return new ComposedDecoder5({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec5 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name29, prefix, baseEncode);
    this.decoder = new Decoder5(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from9({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec5(name29, prefix, encode116, decode144);
}
function baseX5({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default5(alphabet27, name29);
  return from9({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce5(decode144(text))
  });
}
function decode23(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode19(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46485({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from9({
    prefix,
    name: name29,
    encode(input) {
      return encode19(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode23(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base32.js
var base325 = rfc46485({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46485({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46485({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46485({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46485({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46485({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46485({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46485({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46485({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports5 = {};
__export(base58_exports5, {
  base58btc: () => base58btc5,
  base58flickr: () => base58flickr5
});
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/vendor/varint.js
var encode_15 = encode20;
var MSB6 = 128;
var REST6 = 127;
var MSBALL5 = ~REST6;
var INT5 = Math.pow(2, 31);
function encode20(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode20.bytes = offset - oldOffset + 1;
  return out;
}
var decode24 = read6;
var MSB$15 = 128;
var REST$15 = 127;
function read6(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read6.bytes = counter - offset;
  return res;
}
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length6 = function(value) {
  return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
};
var varint5 = {
  encode: encode_15,
  decode: decode24,
  encodingLength: length6
};
var _brrp_varint5 = varint5;
var varint_default5 = _brrp_varint5;

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/varint.js
function decode25(data, offset = 0) {
  const code33 = varint_default5.decode(data, offset);
  return [code33, varint_default5.decode.bytes];
}
function encodeTo5(int, target, offset = 0) {
  varint_default5.encode(int, target, offset);
  return target;
}
function encodingLength6(int) {
  return varint_default5.encodingLength(int);
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/digest.js
function create7(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength6(code33);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo5(code33, bytes3, 0);
  encodeTo5(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest5(code33, size, digest27, bytes3);
}
function decode26(multihash) {
  const bytes3 = coerce5(multihash);
  const [code33, sizeOffset] = decode25(bytes3);
  const [size, digestOffset] = decode25(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code33, size, digest27, bytes3);
}
function equals14(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals13(a.bytes, data.bytes);
  }
}
var Digest5 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/cid.js
function format5(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV05(bytes3, baseCache5(link), base45 ?? base58btc5.encoder);
    default:
      return toStringV15(bytes3, baseCache5(link), base45 ?? base325.encoder);
  }
}
var cache5 = /* @__PURE__ */ new WeakMap();
function baseCache5(cid) {
  const baseCache28 = cache5.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache5.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID5 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create7(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals14(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format5(this, base45);
  }
  toJSON() {
    return { "/": format5(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID5(version3, code33, multihash.bytes));
    } else if (value[cidSymbol5] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode26(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE5) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID5(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE5, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce5(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode25(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE5;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes5(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes5(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc5;
      return [
        base58btc5.prefix,
        decoder.decode(`${base58btc5.prefix}${source}`)
      ];
    }
    case base58btc5.prefix: {
      const decoder = base45 ?? base58btc5;
      return [base58btc5.prefix, decoder.decode(source)];
    }
    case base325.prefix: {
      const decoder = base45 ?? base325;
      return [base325.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV05(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc5.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV15(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
function encodeCID5(version3, code33, multihash) {
  const codeOffset = encodingLength6(version3);
  const hashOffset = codeOffset + encodingLength6(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version3, bytes3, 0);
  encodeTo5(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports5 = {};
__export(base10_exports5, {
  base10: () => base105
});
var base105 = baseX5({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports5 = {};
__export(base16_exports5, {
  base16: () => base165,
  base16upper: () => base16upper5
});
var base165 = rfc46485({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper5 = rfc46485({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports5 = {};
__export(base2_exports5, {
  base2: () => base25
});
var base25 = rfc46485({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports5 = {};
__export(base256emoji_exports5, {
  base256emoji: () => base256emoji5
});
var alphabet5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars5 = alphabet5.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes5 = alphabet5.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode21(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars5[c];
    return p;
  }, "");
}
function decode27(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes5[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji5 = from9({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode21,
  decode: decode27
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports5 = {};
__export(base36_exports5, {
  base36: () => base365,
  base36upper: () => base36upper5
});
var base365 = baseX5({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper5 = baseX5({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports5 = {};
__export(base64_exports5, {
  base64: () => base645,
  base64pad: () => base64pad5,
  base64url: () => base64url5,
  base64urlpad: () => base64urlpad5
});
var base645 = rfc46485({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad5 = rfc46485({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url5 = rfc46485({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad5 = rfc46485({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports5 = {};
__export(base8_exports5, {
  base8: () => base85
});
var base85 = rfc46485({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports9 = {};
__export(identity_exports9, {
  identity: () => identity9
});
var identity9 = from9({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString7(buf3),
  decode: (str) => fromString9(str)
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder5 = new TextEncoder();
var textDecoder5 = new TextDecoder();

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports10 = {};
__export(identity_exports10, {
  identity: () => identity10
});
var code5 = 0;
var name5 = "identity";
var encode22 = coerce5;
function digest5(input) {
  return create7(code5, encode22(input));
}
var identity10 = { code: code5, name: name5, encode: encode22, digest: digest5 };

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports5 = {};
__export(sha2_browser_exports5, {
  sha256: () => sha2566,
  sha512: () => sha5126
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/hasher.js
function from10({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher5(name29, code33, encode116);
}
var Hasher5 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest27) => create7(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha5(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2566 = from10({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5126 = from10({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/basics.js
var bases5 = { ...identity_exports9, ...base2_exports5, ...base8_exports5, ...base10_exports5, ...base16_exports5, ...base32_exports5, ...base36_exports5, ...base58_exports5, ...base64_exports5, ...base256emoji_exports5 };
var hashes5 = { ...sha2_browser_exports5, ...identity_exports10 };

// node_modules/@helia/bitswap/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec6(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string5 = createCodec6("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii5 = createCodec6("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe5(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES5 = {
  utf8: string5,
  "utf-8": string5,
  hex: bases5.base16,
  latin1: ascii5,
  ascii: ascii5,
  binary: ascii5,
  ...bases5
};
var bases_default5 = BASES5;

// node_modules/@helia/bitswap/node_modules/uint8arrays/dist/src/to-string.js
function toString8(array, encoding = "utf8") {
  const base45 = bases_default5[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@helia/bitswap/dist/src/utils/bitswap-message.js
var QueuedBitswapMessage = class {
  full;
  pendingBytes;
  wantlist;
  blocks;
  blockPresences;
  constructor(full = false, pendingBytes = 0) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  addWantlistEntry(cid, entry) {
    const key = base645.encode(cid.multihash.bytes);
    this.wantlist.set(key, entry);
  }
  addBlockPresence(cid, blockPresence) {
    const key = base645.encode(cid.multihash.bytes);
    this.blockPresences.set(key, blockPresence);
  }
  addBlock(cid, block) {
    const key = base645.encode(cid.multihash.bytes);
    this.blocks.set(key, block);
  }
};

// node_modules/@helia/bitswap/dist/src/utils/varint-encoder.js
function varintEncoder(buf3) {
  let out = new Uint8Array(buf3.reduce((acc, curr) => {
    return acc + encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf3) {
    out = encode(num, out, offset);
    offset += encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// node_modules/@helia/bitswap/dist/src/utils/cid-prefix.js
function cidToPrefix(cid) {
  return varint_encoder_default([
    cid.version,
    cid.code,
    cid.multihash.code,
    cid.multihash.digest.byteLength
  ]);
}

// node_modules/@helia/bitswap/dist/src/peer-want-lists/ledger.js
var Ledger = class {
  peerId;
  blockstore;
  network;
  wants;
  exchangeCount;
  bytesSent;
  bytesReceived;
  lastExchange;
  maxSizeReplaceHasWithBlock;
  log;
  constructor(components, init) {
    this.peerId = components.peerId;
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.wants = /* @__PURE__ */ new Map();
    this.log = components.logger.forComponent(`helia:bitswap:ledger:${components.peerId}`);
    this.exchangeCount = 0;
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock ?? DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK;
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesReceived += n;
  }
  debtRatio() {
    return this.bytesSent / (this.bytesReceived + 1);
  }
  async sendBlocksToPeer(options2) {
    const message2 = new QueuedBitswapMessage();
    const sentBlocks = /* @__PURE__ */ new Set();
    for (const [key, entry] of this.wants.entries()) {
      try {
        const block = await this.blockstore.get(entry.cid, options2);
        if (entry.wantType === WantType.WantHave) {
          if (block.byteLength < this.maxSizeReplaceHasWithBlock) {
            this.log("sending have and block for %c", entry.cid);
            sentBlocks.add(key);
            message2.addBlock(entry.cid, {
              data: block,
              prefix: cidToPrefix(entry.cid)
            });
          } else {
            this.log("sending have for %c", entry.cid);
            message2.addBlockPresence(entry.cid, {
              cid: entry.cid.bytes,
              type: BlockPresenceType.HaveBlock
            });
          }
        } else {
          this.log("sending block for %c", entry.cid);
          sentBlocks.add(key);
          message2.addBlock(entry.cid, {
            data: block,
            prefix: cidToPrefix(entry.cid)
          });
        }
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
        this.log("do not have block for %c", entry.cid);
        if (!entry.sendDontHave) {
          continue;
        }
        if (entry.sentDontHave === true) {
          continue;
        }
        entry.sentDontHave = true;
        message2.addBlockPresence(entry.cid, {
          cid: entry.cid.bytes,
          type: BlockPresenceType.DontHaveBlock
        });
      }
    }
    if (message2.blocks.size > 0 || message2.blockPresences.size > 0) {
      this.log("sending message");
      await this.network.sendMessage(this.peerId, message2, options2);
      this.log("sent message");
      this.sentBytes([...message2.blocks.values()].reduce((acc, curr) => acc + curr.data.byteLength, 0));
      for (const key of sentBlocks) {
        this.wants.delete(key);
      }
    }
  }
};

// node_modules/@helia/bitswap/dist/src/peer-want-lists/index.js
var PeerWantLists = class {
  blockstore;
  network;
  ledgerMap;
  maxSizeReplaceHasWithBlock;
  log;
  logger;
  constructor(components, init = {}) {
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock;
    this.log = components.logger.forComponent("helia:bitswap:peer-want-lists");
    this.logger = components.logger;
    this.ledgerMap = trackedPeerMap({
      name: "helia_bitswap_ledger_map",
      metrics: components.metrics
    });
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  ledgerForPeer(peerId2) {
    const ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      return void 0;
    }
    return {
      peer: ledger.peerId,
      value: ledger.debtRatio(),
      sent: ledger.bytesSent,
      received: ledger.bytesReceived,
      exchanged: ledger.exchangeCount
    };
  }
  wantListForPeer(peerId2) {
    const ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      return void 0;
    }
    return [...ledger.wants.values()];
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.peerId);
  }
  /**
   * Handle incoming messages
   */
  async receiveMessage(peerId2, message2) {
    let ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      ledger = new Ledger({
        peerId: peerId2,
        blockstore: this.blockstore,
        network: this.network,
        logger: this.logger
      }, {
        maxSizeReplaceHasWithBlock: this.maxSizeReplaceHasWithBlock
      });
      this.ledgerMap.set(peerId2, ledger);
    }
    ledger.receivedBytes(message2.blocks?.reduce((acc, curr) => acc + curr.data.byteLength, 0) ?? 0);
    if (message2.wantlist != null) {
      if (message2.wantlist.full === true) {
        ledger.wants.clear();
      }
      for (const entry of message2.wantlist.entries) {
        const cid = CID5.decode(entry.cid);
        const cidStr = toString8(cid.multihash.bytes, "base64");
        if (entry.cancel === true) {
          this.log("peer %p cancelled want of block for %c", peerId2, cid);
          ledger.wants.delete(cidStr);
        } else {
          if (entry.wantType === WantType.WantHave) {
            this.log("peer %p wanted block presence for %c", peerId2, cid);
          } else {
            this.log("peer %p wanted block for %c", peerId2, cid);
          }
          ledger.wants.set(cidStr, {
            cid,
            priority: entry.priority,
            wantType: entry.wantType ?? WantType.WantBlock,
            sendDontHave: entry.sendDontHave ?? false
          });
        }
      }
    }
    this.log("send blocks to peer");
    await ledger.sendBlocksToPeer();
  }
  async receivedBlock(cid, options2) {
    const cidStr = toString8(cid.multihash.bytes, "base64");
    const ledgers = [];
    for (const ledger of this.ledgerMap.values()) {
      if (ledger.wants.has(cidStr)) {
        ledgers.push(ledger);
      }
    }
    await Promise.all(ledgers.map(async (ledger) => ledger.sendBlocksToPeer(options2)));
  }
  peerDisconnected(peerId2) {
    this.ledgerMap.delete(peerId2);
  }
};

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bytes.js
var empty6 = new Uint8Array(0);
function coerce6(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/vendor/base-x.js
function base7(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src6 = base7;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default6 = _brrp__multiformats_scope_baseX6;

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base.js
var Encoder6 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder6 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or6(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or6(left, right) {
  return new ComposedDecoder6({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec6 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name29, prefix, baseEncode);
    this.decoder = new Decoder6(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from11({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec6(name29, prefix, encode116, decode144);
}
function baseX6({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default6(alphabet27, name29);
  return from11({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce6(decode144(text))
  });
}
function decode28(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode23(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46486({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from11({
    prefix,
    name: name29,
    encode(input) {
      return encode23(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode28(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base32.js
var base326 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base58.js
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base64.js
var base646 = rfc46486({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad6 = rfc46486({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url6 = rfc46486({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad6 = rfc46486({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/weald/node_modules/ms/dist/index.mjs
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
function ms(value, options2) {
  try {
    if (typeof value === "string" && value.length > 0) {
      return parse(value);
    } else if (typeof value === "number" && isFinite(value)) {
      return options2?.long ? fmtLong(value) : fmtShort(value);
    }
    throw new Error("Value is not a string or number.");
  } catch (error) {
    const message2 = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
    throw new Error(message2);
  }
}
function parse(str) {
  str = String(str);
  if (str.length > 100) {
    throw new Error("Value exceeds the maximum length of 100 characters.");
  }
  const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return NaN;
  }
  const n = parseFloat(match[1]);
  const type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      throw new Error(`The unit ${type} was matched, but no matching case exists.`);
  }
}
var dist_default = ms;
function fmtShort(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return `${Math.round(ms2 / d)}d`;
  }
  if (msAbs >= h) {
    return `${Math.round(ms2 / h)}h`;
  }
  if (msAbs >= m) {
    return `${Math.round(ms2 / m)}m`;
  }
  if (msAbs >= s) {
    return `${Math.round(ms2 / s)}s`;
  }
  return `${ms2}ms`;
}
function fmtLong(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return `${ms2} ms`;
}
function plural(ms2, msAbs, n, name29) {
  const isPlural = msAbs >= n * 1.5;
  return `${Math.round(ms2 / n)} ${name29}${isPlural ? "s" : ""}`;
}
function isError(error) {
  return typeof error === "object" && error !== null && "message" in error;
}

// node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce31;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = dist_default;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace2) {
    let hash2 = 0;
    for (let i = 0; i < namespace2.length; i++) {
      hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self2 = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format28) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format28];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug.namespace = namespace2;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace2);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace2, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i = 0; i < len; i++) {
      if (!split2[i]) {
        continue;
      }
      namespaces = split2[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name29) {
    if (name29[name29.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name29)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name29)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce31(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}

// node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
    return false;
  }
  return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + dist_default(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = "color: " + this.color;
  args.splice(1, 0, c, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
var log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage?.setItem("debug", namespaces);
    } else {
      storage?.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r;
  try {
    r = storage?.getItem("debug");
  } catch (error) {
  }
  if (!r && typeof process !== "undefined" && "env" in process) {
    r = process.env.DEBUG;
  }
  return r;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

// node_modules/weald/dist/src/index.js
var src_default6 = browser_default;

// node_modules/@libp2p/logger/dist/src/index.js
src_default6.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc6.baseEncode(v);
};
src_default6.formatters.t = (v) => {
  return v == null ? "undefined" : base326.baseEncode(v);
};
src_default6.formatters.m = (v) => {
  return v == null ? "undefined" : base646.baseEncode(v);
};
src_default6.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default6.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default6.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default6.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace2) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace2;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function defaultLogger() {
  return {
    forComponent(name29) {
      return logger(name29);
    }
  };
}
function logger(name29) {
  let trace = createDisabledLogger(`${name29}:trace`);
  if (src_default6.enabled(`${name29}:trace`) && src_default6.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = src_default6(`${name29}:trace`);
  }
  return Object.assign(src_default6(name29), {
    error: src_default6(`${name29}:error`),
    trace
  });
}

// node_modules/eventemitter3/index.mjs
var import_index6 = __toESM(require_eventemitter3(), 1);

// node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError5 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError5(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options2) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options2;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options2.signal) {
      const { signal } = options2;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first4 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first4 + step;
    if (comparator(array[it], value) <= 0) {
      first4 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first4;
}

// node_modules/p-queue/dist/priority-queue.js
var PriorityQueue = class {
  #queue = [];
  enqueue(run, options2) {
    options2 = {
      priority: 0,
      ...options2
    };
    const element = {
      priority: options2.priority,
      run
    };
    if (this.size && this.#queue[this.size - 1].priority >= options2.priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index, 0, element);
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options2) {
    return this.#queue.filter((element) => element.priority === options2.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
};

// node_modules/p-queue/dist/index.js
var PQueue = class extends import_index6.default {
  #carryoverConcurrencyCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #interval;
  #intervalEnd = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  #throwOnTimeout;
  /**
      Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
  
      Applies to each future operation.
      */
  timeout;
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options2) {
    super();
    options2 = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options2
    };
    if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options2.intervalCap?.toString() ?? ""}\` (${typeof options2.intervalCap})`);
    }
    if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options2.interval?.toString() ?? ""}\` (${typeof options2.interval})`);
    }
    this.#carryoverConcurrencyCount = options2.carryoverConcurrencyCount;
    this.#isIntervalIgnored = options2.intervalCap === Number.POSITIVE_INFINITY || options2.interval === 0;
    this.#intervalCap = options2.intervalCap;
    this.#interval = options2.interval;
    this.#queue = new options2.queueClass();
    this.#queueClass = options2.queueClass;
    this.concurrency = options2.concurrency;
    this.timeout = options2.timeout;
    this.#throwOnTimeout = options2.throwOnTimeout === true;
    this.#isPaused = options2.autoStart === false;
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = void 0;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === void 0) {
      const delay2 = this.#intervalEnd - now;
      if (delay2 < 0) {
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      } else {
        if (this.#timeoutId === void 0) {
          this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
          }, delay2);
        }
        return true;
      }
    }
    return false;
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
      }
      this.#intervalId = void 0;
      this.emit("empty");
      if (this.#pending === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = void 0;
    }
    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
    this.#processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  async add(function_, options2 = {}) {
    options2 = {
      timeout: this.timeout,
      throwOnTimeout: this.#throwOnTimeout,
      ...options2
    };
    return new Promise((resolve, reject) => {
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#intervalCount++;
        try {
          options2.signal?.throwIfAborted();
          let operation = function_({ signal: options2.signal });
          if (options2.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options2.timeout });
          }
          if (options2.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options2.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options2.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          this.#next();
        }
      }, options2);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options2) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  async #onEvent(event, filter3) {
    return new Promise((resolve) => {
      const listener = () => {
        if (filter3 && !filter3()) {
          return;
        }
        this.off(event, listener);
        resolve();
      };
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options2) {
    return this.#queue.filter(options2).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
};

// node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports6 = {};
__export(base10_exports6, {
  base10: () => base106
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bytes.js
var empty7 = new Uint8Array(0);
function equals15(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce7(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString10(str) {
  return new TextEncoder().encode(str);
}
function toString9(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/base-x.js
function base9(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src7 = base9;
var _brrp__multiformats_scope_baseX7 = src7;
var base_x_default7 = _brrp__multiformats_scope_baseX7;

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base.js
var Encoder7 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder7 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or7(this, decoder);
  }
};
var ComposedDecoder7 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or7(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or7(left, right) {
  return new ComposedDecoder7({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec7 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder7(name29, prefix, baseEncode);
    this.decoder = new Decoder7(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from12({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec7(name29, prefix, encode116, decode144);
}
function baseX7({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default7(alphabet27, name29);
  return from12({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce7(decode144(text))
  });
}
function decode29(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode24(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46487({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from12({
    prefix,
    name: name29,
    encode(input) {
      return encode24(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode29(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
var base106 = baseX7({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports6 = {};
__export(base16_exports6, {
  base16: () => base166,
  base16upper: () => base16upper6
});
var base166 = rfc46487({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper6 = rfc46487({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports6 = {};
__export(base2_exports6, {
  base2: () => base26
});
var base26 = rfc46487({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports6 = {};
__export(base256emoji_exports6, {
  base256emoji: () => base256emoji6
});
var alphabet6 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars6 = alphabet6.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes6 = alphabet6.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode25(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars6[c];
    return p;
  }, "");
}
function decode30(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes6[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji6 = from12({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode25,
  decode: decode30
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports6 = {};
__export(base32_exports6, {
  base32: () => base327,
  base32hex: () => base32hex7,
  base32hexpad: () => base32hexpad7,
  base32hexpadupper: () => base32hexpadupper7,
  base32hexupper: () => base32hexupper7,
  base32pad: () => base32pad7,
  base32padupper: () => base32padupper7,
  base32upper: () => base32upper7,
  base32z: () => base32z7
});
var base327 = rfc46487({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper7 = rfc46487({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad7 = rfc46487({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper7 = rfc46487({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex7 = rfc46487({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper7 = rfc46487({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad7 = rfc46487({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper7 = rfc46487({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z7 = rfc46487({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports6 = {};
__export(base36_exports6, {
  base36: () => base366,
  base36upper: () => base36upper6
});
var base366 = baseX7({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper6 = baseX7({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports6 = {};
__export(base58_exports6, {
  base58btc: () => base58btc7,
  base58flickr: () => base58flickr7
});
var base58btc7 = baseX7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr7 = baseX7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports6 = {};
__export(base64_exports6, {
  base64: () => base647,
  base64pad: () => base64pad7,
  base64url: () => base64url7,
  base64urlpad: () => base64urlpad7
});
var base647 = rfc46487({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad7 = rfc46487({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url7 = rfc46487({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad7 = rfc46487({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports6 = {};
__export(base8_exports6, {
  base8: () => base86
});
var base86 = rfc46487({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports11 = {};
__export(identity_exports11, {
  identity: () => identity11
});
var identity11 = from12({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString9(buf3),
  decode: (str) => fromString10(str)
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder6 = new TextEncoder();
var textDecoder6 = new TextDecoder();

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports12 = {};
__export(identity_exports12, {
  identity: () => identity12
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/varint.js
var encode_16 = encode26;
var MSB7 = 128;
var REST7 = 127;
var MSBALL6 = ~REST7;
var INT6 = Math.pow(2, 31);
function encode26(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB7;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode26.bytes = offset - oldOffset + 1;
  return out;
}
var decode31 = read7;
var MSB$16 = 128;
var REST$16 = 127;
function read7(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read7.bytes = counter - offset;
  return res;
}
var N17 = Math.pow(2, 7);
var N27 = Math.pow(2, 14);
var N37 = Math.pow(2, 21);
var N47 = Math.pow(2, 28);
var N57 = Math.pow(2, 35);
var N67 = Math.pow(2, 42);
var N77 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length7 = function(value) {
  return value < N17 ? 1 : value < N27 ? 2 : value < N37 ? 3 : value < N47 ? 4 : value < N57 ? 5 : value < N67 ? 6 : value < N77 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
};
var varint6 = {
  encode: encode_16,
  decode: decode31,
  encodingLength: length7
};
var _brrp_varint6 = varint6;
var varint_default6 = _brrp_varint6;

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/varint.js
function decode32(data, offset = 0) {
  const code33 = varint_default6.decode(data, offset);
  return [code33, varint_default6.decode.bytes];
}
function encodeTo6(int, target, offset = 0) {
  varint_default6.encode(int, target, offset);
  return target;
}
function encodingLength7(int) {
  return varint_default6.encodingLength(int);
}

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/digest.js
function create8(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength7(code33);
  const digestOffset = sizeOffset + encodingLength7(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo6(code33, bytes3, 0);
  encodeTo6(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest6(code33, size, digest27, bytes3);
}
function decode33(multihash) {
  const bytes3 = coerce7(multihash);
  const [code33, sizeOffset] = decode32(bytes3);
  const [size, digestOffset] = decode32(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code33, size, digest27, bytes3);
}
function equals16(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals15(a.bytes, data.bytes);
  }
}
var Digest6 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
var code6 = 0;
var name6 = "identity";
var encode27 = coerce7;
function digest6(input) {
  return create8(code6, encode27(input));
}
var identity12 = { code: code6, name: name6, encode: encode27, digest: digest6 };

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports6 = {};
__export(sha2_browser_exports6, {
  sha256: () => sha2567,
  sha512: () => sha5127
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/hasher.js
function from13({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher6(name29, code33, encode116);
}
var Hasher6 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create8(this.code, result) : result.then((digest27) => create8(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha6(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2567 = from13({
  name: "sha2-256",
  code: 18,
  encode: sha6("SHA-256")
});
var sha5127 = from13({
  name: "sha2-512",
  code: 19,
  encode: sha6("SHA-512")
});

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/cid.js
function format6(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV06(bytes3, baseCache6(link), base45 ?? base58btc7.encoder);
    default:
      return toStringV16(bytes3, baseCache6(link), base45 ?? base327.encoder);
  }
}
var cache6 = /* @__PURE__ */ new WeakMap();
function baseCache6(cid) {
  const baseCache28 = cache6.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache6.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID6 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create8(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals16(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format6(this, base45);
  }
  toJSON() {
    return { "/": format6(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID6(version3, code33, multihash.bytes));
    } else if (value[cidSymbol6] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode33(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE6) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID6(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE6, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode32(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE6;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes6(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache6(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes6(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc7;
      return [
        base58btc7.prefix,
        decoder.decode(`${base58btc7.prefix}${source}`)
      ];
    }
    case base58btc7.prefix: {
      const decoder = base45 ?? base58btc7;
      return [base58btc7.prefix, decoder.decode(source)];
    }
    case base327.prefix: {
      const decoder = base45 ?? base327;
      return [base327.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV06(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc7.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV16(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
function encodeCID6(version3, code33, multihash) {
  const codeOffset = encodingLength7(version3);
  const hashOffset = codeOffset + encodingLength7(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version3, bytes3, 0);
  encodeTo6(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/dns/node_modules/multiformats/dist/src/basics.js
var bases6 = { ...identity_exports11, ...base2_exports6, ...base8_exports6, ...base10_exports6, ...base16_exports6, ...base32_exports6, ...base36_exports6, ...base58_exports6, ...base64_exports6, ...base256emoji_exports6 };
var hashes6 = { ...sha2_browser_exports6, ...identity_exports12 };

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe9(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec7(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string6 = createCodec7("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii6 = createCodec7("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe9(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES6 = {
  utf8: string6,
  "utf-8": string6,
  hex: bases6.base16,
  latin1: ascii6,
  ascii: ascii6,
  binary: ascii6,
  ...bases6
};
var bases_default6 = BASES6;

// node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/to-string.js
function toString10(array, encoding = "utf8") {
  const base45 = bases_default6[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString10(answer.data) : answer.data
      };
    })
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options2 = {}) => {
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options2.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    options2.onProgress?.(new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options2?.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      options2.onProgress?.(new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options2.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  lru;
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache7(size) {
  return new CachedAnswers(size);
}

// node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  resolvers;
  cache;
  constructor(init) {
    this.resolvers = {};
    this.cache = cache7(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options2 = {}) {
    const types = getTypes(options2.types);
    const cached = options2.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      options2.onProgress?.(new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers2) {
      if (options2.signal?.aborted === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options2,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        options2.onProgress?.(new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}

// node_modules/@helia/utils/node_modules/it-drain/dist/src/index.js
function isAsyncIterable7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain2(source) {
  if (isAsyncIterable7(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default7 = drain2;

// node_modules/@helia/utils/node_modules/cborg/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/@helia/utils/node_modules/cborg/lib/token.js
var Type = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name29, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name29;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/@helia/utils/node_modules/cborg/lib/byte-utils.js
var useBuffer = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder7 = new TextDecoder();
var textEncoder7 = new TextEncoder();
function isBuffer2(buf3) {
  return useBuffer && globalThis.Buffer.isBuffer(buf3);
}
function asU8A(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer2(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
var toString11 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return end - start2 > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes3.subarray(start2, end)).toString("utf8")
    ) : utf8Slice(bytes3, start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return end - start2 > 64 ? textDecoder7.decode(bytes3.subarray(start2, end)) : utf8Slice(bytes3, start2, end);
  }
);
var fromString11 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string27) => {
    return string27.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string27)
    ) : utf8ToBytes3(string27);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string27) => {
    return string27.length > 64 ? textEncoder7.encode(string27) : utf8ToBytes3(string27);
  }
);
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    if (isBuffer2(bytes3)) {
      return new Uint8Array(bytes3.subarray(start2, end));
    }
    return bytes3.slice(start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return bytes3.slice(start2, end);
  }
);
var concat4 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length30) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A(globalThis.Buffer.concat(chunks, length30));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length30) => {
    const out = new Uint8Array(length30);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc5 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes3(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}

// node_modules/@helia/utils/node_modules/cborg/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes3) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes3.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes3, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
        topChunk = alloc5(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes3, 0);
      } else {
        this.chunks.push(bytes3);
        this.maxCursor += bytes3.length;
      }
    }
    this.cursor += bytes3.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat4(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/@helia/utils/node_modules/cborg/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/@helia/utils/node_modules/cborg/lib/0uint.js
var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options2) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options2.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options2) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options2.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options2) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options2.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options2) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options2.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options2.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint8(data, pos + 1, options2), 2);
}
function decodeUint16(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint16(data, pos + 1, options2), 3);
}
function decodeUint32(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint32(data, pos + 1, options2), 5);
}
function decodeUint64(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint64(data, pos + 1, options2), 9);
}
function encodeUint(buf3, token) {
  return encodeUintValue(buf3, 0, token.value);
}
function encodeUintValue(buf3, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf3.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/@helia/utils/node_modules/cborg/lib/1negint.js
function decodeNegint8(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options2), 2);
}
function decodeNegint16(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options2), 3);
}
function decodeNegint32(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options2), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options2) {
  const int = readUint64(data, pos + 1, options2);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options2.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf3, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/@helia/utils/node_modules/cborg/lib/2bytes.js
function toToken(data, pos, prefix, length30) {
  assertEnoughData(data, pos, prefix + length30);
  const buf3 = slice(data, pos + prefix, pos + prefix + length30);
  return new Token(Type.bytes, buf3, prefix + length30);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options2) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeBytes16(data, pos, _minor, options2) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeBytes32(data, pos, _minor, options2) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeBytes64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString11(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf3, token) {
  const bytes3 = tokenBytes(token);
  encodeUintValue(buf3, token.type.majorEncoded, bytes3.length);
  buf3.push(bytes3);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes3 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes3.length) + bytes3.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// node_modules/@helia/utils/node_modules/cborg/lib/3string.js
function toToken2(data, pos, prefix, length30, options2) {
  const totLength = prefix + length30;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString11(data, pos + prefix, pos + totLength), totLength);
  if (options2.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options2) {
  return toToken2(data, pos, 1, minor, options2);
}
function decodeString8(data, pos, _minor, options2) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options2), options2);
}
function decodeString16(data, pos, _minor, options2) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options2), options2);
}
function decodeString32(data, pos, _minor, options2) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options2), options2);
}
function decodeString64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options2);
}
var encodeString = encodeBytes;

// node_modules/@helia/utils/node_modules/cborg/lib/4array.js
function toToken3(_data, _pos, prefix, length30) {
  return new Token(Type.array, length30, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options2) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeArray16(data, pos, _minor, options2) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeArray32(data, pos, _minor, options2) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeArray64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf3, token) {
  encodeUintValue(buf3, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/@helia/utils/node_modules/cborg/lib/5map.js
function toToken4(_data, _pos, prefix, length30) {
  return new Token(Type.map, length30, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options2) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeMap16(data, pos, _minor, options2) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeMap32(data, pos, _minor, options2) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeMap64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf3, token) {
  encodeUintValue(buf3, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/@helia/utils/node_modules/cborg/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint8(data, pos + 1, options2), 2);
}
function decodeTag16(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint16(data, pos + 1, options2), 3);
}
function decodeTag32(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint32(data, pos + 1, options2), 5);
}
function decodeTag64(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint64(data, pos + 1, options2), 9);
}
function encodeTag(buf3, token) {
  encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/@helia/utils/node_modules/cborg/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options2) {
  if (options2.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options2.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes3, options2) {
  if (options2) {
    if (options2.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options2.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes3);
}
function decodeFloat16(data, pos, _minor, options2) {
  return createToken(readFloat16(data, pos + 1), 3, options2);
}
function decodeFloat32(data, pos, _minor, options2) {
  return createToken(readFloat32(data, pos + 1), 5, options2);
}
function decodeFloat64(data, pos, _minor, options2) {
  return createToken(readFloat64(data, pos + 1), 9, options2);
}
function encodeFloat(buf3, token, options2) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf3.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options2 || options2.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf3.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf3.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf3.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options2) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options2 || options2.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/@helia/utils/node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/@helia/utils/node_modules/cborg/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options2, refStack) {
    if (!obj.length) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options2, refStack);
    }
    if (options2.addBreakTokens) {
      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
    }
    return [new Token(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options2, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length30 = isMap ? obj.size : keys.length;
    if (!length30) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options2, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options2, refStack)
      ];
    }
    sortMapEntries(entries, options2);
    if (options2.addBreakTokens) {
      return [new Token(Type.map, length30), entries, new Token(Type.break)];
    }
    return [new Token(Type.map, length30), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options2 = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options2 && options2.typeEncoders && /** @type {OptionalTypeEncoder} */
  options2.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options2, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options2, refStack);
}
function sortMapEntries(entries, options2) {
  if (options2.mapSorter) {
    entries.sort(options2.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf3, tokens, encoders, options2) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf3, token, encoders, options2);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options2);
  }
}
function encodeCustom(data, encoders, options2) {
  const tokens = objectToTokens(data, options2);
  if (!Array.isArray(tokens) && options2.quickEncodeToken) {
    const quickBytes = options2.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options2);
      const buf3 = new Bl(size);
      encoder2(buf3, tokens, options2);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf3.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options2);
  return buf.toBytes(true);
}
function encode28(data, options2) {
  options2 = Object.assign({}, defaultEncodeOptions, options2);
  return encodeCustom(data, cborEncoders, options2);
}

// node_modules/@helia/utils/node_modules/cborg/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options2) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options2);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options2) {
  const useMaps = options2.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options2);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options2.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options2);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options2) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options2);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options2);
  }
  if (token.type === Type.tag) {
    if (options2.tags && typeof options2.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options2);
      return options2.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options2) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options2 = Object.assign({}, defaultDecodeOptions, options2);
  const tokeniser = options2.tokenizer || new Tokeniser(data, options2);
  const decoded = tokensToObject(tokeniser, options2);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode34(data, options2) {
  const [decoded, remainder] = decodeFirst(data, options2);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports7 = {};
__export(base10_exports7, {
  base10: () => base107
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bytes.js
var empty8 = new Uint8Array(0);
function equals17(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce8(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString12(str) {
  return new TextEncoder().encode(str);
}
function toString12(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/vendor/base-x.js
function base11(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src8 = base11;
var _brrp__multiformats_scope_baseX8 = src8;
var base_x_default8 = _brrp__multiformats_scope_baseX8;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base.js
var Encoder8 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder8 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or8(this, decoder);
  }
};
var ComposedDecoder8 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or8(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or8(left, right) {
  return new ComposedDecoder8({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec8 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder8(name29, prefix, baseEncode);
    this.decoder = new Decoder8(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from14({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec8(name29, prefix, encode116, decode144);
}
function baseX8({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default8(alphabet27, name29);
  return from14({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce8(decode144(text))
  });
}
function decode35(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode29(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46488({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from14({
    prefix,
    name: name29,
    encode(input) {
      return encode29(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode35(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base10.js
var base107 = baseX8({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports7 = {};
__export(base16_exports7, {
  base16: () => base167,
  base16upper: () => base16upper7
});
var base167 = rfc46488({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper7 = rfc46488({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports7 = {};
__export(base2_exports7, {
  base2: () => base27
});
var base27 = rfc46488({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports7 = {};
__export(base256emoji_exports7, {
  base256emoji: () => base256emoji7
});
var alphabet7 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars7 = alphabet7.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes7 = alphabet7.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode30(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars7[c];
    return p;
  }, "");
}
function decode36(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes7[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji7 = from14({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode30,
  decode: decode36
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports7 = {};
__export(base32_exports7, {
  base32: () => base328,
  base32hex: () => base32hex8,
  base32hexpad: () => base32hexpad8,
  base32hexpadupper: () => base32hexpadupper8,
  base32hexupper: () => base32hexupper8,
  base32pad: () => base32pad8,
  base32padupper: () => base32padupper8,
  base32upper: () => base32upper8,
  base32z: () => base32z8
});
var base328 = rfc46488({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper8 = rfc46488({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad8 = rfc46488({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper8 = rfc46488({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex8 = rfc46488({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper8 = rfc46488({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad8 = rfc46488({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper8 = rfc46488({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z8 = rfc46488({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports7 = {};
__export(base36_exports7, {
  base36: () => base367,
  base36upper: () => base36upper7
});
var base367 = baseX8({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper7 = baseX8({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports7 = {};
__export(base58_exports7, {
  base58btc: () => base58btc8,
  base58flickr: () => base58flickr8
});
var base58btc8 = baseX8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr8 = baseX8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports7 = {};
__export(base64_exports7, {
  base64: () => base648,
  base64pad: () => base64pad8,
  base64url: () => base64url8,
  base64urlpad: () => base64urlpad8
});
var base648 = rfc46488({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad8 = rfc46488({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url8 = rfc46488({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad8 = rfc46488({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports7 = {};
__export(base8_exports7, {
  base8: () => base87
});
var base87 = rfc46488({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports13 = {};
__export(identity_exports13, {
  identity: () => identity13
});
var identity13 = from14({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString12(buf3),
  decode: (str) => fromString12(str)
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder8 = new TextEncoder();
var textDecoder8 = new TextDecoder();
var code7 = 512;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/codecs/raw.js
var code8 = 85;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports14 = {};
__export(identity_exports14, {
  identity: () => identity14
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/vendor/varint.js
var encode_17 = encode31;
var MSB8 = 128;
var REST8 = 127;
var MSBALL7 = ~REST8;
var INT7 = Math.pow(2, 31);
function encode31(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT7) {
    out[offset++] = num & 255 | MSB8;
    num /= 128;
  }
  while (num & MSBALL7) {
    out[offset++] = num & 255 | MSB8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode31.bytes = offset - oldOffset + 1;
  return out;
}
var decode37 = read8;
var MSB$17 = 128;
var REST$17 = 127;
function read8(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$17);
  read8.bytes = counter - offset;
  return res;
}
var N18 = Math.pow(2, 7);
var N28 = Math.pow(2, 14);
var N38 = Math.pow(2, 21);
var N48 = Math.pow(2, 28);
var N58 = Math.pow(2, 35);
var N68 = Math.pow(2, 42);
var N78 = Math.pow(2, 49);
var N87 = Math.pow(2, 56);
var N97 = Math.pow(2, 63);
var length8 = function(value) {
  return value < N18 ? 1 : value < N28 ? 2 : value < N38 ? 3 : value < N48 ? 4 : value < N58 ? 5 : value < N68 ? 6 : value < N78 ? 7 : value < N87 ? 8 : value < N97 ? 9 : 10;
};
var varint7 = {
  encode: encode_17,
  decode: decode37,
  encodingLength: length8
};
var _brrp_varint7 = varint7;
var varint_default7 = _brrp_varint7;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/varint.js
function decode38(data, offset = 0) {
  const code33 = varint_default7.decode(data, offset);
  return [code33, varint_default7.decode.bytes];
}
function encodeTo7(int, target, offset = 0) {
  varint_default7.encode(int, target, offset);
  return target;
}
function encodingLength8(int) {
  return varint_default7.encodingLength(int);
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/digest.js
function create9(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength8(code33);
  const digestOffset = sizeOffset + encodingLength8(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo7(code33, bytes3, 0);
  encodeTo7(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest7(code33, size, digest27, bytes3);
}
function decode39(multihash) {
  const bytes3 = coerce8(multihash);
  const [code33, sizeOffset] = decode38(bytes3);
  const [size, digestOffset] = decode38(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest7(code33, size, digest27, bytes3);
}
function equals18(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals17(a.bytes, data.bytes);
  }
}
var Digest7 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/identity.js
var code9 = 0;
var name7 = "identity";
var encode32 = coerce8;
function digest7(input) {
  return create9(code9, encode32(input));
}
var identity14 = { code: code9, name: name7, encode: encode32, digest: digest7 };

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports7 = {};
__export(sha2_browser_exports7, {
  sha256: () => sha2568,
  sha512: () => sha5128
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/hasher.js
function from15({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher7(name29, code33, encode116);
}
var Hasher7 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create9(this.code, result) : result.then((digest27) => create9(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha7(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2568 = from15({
  name: "sha2-256",
  code: 18,
  encode: sha7("SHA-256")
});
var sha5128 = from15({
  name: "sha2-512",
  code: 19,
  encode: sha7("SHA-512")
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/cid.js
function format7(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV07(bytes3, baseCache7(link), base45 ?? base58btc8.encoder);
    default:
      return toStringV17(bytes3, baseCache7(link), base45 ?? base328.encoder);
  }
}
var cache8 = /* @__PURE__ */ new WeakMap();
function baseCache7(cid) {
  const baseCache28 = cache8.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache8.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID7 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create9(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals18(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format7(this, base45);
  }
  toJSON() {
    return { "/": format7(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID7(version3, code33, multihash.bytes));
    } else if (value[cidSymbol7] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode39(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE7) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID7(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE7, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce8(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest7(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode38(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE7;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes7(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache7(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes7(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc8;
      return [
        base58btc8.prefix,
        decoder.decode(`${base58btc8.prefix}${source}`)
      ];
    }
    case base58btc8.prefix: {
      const decoder = base45 ?? base58btc8;
      return [base58btc8.prefix, decoder.decode(source)];
    }
    case base328.prefix: {
      const decoder = base45 ?? base328;
      return [base328.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV07(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc8.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV17(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE7 = 112;
var SHA_256_CODE7 = 18;
function encodeCID7(version3, code33, multihash) {
  const codeOffset = encodingLength8(version3);
  const hashOffset = codeOffset + encodingLength8(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo7(version3, bytes3, 0);
  encodeTo7(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/utils/node_modules/multiformats/dist/src/basics.js
var bases7 = { ...identity_exports13, ...base2_exports7, ...base8_exports7, ...base10_exports7, ...base16_exports7, ...base32_exports7, ...base36_exports7, ...base58_exports7, ...base64_exports7, ...base256emoji_exports7 };
var hashes7 = { ...sha2_browser_exports7, ...identity_exports14 };

// node_modules/@helia/utils/node_modules/uint8arrays/dist/src/alloc.js
function alloc6(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe10(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@helia/utils/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec8(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string7 = createCodec8("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii7 = createCodec8("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe10(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES7 = {
  utf8: string7,
  "utf-8": string7,
  hex: bases7.base16,
  latin1: ascii7,
  ascii: ascii7,
  binary: ascii7,
  ...bases7
};
var bases_default7 = BASES7;

// node_modules/@helia/utils/node_modules/uint8arrays/dist/src/from-string.js
function fromString13(string27, encoding = "utf8") {
  const base45 = bases_default7[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@helia/utils/node_modules/uint8arrays/dist/src/to-string.js
function toString13(array, encoding = "utf8") {
  const base45 = bases_default7[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@helia/utils/node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString13(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString13(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/@helia/utils/node_modules/uint8arrays/dist/src/equals.js
function equals19(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@helia/utils/dist/src/pins.js
var DATASTORE_PIN_PREFIX = "/pin/";
var DATASTORE_BLOCK_PREFIX = "/pinned-block/";
var DATASTORE_ENCODING = base367;
var DAG_WALK_QUEUE_CONCURRENCY = 1;
function toDSKey(cid) {
  if (cid.version === 0) {
    cid = cid.toV1();
  }
  return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
}
var PinsImpl = class {
  datastore;
  blockstore;
  dagWalkers;
  constructor(datastore, blockstore, dagWalkers) {
    this.datastore = datastore;
    this.blockstore = blockstore;
    this.dagWalkers = dagWalkers;
  }
  async *add(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    if (await this.datastore.has(pinKey)) {
      throw new Error("Already pinned");
    }
    const depth = Math.round(options2.depth ?? Infinity);
    if (depth < 0) {
      throw new Error("Depth must be greater than or equal to 0");
    }
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of this.#walkDag(cid, queue, {
      ...options2,
      depth
    })) {
      await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
        if (pinnedBlock.pinnedBy.find((c) => equals19(c, cid.bytes)) != null) {
          return false;
        }
        pinnedBlock.pinCount++;
        pinnedBlock.pinnedBy.push(cid.bytes);
        return true;
      }, options2);
      yield childCid;
    }
    const pin = {
      depth,
      metadata: options2.metadata ?? {}
    };
    await this.datastore.put(pinKey, encode28(pin), options2);
  }
  /**
   * Walk a DAG in an iterable fashion
   */
  async *#walkDag(cid, queue, options2) {
    if (options2.depth === -1) {
      return;
    }
    const dagWalker = this.dagWalkers[cid.code];
    if (dagWalker == null) {
      throw new Error(`No dag walker found for cid codec ${cid.code}`);
    }
    const block = await this.blockstore.get(cid, options2);
    yield cid;
    for await (const cid2 of dagWalker.walk(block)) {
      yield* await queue.add(async () => {
        return this.#walkDag(cid2, queue, {
          ...options2,
          depth: options2.depth - 1
        });
      });
    }
  }
  /**
   * Update the pin count for the CID
   */
  async #updatePinnedBlock(cid, withPinnedBlock, options2) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    let pinnedBlock = {
      pinCount: 0,
      pinnedBy: []
    };
    try {
      pinnedBlock = decode34(await this.datastore.get(blockKey, options2));
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    const shouldContinue = withPinnedBlock(pinnedBlock);
    if (!shouldContinue) {
      return;
    }
    if (pinnedBlock.pinCount === 0) {
      if (await this.datastore.has(blockKey)) {
        await this.datastore.delete(blockKey);
        return;
      }
    }
    await this.datastore.put(blockKey, encode28(pinnedBlock), options2);
    options2.onProgress?.(new CustomProgressEvent("helia:pin:add", cid));
  }
  async *rm(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    const buf3 = await this.datastore.get(pinKey, options2);
    const pin = decode34(buf3);
    await this.datastore.delete(pinKey, options2);
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of this.#walkDag(cid, queue, {
      ...options2,
      depth: pin.depth
    })) {
      await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
        pinnedBlock.pinCount--;
        pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c) => equals19(c, cid.bytes));
        return true;
      }, {
        ...options2,
        depth: pin.depth
      });
      yield childCid;
    }
  }
  async *ls(options2 = {}) {
    for await (const { key, value } of this.datastore.query({
      prefix: DATASTORE_PIN_PREFIX + (options2.cid != null ? `${options2.cid.toString(base367)}` : "")
    }, options2)) {
      const cid = CID7.parse(key.toString().substring(5), base367);
      const pin = decode34(value);
      yield {
        cid,
        ...pin
      };
    }
  }
  async isPinned(cid, options2 = {}) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    return this.datastore.has(blockKey, options2);
  }
};

// node_modules/@helia/utils/dist/src/routing.js
var DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
var Routing = class {
  log;
  routers;
  providerLookupConcurrency;
  constructor(components, init) {
    this.log = components.logger.forComponent("helia:routing");
    this.routers = init.routers ?? [];
    this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
  }
  async start() {
    await start(...this.routers);
  }
  async stop() {
    await stop(...this.routers);
  }
  /**
   * Iterates over all content routers in parallel to find providers of the
   * given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    const queue = new PeerQueue({
      concurrency: this.providerLookupConcurrency
    });
    queue.addEventListener("error", () => {
    });
    for await (const peer of src_default4(queue.toGenerator(), ...supports(this.routers, "findProviders").map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length === 0) {
        if (queue.find(peer.id) != null) {
          continue;
        }
        queue.add(async () => {
          try {
            const provider = await this.findPeer(peer.id, options2);
            if (provider.multiaddrs.length === 0) {
              return null;
            }
            return provider;
          } catch (err) {
            this.log.error("could not load multiaddrs for peer %p", peer.id, err);
            return null;
          }
        }, {
          peerId: peer.id,
          signal: options2.signal
        }).catch((err) => {
          this.log.error("could not load multiaddrs for peer %p", peer.id, err);
        });
      }
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    await Promise.all(supports(this.routers, "provide").map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options2) {
    await Promise.all(supports(this.routers, "put").map(async (router) => {
      await router.put(key, value, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    return Promise.any(supports(this.routers, "get").map(async (router) => {
      return router.get(key, options2);
    }));
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    const self2 = this;
    const source = src_default4(...supports(this.routers, "findPeer").map((router) => async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      return peer;
    }
    throw new CodeError("Could not find peer in routing", "ERR_NOT_FOUND");
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    for await (const peer of src_default4(...supports(this.routers, "getClosestPeers").map((router) => router.getClosestPeers(key, options2)))) {
      if (peer == null) {
        continue;
      }
      yield peer;
    }
  }
};
function supports(routers, key) {
  return routers.filter((router) => router[key] != null);
}

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default8 = observable;

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/mortice/dist/src/utils.js
var nanoid = (size = 21) => {
  return Math.random().toString().substring(2);
};

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name29, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name29
    });
    return new Promise((resolve) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name29
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions = {
  singleProcess: false
};
var browser_default2 = (options2) => {
  options2 = Object.assign({}, defaultOptions, options2);
  const isPrimary = Boolean(globalThis.document) || options2.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default8.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default8.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name29) => makeWorkerLockRequest(name29, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name29) => makeWorkerLockRequest(name29, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options2) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => pTimeout((async () => {
    await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options2.timeout
  }));
  return p;
}
var createMutex = (name29, options2) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name29, options2),
      writeLock: implementation.writeLock(name29, options2)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return createReleaseable(readQueue, options2);
      }
      readQueue = new PQueue({
        concurrency: options2.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options2);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock() {
      readQueue = null;
      return createReleaseable(masterQueue, options2);
    }
  };
};
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options2) {
  const opts = Object.assign({}, defaultOptions2, options2);
  if (implementation == null) {
    implementation = browser_default2(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/@helia/utils/dist/src/storage.js
var BlockStorage = class {
  lock;
  child;
  pins;
  started;
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, pins, options2 = {}) {
    this.child = blockstore;
    this.pins = pins;
    this.lock = createMortice({
      singleProcess: options2.holdGcLock
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child);
    this.started = true;
  }
  async stop() {
    await stop(this.child);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.put(cid, block, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.putMany(blocks, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.get(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getMany(cids, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      if (await this.pins.isPinned(cid)) {
        throw new Error("CID was pinned");
      }
      await this.child.delete(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      const storage2 = this;
      yield* this.child.deleteMany(async function* () {
        for await (const cid of cids) {
          if (await storage2.pins.isPinned(cid)) {
            throw new Error("CID was pinned");
          }
          yield cid;
        }
      }(), options2);
    } finally {
      releaseLock();
    }
  }
  async has(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.has(cid, options2);
    } finally {
      releaseLock();
    }
  }
  async *getAll(options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getAll(options2);
    } finally {
      releaseLock();
    }
  }
  createSession(root, options2) {
    options2?.signal?.throwIfAborted();
    return this.child.createSession(root, options2);
  }
};

// node_modules/@helia/utils/node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID7.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes3 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes3.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes3)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var _encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
var encodeOptions = {
  ..._encodeOptions,
  typeEncoders: {
    ..._encodeOptions.typeEncoders
  }
};
function cidDecoder(bytes3) {
  if (bytes3[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID7.decode(bytes3.subarray(1));
}
var _decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var decodeOptions = {
  ..._decodeOptions,
  tags: _decodeOptions.tags.slice()
};
var code10 = 113;

// node_modules/@helia/utils/node_modules/cborg/lib/json/encode.js
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  /**
   * @param {Bl} buf
   */
  prefix(buf3) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf3.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf3.push([44]);
          } else {
            buf3.push([58]);
          }
        }
      }
    }
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.uint.major](buf3, token) {
    this.prefix(buf3);
    const is3 = String(token.value);
    const isa = [];
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
    }
    buf3.push(isa);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.negint.major](buf3, token) {
    this[Type.uint.major](buf3, token);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.string.major](buf3, token) {
    this.prefix(buf3);
    const byts = fromString11(JSON.stringify(token.value));
    buf3.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.array.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({ type: Type.array, elements: 0 });
    buf3.push([91]);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.map.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({ type: Type.map, elements: 0 });
    buf3.push([123]);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.tag.major](_buf, _token) {
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.float.major](buf3, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf3.push([93]);
        } else if (recurs.type === Type.map) {
          buf3.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf3);
    if (token.type.name === "true") {
      buf3.push([116, 114, 117, 101]);
      return;
    } else if (token.type.name === "false") {
      buf3.push([102, 97, 108, 115, 101]);
      return;
    } else if (token.type.name === "null") {
      buf3.push([110, 117, 108, 108]);
      return;
    }
    const is3 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf3.push(isa);
  }
};

// node_modules/@helia/utils/node_modules/cborg/lib/json/decode.js
var Tokenizer = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  pos() {
    return this._pos;
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this._pos >= this.data.length;
  }
  /**
   * @returns {number}
   */
  ch() {
    return this.data[this._pos];
  }
  /**
   * @returns {string}
   */
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this._pos];
    }
  }
  /**
   * @param {number[]} str
   */
  expect(str) {
    if (this.data.length - this._pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this._pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this._pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this._pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this._pos++;
    }
    if (this.ch() === 48) {
      this._pos++;
      if (this.ch() === 46) {
        this._pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this._pos - startPos);
      }
    }
    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    if (negative && this._pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
      }
      float = true;
      this._pos++;
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this._pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this._pos++;
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this._pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
  }
  /**
   * @returns {Token}
   */
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
    }
    this._pos++;
    for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
        this._pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this._pos;
    const chars = [];
    const readu4 = () => {
      if (this._pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
        }
        u4 = u4 * 16 + ch;
        this._pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this._pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        /* c8 ignore next 6 */
        // this case is dealt with by the caller function
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this._pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          fourthByte = this.data[this._pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this._pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this._pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
          }
          ch1 = this.ch();
          this._pos++;
          switch (ch1) {
            case 34:
            // '"'
            case 39:
            // '\''
            case 92:
            // '\'
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
          }
          break;
        case 34:
          this._pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this._pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
  }
  /**
   * @returns {Token}
   */
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this._pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this._pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([110, 117, 108, 108]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([102, 97, 108, 115, 101]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([116, 114, 117, 101]);
        return new Token(Type.true, true, 4);
      case 45:
      // '-'
      case 48:
      // '0'
      case 49:
      // '1'
      case 50:
      // '2'
      case 51:
      // '3'
      case 52:
      // '4'
      case 53:
      // '5'
      case 54:
      // '6'
      case 55:
      // '7'
      case 56:
      // '8'
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
    }
  }
  /**
   * @returns {Token}
   */
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      // @ts-ignore
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      /* c8 ignore next 2 */
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
    }
  }
};
function decode40(data, options2) {
  options2 = Object.assign({ tokenizer: new Tokenizer(data, options2) }, options2);
  return decode34(data, options2);
}

// node_modules/@helia/utils/node_modules/@ipld/dag-json/src/index.js
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions2.tags[42] = CID7.parse;
var code11 = 297;
var utf8Decoder = new TextDecoder();
var utf8Encoder = new TextEncoder();

// node_modules/@helia/utils/node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder9 = new TextDecoder();
function decodeVarint(bytes3, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes3.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes3[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes3, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes3, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes3.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes3.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes3, index) {
  let wire;
  [wire, index] = decodeVarint(bytes3, index);
  return [wire & 7, wire >> 3, index];
}
function decodeLink(bytes3) {
  const link = {};
  const l = bytes3.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes3, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      link.Name = textDecoder9.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes3, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes3) {
  const l = bytes3.length;
  let index = 0;
  let links = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes3, index);
      if (links) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links) {
        links = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      links.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links || [];
  return node;
}

// node_modules/@helia/utils/node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder9 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;

// node_modules/@helia/utils/node_modules/@ipld/dag-pb/src/util.js
var textEncoder10 = new TextEncoder();
function toByteView(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}

// node_modules/@helia/utils/node_modules/@ipld/dag-pb/src/index.js
var code12 = 112;
function decode41(bytes3) {
  const buf3 = toByteView(bytes3);
  const pbn = decodeNode(buf3);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID7.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/@helia/utils/dist/src/utils/dag-walkers.js
var dagPbWalker = {
  codec: code12,
  *walk(block) {
    const node = decode41(block);
    yield* node.Links.map((l) => l.Hash);
  }
};
var rawWalker = {
  codec: code8,
  *walk() {
  }
};
var CID_TAG = 42;
var dagCborWalker = {
  codec: code10,
  *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (bytes3) => {
      if (bytes3[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      const cid = CID7.decode(bytes3.subarray(1));
      cids.push(cid);
      return cid;
    };
    decode34(block, {
      tags
    });
    yield* cids;
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  tokenBuffer;
  constructor(data, options2) {
    super(data, options2);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   */
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes3 = base648.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes3, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var dagJsonWalker = {
  codec: code11,
  *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (string27) => {
      const cid = CID7.parse(string27);
      cids.push(cid);
      return cid;
    };
    decode40(block, {
      tags,
      tokenizer: new DagJsonTokenizer(block, {
        tags,
        allowIndefinite: true,
        allowUndefined: true,
        allowNaN: true,
        allowInfinity: true,
        allowBigInt: true,
        strict: false,
        rejectDuplicateMapKeys: false
      })
    });
    yield* cids;
  }
};
var jsonWalker = {
  codec: code7,
  *walk() {
  }
};
function defaultDagWalkers(walkers = []) {
  const output3 = {};
  [
    dagPbWalker,
    rawWalker,
    dagCborWalker,
    dagJsonWalker,
    jsonWalker,
    ...walkers
  ].forEach((dagWalker) => {
    output3[dagWalker.codec] = dagWalker;
  });
  return output3;
}

// node_modules/@helia/utils/dist/src/utils/datastore-version.js
var DS_VERSION_KEY = new Key("/version");
var CURRENT_VERSION = 1;
async function assertDatastoreVersionIsCurrent(datastore) {
  if (!await datastore.has(DS_VERSION_KEY)) {
    await datastore.put(DS_VERSION_KEY, fromString13(`${CURRENT_VERSION}`));
    return;
  }
  const buf3 = await datastore.get(DS_VERSION_KEY);
  const str = toString13(buf3);
  const version3 = parseInt(str, 10);
  if (version3 !== CURRENT_VERSION) {
    throw new Error("Unknown datastore version, a datastore migration may be required");
  }
}

// node_modules/@helia/utils/dist/src/utils/default-hashers.js
function defaultHashers(hashers = []) {
  const output3 = {};
  [
    sha2568,
    sha5128,
    identity14,
    ...hashers
  ].forEach((hasher) => {
    output3[hasher.code] = hasher;
  });
  return output3;
}

// node_modules/@helia/utils/node_modules/any-signal/dist/src/index.js
function anySignal2(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/@helia/utils/node_modules/blockstore-core/dist/src/base.js
var BaseBlockstore = class {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options2);
      yield cid;
    }
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
};

// node_modules/@helia/utils/node_modules/blockstore-core/dist/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  closeFailedError: () => closeFailedError,
  deleteFailedError: () => deleteFailedError,
  getFailedError: () => getFailedError,
  hasFailedError: () => hasFailedError,
  notFoundError: () => notFoundError,
  openFailedError: () => openFailedError,
  putFailedError: () => putFailedError
});
var import_err_code = __toESM(require_err_code(), 1);
function openFailedError(err) {
  err = err ?? new Error("Open failed");
  return (0, import_err_code.default)(err, "ERR_OPEN_FAILED");
}
function closeFailedError(err) {
  err = err ?? new Error("Close failed");
  return (0, import_err_code.default)(err, "ERR_CLOSE_FAILED");
}
function putFailedError(err) {
  err = err ?? new Error("Put failed");
  return (0, import_err_code.default)(err, "ERR_PUT_FAILED");
}
function getFailedError(err) {
  err = err ?? new Error("Get failed");
  return (0, import_err_code.default)(err, "ERR_GET_FAILED");
}
function deleteFailedError(err) {
  err = err ?? new Error("Delete failed");
  return (0, import_err_code.default)(err, "ERR_DELETE_FAILED");
}
function hasFailedError(err) {
  err = err ?? new Error("Has failed");
  return (0, import_err_code.default)(err, "ERR_HAS_FAILED");
}
function notFoundError(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err ?? new Error("Aborted");
  return (0, import_err_code.default)(err, "ERR_ABORTED");
}

// node_modules/@helia/utils/node_modules/it-peekable/dist/src/index.js
function peekable2(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default9 = peekable2;

// node_modules/@helia/utils/node_modules/it-filter/dist/src/index.js
function isAsyncIterable8(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable8(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable8 = src_default9(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable8) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func2 = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable8) {
      if (func2(entry, index++)) {
        yield entry;
      }
    }
  }();
}
var src_default10 = filter;

// node_modules/@helia/utils/node_modules/blockstore-core/dist/src/tiered.js
var log3 = logger("blockstore:core:tiered");

// node_modules/@helia/utils/node_modules/blockstore-core/dist/src/index.js
var Errors = {
  ...errors_exports
};

// node_modules/@helia/utils/node_modules/blockstore-core/dist/src/identity.js
var IDENTITY_CODEC = 0;
var IdentityBlockstore = class extends BaseBlockstore {
  child;
  constructor(child) {
    super();
    this.child = child;
  }
  put(key, block) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key;
    }
    if (this.child == null) {
      return key;
    }
    return this.child.put(key, block);
  }
  get(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key.multihash.digest;
    }
    if (this.child == null) {
      throw Errors.notFoundError();
    }
    return this.child.get(key);
  }
  has(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return true;
    }
    if (this.child == null) {
      return false;
    }
    return this.child.has(key);
  }
  delete(key) {
    if (key.code === IDENTITY_CODEC) {
      return;
    }
    if (this.child != null) {
      return this.child.delete(key);
    }
  }
  getAll(options2) {
    if (this.child != null) {
      return this.child.getAll(options2);
    }
    return [];
  }
};

// node_modules/it-foreach/node_modules/it-peekable/dist/src/index.js
function peekable3(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default11 = peekable3;

// node_modules/it-foreach/dist/src/index.js
function isAsyncIterable9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function isPromise2(thing) {
  return thing?.then != null;
}
function forEach(source, fn) {
  let index = 0;
  if (isAsyncIterable9(source)) {
    return async function* () {
      for await (const val of source) {
        const res2 = fn(val, index++);
        if (isPromise2(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const peekable8 = src_default11(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res?.then === "function") {
    return async function* () {
      yield value;
      for await (const val of peekable8) {
        const res2 = fn(val, index++);
        if (isPromise2(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const func2 = fn;
  return function* () {
    yield value;
    for (const val of peekable8) {
      func2(val, index++);
      yield val;
    }
  }();
}
var src_default12 = forEach;

// node_modules/@helia/utils/dist/src/utils/networked-storage.js
var Storage = class {
  child;
  hashers;
  log;
  logger;
  components;
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    this.log = components.logger.forComponent("helia:networked-storage");
    this.logger = components.logger;
    this.components = components;
    this.child = new IdentityBlockstore(components.blockstore);
    this.hashers = components.hashers ?? {};
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    if (await this.child.has(cid, options2)) {
      options2.onProgress?.(new CustomProgressEvent("blocks:put:duplicate", cid));
      return cid;
    }
    options2.onProgress?.(new CustomProgressEvent("blocks:put:providers:notify", cid));
    await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
    options2.onProgress?.(new CustomProgressEvent("blocks:put:blockstore:put", cid));
    return this.child.put(cid, block, options2);
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const missingBlocks = src_default10(blocks, async ({ cid }) => {
      const has = await this.child.has(cid, options2);
      if (has) {
        options2.onProgress?.(new CustomProgressEvent("blocks:put-many:duplicate", cid));
      }
      return !has;
    });
    const notifyEach = src_default12(missingBlocks, async ({ cid, block }) => {
      options2.onProgress?.(new CustomProgressEvent("blocks:put-many:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
    });
    options2.onProgress?.(new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
    yield* this.child.putMany(notifyEach, options2);
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    if (options2.offline !== true && !await this.child.has(cid, options2)) {
      options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:get", cid));
      const block = await raceBlockRetrievers(cid, this.components.blockBrokers, this.hashers[cid.multihash.code], {
        ...options2,
        log: this.log
      });
      options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:put", cid));
      await this.child.put(cid, block, options2);
      options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
      return block;
    }
    options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:get", cid));
    return this.child.get(cid, options2);
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
    yield* this.child.getMany(src_default12(cids, async (cid) => {
      if (options2.offline !== true && !await this.child.has(cid, options2)) {
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:get", cid));
        const block = await raceBlockRetrievers(cid, this.components.blockBrokers, this.hashers[cid.multihash.code], {
          ...options2,
          log: this.log
        });
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
        await this.child.put(cid, block, options2);
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
      }
    }));
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
    await this.child.delete(cid, options2);
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
    yield* this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cid;
      }
    }(), options2);
  }
  async has(cid, options2 = {}) {
    return this.child.has(cid, options2);
  }
  async *getAll(options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
    yield* this.child.getAll(options2);
  }
};
var NetworkedStorage = class extends Storage {
  started;
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    super(components);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child, ...this.components.blockBrokers);
    this.started = true;
  }
  async stop() {
    await stop(this.child, ...this.components.blockBrokers);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  createSession(root, options2) {
    const blockBrokers = this.components.blockBrokers.map((broker) => {
      if (broker.createSession == null) {
        return broker;
      }
      return broker.createSession(options2);
    });
    return new SessionStorage({
      blockstore: this.child,
      blockBrokers,
      hashers: this.hashers,
      logger: this.logger
    }, {
      root
    });
  }
};
var SessionStorage = class extends Storage {
  closeController;
  constructor(components, init) {
    super(components);
    this.closeController = new AbortController();
    setMaxListeners2(Infinity, this.closeController.signal);
    this.log = components.logger.forComponent(`helia:session-storage:${init.root}`);
  }
  close() {
    this.closeController.abort();
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      return await super.put(cid, block, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      yield* super.putMany(blocks, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      return await super.get(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      yield* super.getMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      await super.delete(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      yield* super.deleteMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async has(cid, options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      return await super.has(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async *getAll(options2 = {}) {
    const signal = anySignal2([this.closeController.signal, options2.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      yield* super.getAll({
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
};
function isRetrievingBlockBroker(broker) {
  return typeof broker.retrieve === "function";
}
var getCidBlockVerifierFunction = (cid, hasher) => {
  if (hasher == null) {
    throw new CodeError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`, "ERR_UNKNOWN_HASH_ALG");
  }
  return async (block) => {
    const hash2 = await hasher.digest(block);
    if (!equals19(hash2.digest, cid.multihash.digest)) {
      throw new CodeError("Hash of downloaded block did not match multihash from passed CID", "ERR_HASH_MISMATCH");
    }
  };
};
async function raceBlockRetrievers(cid, blockBrokers, hasher, options2) {
  const validateFn = getCidBlockVerifierFunction(cid, hasher);
  const controller = new AbortController();
  const signal = anySignal2([controller.signal, options2.signal]);
  setMaxListeners2(Infinity, controller.signal, signal);
  const retrievers = [];
  for (const broker of blockBrokers) {
    if (isRetrievingBlockBroker(broker)) {
      retrievers.push(broker);
    }
  }
  try {
    return await Promise.any(retrievers.map(async (retriever) => {
      try {
        let blocksWereValidated = false;
        const block = await retriever.retrieve(cid, {
          ...options2,
          signal,
          validateFn: async (block2) => {
            await validateFn(block2);
            blocksWereValidated = true;
          }
        });
        if (!blocksWereValidated) {
          await validateFn(block);
        }
        return block;
      } catch (err) {
        options2.log.error("could not retrieve verified block for %c", cid, err);
        throw err;
      }
    }));
  } finally {
    controller.abort();
    signal.clear();
  }
}

// node_modules/@helia/interface/dist/src/blocks.js
var DEFAULT_SESSION_MIN_PROVIDERS = 1;
var DEFAULT_SESSION_MAX_PROVIDERS = 5;

// node_modules/@helia/utils/node_modules/p-defer/index.js
function pDefer3() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@helia/utils/dist/src/bloom-filter.js
var import_murmurhash3js_revisited3 = __toESM(require_murmurhash3js_revisited(), 1);
var LN2_SQUARED2 = Math.LN2 * Math.LN2;
var BloomFilter2 = class _BloomFilter {
  /**
   * Create a `BloomFilter` with the smallest `bits` and `hashes` value for the
   * specified item count and error rate.
   */
  static create(itemcount, errorRate = 5e-3) {
    const opts = optimize3(itemcount, errorRate);
    return new _BloomFilter(opts);
  }
  seeds;
  bits;
  buffer;
  constructor(options2 = {}) {
    if (options2.seeds != null) {
      this.seeds = options2.seeds;
    } else {
      this.seeds = generateSeeds2(options2.hashes ?? 8);
    }
    this.bits = options2.bits ?? 1024;
    this.buffer = alloc6(Math.ceil(this.bits / 8));
  }
  /**
   * Add an item to the filter
   */
  add(item) {
    if (typeof item === "string") {
      item = fromString13(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = import_murmurhash3js_revisited3.default.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      this.setbit(bit);
    }
  }
  /**
   * Test if the filter has an item. If it returns false it definitely does not
   * have the item. If it returns true, it probably has the item but there's
   * an `errorRate` chance it doesn't.
   */
  has(item) {
    if (typeof item === "string") {
      item = fromString13(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = import_murmurhash3js_revisited3.default.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      const isSet = this.getbit(bit);
      if (!isSet) {
        return false;
      }
    }
    return true;
  }
  /**
   * Reset the filter
   */
  clear() {
    this.buffer.fill(0);
  }
  setbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    let bitfield = this.buffer[pos];
    bitfield |= 1 << shift;
    this.buffer[pos] = bitfield;
  }
  getbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    const bitfield = this.buffer[pos];
    return (bitfield & 1 << shift) !== 0;
  }
};
function optimize3(itemcount, errorRate = 5e-3) {
  const bits2 = Math.round(-1 * itemcount * Math.log(errorRate) / LN2_SQUARED2);
  const hashes27 = Math.round(bits2 / itemcount * Math.LN2);
  return { bits: bits2, hashes: hashes27 };
}
function generateSeeds2(count) {
  let buf3;
  let j;
  const seeds = [];
  for (let i = 0; i < count; i++) {
    buf3 = new Uint8ArrayList(randomBytes2(4));
    seeds[i] = buf3.getUint32(0, true);
    for (j = 0; j < i; j++) {
      if (seeds[i] === seeds[j]) {
        i--;
        break;
      }
    }
  }
  return seeds;
}

// node_modules/@helia/utils/dist/src/abstract-session.js
var AbstractSession = class extends TypedEventEmitter {
  intialPeerSearchComplete;
  requests;
  name;
  log;
  logger;
  minProviders;
  maxProviders;
  providers;
  evictionFilter;
  constructor(components, init) {
    super();
    setMaxListeners2(Infinity, this);
    this.name = init.name;
    this.logger = components.logger;
    this.log = components.logger.forComponent(this.name);
    this.requests = /* @__PURE__ */ new Map();
    this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
    this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
    this.providers = [];
    this.evictionFilter = BloomFilter2.create(this.maxProviders);
  }
  async retrieve(cid, options2 = {}) {
    const cidStr = base648.encode(cid.multihash.bytes);
    const existingJob = this.requests.get(cidStr);
    if (existingJob != null) {
      this.log("join existing request for %c", cid);
      return existingJob;
    }
    const deferred = pDefer3();
    this.requests.set(cidStr, deferred.promise);
    if (this.providers.length === 0) {
      let first4 = false;
      if (this.intialPeerSearchComplete == null) {
        first4 = true;
        this.log = this.logger.forComponent(`${this.name}:${cid}`);
        this.intialPeerSearchComplete = this.findProviders(cid, this.minProviders, options2);
      }
      await this.intialPeerSearchComplete;
      if (first4) {
        this.log("found initial session peers for %c", cid);
      }
    }
    let foundBlock = false;
    const queue = new Queue({
      concurrency: this.maxProviders
    });
    queue.addEventListener("error", () => {
    });
    queue.addEventListener("failure", (evt) => {
      this.log.error("error querying provider %o, evicting from session", evt.detail.job.options.provider, evt.detail.error);
      this.evict(evt.detail.job.options.provider);
    });
    queue.addEventListener("success", (evt) => {
      foundBlock = true;
      deferred.resolve(evt.detail.result);
    });
    queue.addEventListener("idle", () => {
      if (foundBlock || options2.signal?.aborted === true) {
        return;
      }
      Promise.resolve().then(async () => {
        this.log("no session peers had block for for %c, finding new providers", cid);
        for (let i = 0; i < this.minProviders; i++) {
          if (this.providers.length === 0) {
            break;
          }
          const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
          this.evict(provider);
        }
        await this.findProviders(cid, this.minProviders, options2);
        this.log("found new providers re-retrieving %c", cid);
        this.requests.delete(cidStr);
        deferred.resolve(await this.retrieve(cid, options2));
      }).catch((err) => {
        this.log.error("could not find new providers for %c", cid, err);
        deferred.reject(err);
      });
    });
    const peerAddedToSessionListener = (event) => {
      queue.add(async () => {
        return this.queryProvider(cid, event.detail, options2);
      }, {
        provider: event.detail
      }).catch((err) => {
        if (options2.signal?.aborted === true) {
          return;
        }
        this.log.error("error retrieving session block for %c", cid, err);
      });
    };
    this.addEventListener("provider", peerAddedToSessionListener);
    Promise.all([...this.providers].map(async (provider) => {
      return queue.add(async () => {
        return this.queryProvider(cid, provider, options2);
      }, {
        provider
      });
    })).catch((err) => {
      if (options2.signal?.aborted === true) {
        return;
      }
      this.log.error("error retrieving session block for %c", cid, err);
    });
    try {
      return await deferred.promise;
    } finally {
      this.removeEventListener("provider", peerAddedToSessionListener);
      queue.clear();
      this.requests.delete(cidStr);
    }
  }
  evict(provider) {
    this.evictionFilter.add(this.toEvictionKey(provider));
    const index = this.providers.findIndex((prov) => this.equals(prov, provider));
    if (index === -1) {
      return;
    }
    this.providers.splice(index, 1);
  }
  isEvicted(provider) {
    return this.evictionFilter.has(this.toEvictionKey(provider));
  }
  hasProvider(provider) {
    if (this.providers.find((prov) => this.equals(prov, provider)) != null) {
      return true;
    }
    if (this.isEvicted(provider)) {
      return true;
    }
    return false;
  }
  async findProviders(cid, count, options2) {
    const deferred = pDefer3();
    let found = 0;
    void Promise.resolve().then(async () => {
      this.log("finding %d-%d new provider(s) for %c", count, this.maxProviders, cid);
      for await (const provider of this.findNewProviders(cid, options2)) {
        if (found === this.maxProviders || options2.signal?.aborted === true) {
          break;
        }
        if (this.hasProvider(provider)) {
          continue;
        }
        this.log("found %d/%d new providers", found, this.maxProviders);
        this.providers.push(provider);
        this.safeDispatchEvent("provider", {
          detail: provider
        });
        found++;
        if (found === count) {
          this.log("session is ready");
          deferred.resolve();
        }
        if (this.providers.length === this.maxProviders) {
          this.log("found max session peers", found);
          break;
        }
      }
      this.log("found %d/%d new session peers", found, this.maxProviders);
      if (found < count) {
        throw new CodeError(`Found ${found} of ${count} ${this.name} providers for ${cid}`, "ERR_INSUFFICIENT_PROVIDERS_FOUND");
      }
    }).catch((err) => {
      this.log.error("error searching routing for potential session peers for %c", cid, err.errors ?? err);
      deferred.reject(err);
    });
    return deferred.promise;
  }
};

// node_modules/@helia/utils/dist/src/index.js
var Helia = class {
  blockstore;
  datastore;
  pins;
  logger;
  routing;
  dagWalkers;
  hashers;
  dns;
  metrics;
  log;
  constructor(init) {
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("helia");
    this.hashers = defaultHashers(init.hashers);
    this.dagWalkers = defaultDagWalkers(init.dagWalkers);
    this.dns = init.dns ?? dns();
    this.metrics = init.metrics;
    const components = {
      blockstore: init.blockstore,
      datastore: init.datastore,
      hashers: this.hashers,
      dagWalkers: this.dagWalkers,
      logger: this.logger,
      blockBrokers: [],
      dns: this.dns,
      metrics: this.metrics,
      ...init.components ?? {}
    };
    this.routing = components.routing = new Routing(components, {
      routers: (init.routers ?? []).flatMap((router) => {
        const routers = [
          router
        ];
        if (router[contentRoutingSymbol] != null) {
          routers.push(router[contentRoutingSymbol]);
        }
        if (router[peerRoutingSymbol] != null) {
          routers.push(router[peerRoutingSymbol]);
        }
        return routers;
      }),
      providerLookupConcurrency: init.providerLookupConcurrency
    });
    const networkedStorage = new NetworkedStorage(components);
    this.pins = new PinsImpl(init.datastore, networkedStorage, this.dagWalkers);
    this.blockstore = new BlockStorage(networkedStorage, this.pins, {
      holdGcLock: init.holdGcLock ?? true
    });
    this.datastore = init.datastore;
    components.blockBrokers = init.blockBrokers.map((fn) => {
      return fn(components);
    });
  }
  async start() {
    await assertDatastoreVersionIsCurrent(this.datastore);
    await start(this.blockstore, this.datastore, this.routing);
  }
  async stop() {
    await stop(this.blockstore, this.datastore, this.routing);
  }
  async gc(options2 = {}) {
    const releaseLock = await this.blockstore.lock.writeLock();
    try {
      const helia = this;
      const blockstore = this.blockstore.unwrap();
      this.log("gc start");
      await src_default7(blockstore.deleteMany(async function* () {
        for await (const { cid } of blockstore.getAll()) {
          try {
            if (await helia.pins.isPinned(cid, options2)) {
              continue;
            }
            yield cid;
            options2.onProgress?.(new CustomProgressEvent("helia:gc:deleted", cid));
          } catch (err) {
            helia.log.error("Error during gc", err);
            options2.onProgress?.(new CustomProgressEvent("helia:gc:error", err));
          }
        }
      }()));
    } finally {
      releaseLock();
    }
    this.log("gc finished");
  }
};

// node_modules/@helia/bitswap/dist/src/session.js
var BitswapSession = class extends AbstractSession {
  wantList;
  network;
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:bitswap:session"
    });
    this.wantList = components.wantList;
    this.network = components.network;
  }
  async queryProvider(cid, provider, options2) {
    this.log("sending WANT-BLOCK for %c to %p", cid, provider);
    const result = await this.wantList.wantSessionBlock(cid, provider, options2);
    this.log("%p %s %c", provider, result.has ? "has" : "does not have", cid);
    if (result.has && result.block != null) {
      return result.block;
    }
    throw new Error("Provider did not have block");
  }
  async *findNewProviders(cid, options2 = {}) {
    for await (const provider of this.network.findProviders(cid, options2)) {
      yield provider.id;
    }
  }
  toEvictionKey(provider) {
    return provider.toBytes();
  }
  equals(providerA, providerB) {
    return providerA.equals(providerB);
  }
};
function createBitswapSession(components, init) {
  return new BitswapSession(components, init);
}

// node_modules/@helia/bitswap/dist/src/stats.js
var Stats = class {
  blocksReceived;
  duplicateBlocksReceived;
  dataReceived;
  duplicateDataReceived;
  constructor(components) {
    this.blocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_received_blocks");
    this.duplicateBlocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_received_blocks");
    this.dataReceived = components.metrics?.registerMetricGroup("helia_bitswap_data_received_bytes");
    this.duplicateDataReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes");
  }
  updateBlocksReceived(count = 1, peerId2) {
    const stats = {
      global: count
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = count;
    }
    this.blocksReceived?.increment(stats);
  }
  updateDuplicateBlocksReceived(count = 1, peerId2) {
    const stats = {
      global: count
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = count;
    }
    this.duplicateBlocksReceived?.increment(stats);
  }
  updateDataReceived(bytes3, peerId2) {
    const stats = {
      global: bytes3
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = bytes3;
    }
    this.dataReceived?.increment(stats);
  }
  updateDuplicateDataReceived(bytes3, peerId2) {
    const stats = {
      global: bytes3
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = bytes3;
    }
    this.duplicateDataReceived?.increment(stats);
  }
};

// node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  metric;
  constructor(init) {
    super();
    const { name: name29, metrics } = init;
    this.metric = metrics.registerMetric(name29);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name29, metrics } = config;
  let map6;
  if (metrics != null) {
    map6 = new TrackedMap({ name: name29, metrics });
  } else {
    map6 = /* @__PURE__ */ new Map();
  }
  return map6;
}

// node_modules/@helia/bitswap/node_modules/p-defer/index.js
function pDefer4() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@helia/bitswap/node_modules/uint8arrays/dist/src/equals.js
function equals20(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@helia/bitswap/dist/src/utils/varint-decoder.js
function varintDecoder(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    throw new Error("arg needs to be a Uint8Array");
  }
  const result = [];
  while (buf3.length > 0) {
    const num = decode(buf3);
    result.push(num);
    buf3 = buf3.slice(encodingLength(num));
  }
  return result;
}
var varint_decoder_default = varintDecoder;

// node_modules/@helia/bitswap/dist/src/want-list.js
var WantList = class extends TypedEventEmitter {
  /**
   * Tracks what CIDs we've previously sent to which peers
   */
  peers;
  wants;
  network;
  log;
  sendMessagesDelay;
  sendMessagesTimeout;
  hashLoader;
  sendingMessages;
  constructor(components, init = {}) {
    super();
    setMaxListeners2(Infinity, this);
    this.peers = trackedPeerMap({
      name: "helia_bitswap_peers",
      metrics: components.metrics
    });
    this.wants = trackedMap({
      name: "helia_bitswap_wantlist",
      metrics: components.metrics
    });
    this.network = components.network;
    this.sendMessagesDelay = init.sendMessagesDelay ?? DEFAULT_MESSAGE_SEND_DELAY;
    this.log = components.logger.forComponent("helia:bitswap:wantlist");
    this.hashLoader = init.hashLoader;
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:connected", (evt) => {
      this.peerConnected(evt.detail).catch((err) => {
        this.log.error("error processing newly connected bitswap peer %p", evt.detail, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  async addEntry(cid, options2) {
    const cidStr = toString8(cid.multihash.bytes, "base64");
    let entry = this.wants.get(cidStr);
    if (entry == null) {
      entry = {
        cid,
        priority: options2.priority ?? 1,
        wantType: options2.wantType ?? WantType.WantBlock,
        cancel: false,
        sendDontHave: true
      };
      this.wants.set(cidStr, entry);
    }
    if (entry.wantType === WantType.WantHave && options2.wantType === WantType.WantBlock) {
      entry.wantType = WantType.WantBlock;
    }
    await this.sendMessagesDebounced();
    try {
      if (options2.wantType === WantType.WantBlock) {
        const event2 = await raceEvent(this, "block", options2?.signal, {
          filter: (event3) => {
            return equals20(cid.multihash.digest, event3.detail.cid.multihash.digest);
          },
          errorMessage: "Want was aborted"
        });
        return event2.detail;
      }
      const event = await raceEvent(this, "presence", options2?.signal, {
        filter: (event2) => {
          return equals20(cid.multihash.digest, event2.detail.cid.multihash.digest);
        },
        errorMessage: "Want was aborted"
      });
      return event.detail;
    } finally {
      if (options2.signal?.aborted === true) {
        this.log("want for %c was aborted, cancelling want", cid);
        entry.cancel = true;
        await this.sendMessagesDebounced();
      }
    }
  }
  async sendMessagesDebounced() {
    await this.sendingMessages?.promise;
    clearTimeout(this.sendMessagesTimeout);
    this.sendMessagesTimeout = setTimeout(() => {
      void this.sendMessages().catch((err) => {
        this.log("error sending messages to peers", err);
      });
    }, this.sendMessagesDelay);
  }
  async sendMessages() {
    this.sendingMessages = pDefer4();
    await Promise.all([...this.peers.entries()].map(async ([peerId2, sentWants]) => {
      const sent = /* @__PURE__ */ new Set();
      const message2 = new QueuedBitswapMessage();
      for (const [key, entry] of this.wants.entries()) {
        const sentPreviously = sentWants.has(key);
        if (sentPreviously || entry.cancel) {
          continue;
        }
        sent.add(key);
        message2.addWantlistEntry(entry.cid, {
          cid: entry.cid.bytes,
          priority: entry.priority,
          wantType: entry.wantType,
          cancel: entry.cancel,
          sendDontHave: entry.sendDontHave
        });
      }
      if (message2.wantlist.size === 0) {
        return;
      }
      try {
        await this.network.sendMessage(peerId2, message2);
        for (const key of sent) {
          sentWants.add(key);
        }
      } catch (err) {
        this.log.error("error sending full wantlist to new peer", err);
      }
    })).catch((err) => {
      this.log.error("error sending messages", err);
    });
    for (const [key, entry] of this.wants) {
      if (entry.cancel) {
        this.wants.delete(key);
        for (const sentWants of this.peers.values()) {
          sentWants.delete(key);
        }
      }
    }
    this.sendingMessages.resolve();
  }
  has(cid) {
    const cidStr = toString8(cid.multihash.bytes, "base64");
    return this.wants.has(cidStr);
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionPresence(cid, peerId2, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantHave,
      priority: 1
    });
    await this.network.sendMessage(peerId2, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId2.equals(event2.detail.sender) && equals20(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Add a CID to the wantlist
   */
  async wantBlock(cid, options2 = {}) {
    return this.addEntry(cid, {
      ...options2,
      wantType: WantType.WantBlock
    });
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionBlock(cid, peerId2, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantBlock,
      priority: 1
    });
    await this.network.sendMessage(peerId2, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId2.equals(event2.detail.sender) && equals20(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Invoked when a block has been received from an external source
   */
  async receivedBlock(cid, options2) {
    const cidStr = toString8(cid.multihash.bytes, "base64");
    const entry = this.wants.get(cidStr);
    if (entry == null) {
      return;
    }
    entry.cancel = true;
    await this.sendMessagesDebounced();
  }
  /**
   * Invoked when a message is received from a bitswap peer
   */
  async receiveMessage(sender, message2) {
    this.log("received message from %p with %d blocks", sender, message2.blocks.length);
    let blocksCancelled = false;
    for (const block of message2.blocks) {
      if (block.prefix == null || block.data == null) {
        continue;
      }
      const values = varint_decoder_default(block.prefix);
      const cidVersion = values[0];
      const multicodec2 = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha2566.code ? sha2566 : await this.hashLoader?.getHasher(hashAlg);
      if (hasher == null) {
        this.log.error("unknown hash algorithm", hashAlg);
        continue;
      }
      let hash2 = hasher.digest(block.data);
      if (hash2.then != null) {
        hash2 = await hash2;
      }
      const cid = CID5.create(cidVersion === 0 ? 0 : 1, multicodec2, hash2);
      this.log("received block from %p for %c", sender, cid);
      this.safeDispatchEvent("block", {
        detail: {
          sender,
          cid,
          block: block.data
        }
      });
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: true,
          block: block.data
        }
      });
      const cidStr = toString8(cid.multihash.bytes, "base64");
      const entry = this.wants.get(cidStr);
      if (entry == null) {
        continue;
      }
      entry.cancel = true;
      blocksCancelled = true;
    }
    for (const { cid: cidBytes, type } of message2.blockPresences) {
      const cid = CID5.decode(cidBytes);
      this.log("received %s from %p for %c", type, sender, cid);
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: type === BlockPresenceType.HaveBlock
        }
      });
    }
    if (blocksCancelled) {
      await this.sendMessagesDebounced();
    }
  }
  /**
   * Invoked when the network topology notices a new peer that supports Bitswap
   */
  async peerConnected(peerId2) {
    const sentWants = /* @__PURE__ */ new Set();
    const message2 = new QueuedBitswapMessage(true);
    for (const [key, entry] of this.wants.entries()) {
      if (entry.cancel) {
        continue;
      }
      sentWants.add(key);
      message2.addWantlistEntry(entry.cid, {
        cid: entry.cid.bytes,
        priority: 1,
        wantType: WantType.WantBlock,
        cancel: false,
        sendDontHave: false
      });
    }
    if (message2.wantlist.size === 0) {
      this.peers.set(peerId2, sentWants);
      return;
    }
    try {
      await this.network.sendMessage(peerId2, message2);
      this.peers.set(peerId2, sentWants);
    } catch (err) {
      this.log.error("error sending full wantlist to new peer %p", peerId2, err);
    }
  }
  /**
   * Invoked when the network topology notices peer that supports Bitswap has
   * disconnected
   */
  peerDisconnected(peerId2) {
    this.peers.delete(peerId2);
  }
  start() {
  }
  stop() {
    this.peers.clear();
    clearTimeout(this.sendMessagesTimeout);
  }
};

// node_modules/@helia/bitswap/dist/src/bitswap.js
var Bitswap = class {
  log;
  logger;
  stats;
  network;
  blockstore;
  peerWantLists;
  wantList;
  constructor(components, init = {}) {
    this.logger = components.logger;
    this.log = components.logger.forComponent("helia:bitswap");
    this.blockstore = components.blockstore;
    this.stats = new Stats(components);
    this.network = new Network(components, init);
    this.peerWantLists = new PeerWantLists({
      ...components,
      network: this.network
    }, init);
    this.wantList = new WantList({
      ...components,
      network: this.network
    }, init);
  }
  createSession(options2 = {}) {
    return createBitswapSession({
      wantList: this.wantList,
      network: this.network,
      logger: this.logger
    }, options2);
  }
  async want(cid, options2 = {}) {
    const controller = new AbortController();
    const signal = anySignal([controller.signal, options2.signal]);
    setMaxListeners2(Infinity, controller.signal, signal);
    this.network.findAndConnect(cid, {
      ...options2,
      signal
    }).catch((err) => {
      if (!controller.signal.aborted) {
        this.log.error("error during finding and connect for cid %c", cid, err);
      }
    });
    try {
      const result = await this.wantList.wantBlock(cid, {
        ...options2,
        signal
      });
      return result.block;
    } finally {
      controller.abort();
      signal.clear();
    }
  }
  /**
   * Sends notifications about the arrival of a block
   */
  async notify(cid, block, options2 = {}) {
    await Promise.all([
      this.peerWantLists.receivedBlock(cid, options2),
      this.wantList.receivedBlock(cid, options2)
    ]);
  }
  getWantlist() {
    return [...this.wantList.wants.values()].filter((entry) => !entry.cancel).map((entry) => ({
      cid: entry.cid,
      priority: entry.priority,
      wantType: entry.wantType
    }));
  }
  getPeerWantlist(peer) {
    return this.peerWantLists.wantListForPeer(peer);
  }
  /**
   * Start the bitswap node
   */
  async start() {
    this.wantList.start();
    await this.network.start();
  }
  /**
   * Stop the bitswap node
   */
  async stop() {
    this.wantList.stop();
    await this.network.stop();
  }
};

// node_modules/@helia/bitswap/dist/src/index.js
var createBitswap = (components, options2 = {}) => {
  return new Bitswap(components, options2);
};

// node_modules/@helia/block-brokers/dist/src/bitswap.js
var BitswapBlockBroker = class {
  bitswap;
  started;
  constructor(components, init = {}) {
    const { hashers } = components;
    this.bitswap = createBitswap(components, {
      hashLoader: {
        getHasher: async (codecOrName) => {
          let hasher;
          if (typeof codecOrName === "string") {
            hasher = Object.values(hashers).find((hasher2) => {
              return hasher2.name === codecOrName;
            });
          } else {
            hasher = hashers[codecOrName];
          }
          if (hasher != null) {
            return hasher;
          }
          throw new Error(`Could not load hasher for code/name "${codecOrName}"`);
        }
      },
      ...init
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await this.bitswap.start();
    this.started = true;
  }
  async stop() {
    await this.bitswap.stop();
    this.started = false;
  }
  async announce(cid, block, options2) {
    await this.bitswap.notify(cid, block, options2);
  }
  async retrieve(cid, options2 = {}) {
    return this.bitswap.want(cid, options2);
  }
  createSession(options2) {
    const session = this.bitswap.createSession(options2);
    return {
      announce: async (cid, block, options3) => {
        await this.bitswap.notify(cid, block, options3);
      },
      retrieve: async (cid, options3) => {
        return session.retrieve(cid, options3);
      }
    };
  }
};
function bitswap(init = {}) {
  return (components) => new BitswapBlockBroker(components, init);
}

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  index = 0;
  input = "";
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}

// node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask = __toESM(require_netmask(), 1);
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r of NETMASK_RANGES) {
    if (r.contains(ipAddr))
      return true;
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip))
    return ipv4Check(ip);
  else if (isIpv4MappedIpv6(ip))
    return ipv4MappedIpv6Check(ip);
  else if (isIpv4EmbeddedIpv6(ip))
    return ipv4EmbeddedIpv6Check(ip);
  else if (isIPv6(ip))
    return ipv6Check(ip);
  else
    return void 0;
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports8 = {};
__export(base58_exports8, {
  base58btc: () => base58btc9,
  base58flickr: () => base58flickr9
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js
var empty9 = new Uint8Array(0);
function equals21(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce9(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString14(str) {
  return new TextEncoder().encode(str);
}
function toString14(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js
function base12(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src9 = base12;
var _brrp__multiformats_scope_baseX9 = src9;
var base_x_default9 = _brrp__multiformats_scope_baseX9;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js
var Encoder9 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder9 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or9(this, decoder);
  }
};
var ComposedDecoder9 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or9(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or9(left, right) {
  return new ComposedDecoder9({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec9 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder9(name29, prefix, baseEncode);
    this.decoder = new Decoder9(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from16({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec9(name29, prefix, encode116, decode144);
}
function baseX9({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default9(alphabet27, name29);
  return from16({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce9(decode144(text))
  });
}
function decode42(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode34(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46489({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from16({
    prefix,
    name: name29,
    encode(input) {
      return encode34(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode42(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js
var base58btc9 = baseX9({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr9 = baseX9({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports8 = {};
__export(base32_exports8, {
  base32: () => base329,
  base32hex: () => base32hex9,
  base32hexpad: () => base32hexpad9,
  base32hexpadupper: () => base32hexpadupper9,
  base32hexupper: () => base32hexupper9,
  base32pad: () => base32pad9,
  base32padupper: () => base32padupper9,
  base32upper: () => base32upper9,
  base32z: () => base32z9
});
var base329 = rfc46489({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper9 = rfc46489({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad9 = rfc46489({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper9 = rfc46489({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex9 = rfc46489({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper9 = rfc46489({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad9 = rfc46489({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper9 = rfc46489({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z9 = rfc46489({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js
var encode_18 = encode35;
var MSB9 = 128;
var REST9 = 127;
var MSBALL8 = ~REST9;
var INT8 = Math.pow(2, 31);
function encode35(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT8) {
    out[offset++] = num & 255 | MSB9;
    num /= 128;
  }
  while (num & MSBALL8) {
    out[offset++] = num & 255 | MSB9;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode35.bytes = offset - oldOffset + 1;
  return out;
}
var decode43 = read9;
var MSB$18 = 128;
var REST$18 = 127;
function read9(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$18);
  read9.bytes = counter - offset;
  return res;
}
var N19 = Math.pow(2, 7);
var N29 = Math.pow(2, 14);
var N39 = Math.pow(2, 21);
var N49 = Math.pow(2, 28);
var N59 = Math.pow(2, 35);
var N69 = Math.pow(2, 42);
var N79 = Math.pow(2, 49);
var N88 = Math.pow(2, 56);
var N98 = Math.pow(2, 63);
var length9 = function(value) {
  return value < N19 ? 1 : value < N29 ? 2 : value < N39 ? 3 : value < N49 ? 4 : value < N59 ? 5 : value < N69 ? 6 : value < N79 ? 7 : value < N88 ? 8 : value < N98 ? 9 : 10;
};
var varint8 = {
  encode: encode_18,
  decode: decode43,
  encodingLength: length9
};
var _brrp_varint8 = varint8;
var varint_default8 = _brrp_varint8;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js
function decode44(data, offset = 0) {
  const code33 = varint_default8.decode(data, offset);
  return [code33, varint_default8.decode.bytes];
}
function encodeTo8(int, target, offset = 0) {
  varint_default8.encode(int, target, offset);
  return target;
}
function encodingLength9(int) {
  return varint_default8.encodingLength(int);
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js
function create10(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength9(code33);
  const digestOffset = sizeOffset + encodingLength9(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo8(code33, bytes3, 0);
  encodeTo8(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest8(code33, size, digest27, bytes3);
}
function decode45(multihash) {
  const bytes3 = coerce9(multihash);
  const [code33, sizeOffset] = decode44(bytes3);
  const [size, digestOffset] = decode44(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest8(code33, size, digest27, bytes3);
}
function equals22(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals21(a.bytes, data.bytes);
  }
}
var Digest8 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js
function format8(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV08(bytes3, baseCache8(link), base45 ?? base58btc9.encoder);
    default:
      return toStringV18(bytes3, baseCache8(link), base45 ?? base329.encoder);
  }
}
var cache9 = /* @__PURE__ */ new WeakMap();
function baseCache8(cid) {
  const baseCache28 = cache9.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache9.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID8 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create10(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals22(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format8(this, base45);
  }
  toJSON() {
    return { "/": format8(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID8(version3, code33, multihash.bytes));
    } else if (value[cidSymbol8] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode45(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE8) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID8(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE8, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce9(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest8(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode44(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE8;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes8(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache8(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes8(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc9;
      return [
        base58btc9.prefix,
        decoder.decode(`${base58btc9.prefix}${source}`)
      ];
    }
    case base58btc9.prefix: {
      const decoder = base45 ?? base58btc9;
      return [base58btc9.prefix, decoder.decode(source)];
    }
    case base329.prefix: {
      const decoder = base45 ?? base329;
      return [base329.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV08(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc9.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV18(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE8 = 112;
var SHA_256_CODE8 = 18;
function encodeCID8(version3, code33, multihash) {
  const codeOffset = encodingLength9(version3);
  const hashOffset = codeOffset + encodingLength9(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo8(version3, bytes3, 0);
  encodeTo8(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js
function equals23(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports8 = {};
__export(base10_exports8, {
  base10: () => base108
});
var base108 = baseX9({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports8 = {};
__export(base16_exports8, {
  base16: () => base168,
  base16upper: () => base16upper8
});
var base168 = rfc46489({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper8 = rfc46489({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports8 = {};
__export(base2_exports8, {
  base2: () => base28
});
var base28 = rfc46489({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports8 = {};
__export(base256emoji_exports8, {
  base256emoji: () => base256emoji8
});
var alphabet8 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars8 = alphabet8.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes8 = alphabet8.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode36(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars8[c];
    return p;
  }, "");
}
function decode46(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes8[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji8 = from16({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode36,
  decode: decode46
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports8 = {};
__export(base36_exports8, {
  base36: () => base368,
  base36upper: () => base36upper8
});
var base368 = baseX9({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper8 = baseX9({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports8 = {};
__export(base64_exports8, {
  base64: () => base649,
  base64pad: () => base64pad9,
  base64url: () => base64url9,
  base64urlpad: () => base64urlpad9
});
var base649 = rfc46489({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad9 = rfc46489({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url9 = rfc46489({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad9 = rfc46489({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports8 = {};
__export(base8_exports8, {
  base8: () => base88
});
var base88 = rfc46489({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports15 = {};
__export(identity_exports15, {
  identity: () => identity15
});
var identity15 = from16({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString14(buf3),
  decode: (str) => fromString14(str)
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder11 = new TextEncoder();
var textDecoder10 = new TextDecoder();

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports16 = {};
__export(identity_exports16, {
  identity: () => identity16
});
var code13 = 0;
var name8 = "identity";
var encode37 = coerce9;
function digest8(input) {
  return create10(code13, encode37(input));
}
var identity16 = { code: code13, name: name8, encode: encode37, digest: digest8 };

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports8 = {};
__export(sha2_browser_exports8, {
  sha256: () => sha2569,
  sha512: () => sha5129
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js
function from17({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher8(name29, code33, encode116);
}
var Hasher8 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create10(this.code, result) : result.then((digest27) => create10(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha8(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha2569 = from17({
  name: "sha2-256",
  code: 18,
  encode: sha8("SHA-256")
});
var sha5129 = from17({
  name: "sha2-512",
  code: 19,
  encode: sha8("SHA-512")
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js
var bases8 = { ...identity_exports15, ...base2_exports8, ...base8_exports8, ...base10_exports8, ...base16_exports8, ...base32_exports8, ...base36_exports8, ...base58_exports8, ...base64_exports8, ...base256emoji_exports8 };
var hashes8 = { ...sha2_browser_exports8, ...identity_exports16 };

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe11(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec9(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string8 = createCodec9("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii8 = createCodec9("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe11(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES8 = {
  utf8: string8,
  "utf-8": string8,
  hex: bases8.base16,
  latin1: ascii8,
  ascii: ascii8,
  binary: ascii8,
  ...bases8
};
var bases_default8 = BASES8;

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js
function toString15(array, encoding = "utf8") {
  const base45 = bases_default8[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array3(buf3) {
  return buf3;
}

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js
function concat5(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe11(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array3(output3);
}

// node_modules/@chainsafe/netmask/dist/src/ip.js
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);

// node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js
function fromString15(string27, encoding = "utf8") {
  const base45 = bases_default8[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes2 = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes3 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes3[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes3;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes2(sections[i]);
        sections[i] = toString15(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString15(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes3 = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word2 = parseInt(sections[i], 16);
      bytes3[offset++] = word2 >> 8 & 255;
      bytes3[offset++] = word2 & 255;
    }
    return bytes3;
  }
  throw new Error("invalid ip address");
};
var toString16 = function(buf3, offset = 0, length30) {
  offset = ~~offset;
  length30 = length30 ?? buf3.length - offset;
  const view = new DataView(buf3.buffer);
  if (length30 === 4) {
    const result = [];
    for (let i = 0; i < length30; i++) {
      result.push(buf3[offset + i]);
    }
    return result.join(".");
  }
  if (length30 === 16) {
    const result = [];
    for (let i = 0; i < length30; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V = -1;
var names2 = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc-direct"],
  [281, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [481, V, "http-path"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names2[proto.name] = proto;
});
function createProtocol(code33, size, name29, resolvable, path) {
  return {
    code: code33,
    size,
    name: name29,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names2[proto] != null) {
      return names2[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/@multiformats/multiaddr/dist/src/convert.js
var ip4Protocol = getProtocol("ip4");
var ip6Protocol = getProtocol("ip6");
var ipcidrProtocol = getProtocol("ipcidr");
function convertToString(proto, buf3) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    // ipv4
    case 41:
      return bytes2ip(buf3);
    case 42:
      return bytes2str(buf3);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return bytes2port(buf3).toString();
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return bytes2str(buf3);
    case 421:
      return bytes2mh(buf3);
    case 444:
      return bytes2onion(buf3);
    case 445:
      return bytes2onion(buf3);
    case 466:
      return bytes2mb(buf3);
    case 481:
      return globalThis.encodeURIComponent(bytes2str(buf3));
    default:
      return toString15(buf3, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    case 481:
      return str2bytes(globalThis.decodeURIComponent(str));
    default:
      return fromString15(str, "base16");
  }
}
var decoders = Object.values(bases8).map((c) => c.decoder);
var anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes2(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString16(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf3 = new ArrayBuffer(2);
  const view = new DataView(buf3);
  view.setUint16(0, port);
  return new Uint8Array(buf3);
}
function bytes2port(buf3) {
  const view = new DataView(buf3.buffer);
  return view.getUint16(buf3.byteOffset);
}
function str2bytes(str) {
  const buf3 = fromString15(str);
  const size = Uint8Array.from(encode(buf3.length));
  return concat5([size, buf3], size.length + buf3.length);
}
function bytes2str(buf3) {
  const size = decode(buf3);
  buf3 = buf3.slice(encodingLength(size));
  if (buf3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString15(buf3);
}
function mh2bytes(hash2) {
  let mh;
  if (hash2[0] === "Q" || hash2[0] === "1") {
    mh = decode45(base58btc9.decode(`z${hash2}`)).bytes;
  } else {
    mh = CID8.parse(hash2).multihash.bytes;
  }
  const size = Uint8Array.from(encode(mh.length));
  return concat5([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(encode(mb.length));
  return concat5([size, mb], size.length + mb.length);
}
function bytes2mb(buf3) {
  const size = decode(buf3);
  const hash2 = buf3.slice(encodingLength(size));
  if (hash2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString15(hash2, "base64url");
}
function bytes2mh(buf3) {
  const size = decode(buf3);
  const address = buf3.slice(encodingLength(size));
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString15(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf3 = base329.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat5([buf3, portBuf], buf3.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf3 = base329.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat5([buf3, portBuf], buf3.length + portBuf.length);
}
function bytes2onion(buf3) {
  const addrBytes = buf3.slice(0, buf3.length - 2);
  const portBytes = buf3.slice(buf3.length - 2);
  const addr = toString15(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// node_modules/@multiformats/multiaddr/dist/src/codec.js
function stringToMultiaddrParts(str) {
  str = cleanPath(str);
  const tuples = [];
  const stringTuples = [];
  let path = null;
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return {
      bytes: new Uint8Array(),
      string: "/",
      tuples: [],
      stringTuples: [],
      path: null
    };
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([proto.code]);
      stringTuples.push([proto.code]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      path = cleanPath(parts.slice(p).join("/"));
      tuples.push([proto.code, convertToBytes(proto.code, path)]);
      stringTuples.push([proto.code, path]);
      break;
    }
    const bytes3 = convertToBytes(proto.code, parts[p]);
    tuples.push([proto.code, bytes3]);
    stringTuples.push([proto.code, convertToString(proto.code, bytes3)]);
  }
  return {
    string: stringTuplesToString(stringTuples),
    bytes: tuplesToBytes(tuples),
    tuples,
    stringTuples,
    path
  };
}
function bytesToMultiaddrParts(bytes3) {
  const tuples = [];
  const stringTuples = [];
  let path = null;
  let i = 0;
  while (i < bytes3.length) {
    const code33 = decode(bytes3, i);
    const n = encodingLength(code33);
    const p = getProtocol(code33);
    const size = sizeForAddr(p, bytes3.slice(i + n));
    if (size === 0) {
      tuples.push([code33]);
      stringTuples.push([code33]);
      i += n;
      continue;
    }
    const addr = bytes3.slice(i + n, i + n + size);
    i += size + n;
    if (i > bytes3.length) {
      throw ParseError("Invalid address Uint8Array: " + toString15(bytes3, "base16"));
    }
    tuples.push([code33, addr]);
    const stringAddr = convertToString(code33, addr);
    stringTuples.push([code33, stringAddr]);
    if (p.path === true) {
      path = stringAddr;
      break;
    }
  }
  return {
    bytes: Uint8Array.from(bytes3),
    string: stringTuplesToString(stringTuples),
    tuples,
    stringTuples,
    path
  };
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function tuplesToBytes(tuples) {
  return concat5(tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    let buf3 = Uint8Array.from(encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf3 = concat5([buf3, tup[1]]);
    }
    return buf3;
  }));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
    return size + encodingLength(size);
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}

// node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var symbol2 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var Multiaddr = class _Multiaddr {
  bytes;
  #string;
  #tuples;
  #stringTuples;
  #path;
  [symbol2] = true;
  constructor(addr) {
    if (addr == null) {
      addr = "";
    }
    let parts;
    if (addr instanceof Uint8Array) {
      parts = bytesToMultiaddrParts(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      parts = stringToMultiaddrParts(addr);
    } else if (isMultiaddr(addr)) {
      parts = bytesToMultiaddrParts(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
    this.bytes = parts.bytes;
    this.#string = parts.string;
    this.#tuples = parts.tuples;
    this.#stringTuples = parts.stringTuples;
    this.#path = parts.path;
  }
  toString() {
    return this.#string;
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code33, value] of this.stringTuples()) {
      if (code33 === ip6zone.code) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code33)) {
        transport = tcp.name;
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code33 === dns6.code ? 6 : 4;
      }
      if (code33 === tcp.code || code33 === udp.code) {
        transport = getProtocol(code33).name;
        port = parseInt(value ?? "");
      }
      if (code33 === ip4.code || code33 === ip6.code) {
        transport = getProtocol(code33).name;
        host = `${value ?? ""}${zone}`;
        family = code33 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.#tuples.map(([code33]) => Object.assign({}, getProtocol(code33)));
  }
  protoCodes() {
    return this.#tuples.map(([code33]) => code33);
  }
  protoNames() {
    return this.#tuples.map(([code33]) => getProtocol(code33).name);
  }
  tuples() {
    return this.#tuples;
  }
  stringTuples() {
    return this.#stringTuples;
  }
  encapsulate(addr) {
    addr = new _Multiaddr(addr);
    return new _Multiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i = s2.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s2.slice(0, i));
  }
  decapsulateCode(code33) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code33) {
        return new _Multiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      let tuples = [];
      this.stringTuples().forEach(([code33, name29]) => {
        if (code33 === names2.p2p.code) {
          tuples.push([code33, name29]);
        }
        if (code33 === names2["p2p-circuit"].code) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString15(base58btc9.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString15(CID8.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    return this.#path;
  }
  equals(addr) {
    return equals23(this.bytes, addr.bytes);
  }
  async resolve(options2) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw new CodeError(`no available resolver for ${resolvableProto.name}`, "ERR_NO_AVAILABLE_RESOLVER");
    }
    const result = await resolver(this, options2);
    return result.map((str) => multiaddr(str));
  }
  nodeAddress() {
    const options2 = this.toOptions();
    if (options2.transport !== "tcp" && options2.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options2.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options2.family,
      address: options2.host,
      port: options2.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [inspect2]() {
    return `Multiaddr(${this.#string})`;
  }
};

// node_modules/@multiformats/multiaddr/dist/src/index.js
var resolvers = /* @__PURE__ */ new Map();
function isMultiaddr(value) {
  return Boolean(value?.[symbol2]);
}
function multiaddr(addr) {
  return new Multiaddr(addr);
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bytes.js
var empty10 = new Uint8Array(0);
function coerce10(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/vendor/base-x.js
function base13(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src10 = base13;
var _brrp__multiformats_scope_baseX10 = src10;
var base_x_default10 = _brrp__multiformats_scope_baseX10;

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base.js
var Encoder10 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder10 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or10(this, decoder);
  }
};
var ComposedDecoder10 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or10(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or10(left, right) {
  return new ComposedDecoder10({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec10 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder10(name29, prefix, baseEncode);
    this.decoder = new Decoder10(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from18({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec10(name29, prefix, encode116, decode144);
}
function baseX10({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default10(alphabet27, name29);
  return from18({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce10(decode144(text))
  });
}
function decode47(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode38(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464810({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from18({
    prefix,
    name: name29,
    encode(input) {
      return encode38(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode47(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base58.js
var base58btc10 = baseX10({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr10 = baseX10({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base64.js
var base6410 = rfc464810({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad10 = rfc464810({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url10 = rfc464810({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad10 = rfc464810({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
var func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
var literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
var string9 = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
var number2 = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
var peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc10.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
var certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url10.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
var or11 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matches,
    exactMatch
  };
}
var _DNS4 = and(literal("dns4"), string9());
var _DNS6 = and(literal("dns6"), string9());
var _DNSADDR = and(literal("dnsaddr"), string9());
var _DNS = and(literal("dns"), string9());
var DNS4 = fmt(_DNS4);
var DNS6 = fmt(_DNS6);
var DNSADDR = fmt(_DNSADDR);
var DNS2 = fmt(or11(_DNS, _DNSADDR, _DNS4, _DNS6));
var _IP4 = and(literal("ip4"), func(isIPv4));
var _IP6 = and(literal("ip6"), func(isIPv6));
var _IP = or11(_IP4, _IP6);
var _IP_OR_DOMAIN = or11(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN);
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number2());
var _UDP = and(_IP_OR_DOMAIN, literal("udp"), number2());
var TCP = fmt(_TCP);
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, literal("quic"));
var _QUICV1 = and(_UDP, literal("quic-v1"));
var QUIC_V0_OR_V1 = or11(_QUIC, _QUICV1);
var QUIC = fmt(_QUIC);
var QUICV1 = fmt(_QUICV1);
var _WEB = or11(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
var _WebSockets = or11(and(_WEB, literal("ws"), optional(peerId())));
var WebSockets = fmt(_WebSockets);
var _WebSocketsSecure = or11(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), literal("ws"), optional(peerId())));
var WebSocketsSecure = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebTransport = fmt(_WebTransport);
var _P2P = or11(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
var P2P = fmt(_P2P);
var _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
var Circuit = fmt(_Circuit);
var _WebRTC = or11(and(_P2P, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and(_P2P, literal("webrtc"), optional(peerId())), literal("webrtc"));
var WebRTC = fmt(_WebRTC);
var _HTTP = or11(and(_IP_OR_DOMAIN, literal("tcp"), number2(), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
var HTTP = fmt(_HTTP);
var _HTTPS = or11(and(_IP_OR_DOMAIN, literal("tcp"), or11(and(literal("443"), literal("http")), and(number2(), literal("https"))), optional(peerId())), and(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
var HTTPS = fmt(_HTTPS);

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  getProtocol("tcp").code,
  getProtocol("dns").code,
  getProtocol("dnsaddr").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code
];
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = getProtocol("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value] of ma) {
    if (proto === sniProtoCode && value !== void 0) {
      return value;
    }
  }
  return null;
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === getProtocol("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[getProtocol(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === getProtocol("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    const decodedValue = decodeURIComponent(value);
    return `${baseVal}/${decodedValue}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = getProtocol(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head[0])) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head[1] === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bytes.js
var empty11 = new Uint8Array(0);

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bases/base.js
var Encoder11 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder11 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or12(this, decoder);
  }
};
var ComposedDecoder11 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or12(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or12(left, right) {
  return new ComposedDecoder11({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec11 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder11(name29, prefix, baseEncode);
    this.decoder = new Decoder11(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from19({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec11(name29, prefix, encode116, decode144);
}
function decode48(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode39(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464811({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from19({
    prefix,
    name: name29,
    encode(input) {
      return encode39(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode48(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bases/base64.js
var base6411 = rfc464811({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad11 = rfc464811({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url11 = rfc464811({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad11 = rfc464811({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js
var TrustlessGateway = class {
  url;
  /**
   * The number of times this gateway has been attempted to be used to fetch a
   * block. This includes successful, errored, and aborted attempts. By counting
   * even aborted attempts, slow gateways that are out-raced by others will be
   * considered less reliable.
   */
  #attempts = 0;
  /**
   * The number of times this gateway has errored while attempting to fetch a
   * block. This includes `response.ok === false` and any other errors that
   * throw while attempting to fetch a block. This does not include aborted
   * attempts.
   */
  #errors = 0;
  /**
   * The number of times this gateway has returned an invalid block. A gateway
   * that returns the wrong blocks for a CID should be considered for removal
   * from the list of gateways to fetch blocks from.
   */
  #invalidBlocks = 0;
  /**
   * The number of times this gateway has successfully fetched a block.
   */
  #successes = 0;
  /**
   * A map of pending responses for this gateway. This is used to ensure that
   * only one request per CID is made to a given gateway at a time, and that we
   * don't make multiple in-flight requests for the same CID to the same gateway.
   */
  #pendingResponses = /* @__PURE__ */ new Map();
  log;
  constructor(url, logger2) {
    this.url = url instanceof URL ? url : new URL(url);
    this.log = logger2.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`);
  }
  /**
   * This function returns a unique string for the multihash.bytes of the CID.
   *
   * Some useful resources for why this is needed can be found using the links below:
   *
   * - https://github.com/ipfs/helia/pull/503#discussion_r1572451331
   * - https://github.com/ipfs/kubo/issues/6815
   * - https://www.notion.so/pl-strflt/Handling-ambiguity-around-CIDs-9d5e14f6516f438980b01ef188efe15d#d9d45cd1ed8b4d349b96285de4aed5ab
   */
  #uniqueBlockId(cid) {
    const multihashBytes = cid.multihash.bytes;
    return base6411.encode(multihashBytes);
  }
  /**
   * Fetch a raw block from `this.url` following the specification defined at
   * https://specs.ipfs.tech/http-gateways/trustless-gateway/
   */
  async getRawBlock(cid, signal) {
    const gwUrl = new URL(this.url.toString());
    gwUrl.pathname = `/ipfs/${cid.toString()}`;
    gwUrl.search = "?format=raw";
    if (signal?.aborted === true) {
      throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);
    }
    const blockId = this.#uniqueBlockId(cid);
    const innerController = new AbortController();
    const abortInnerSignal = () => {
      innerController.abort();
    };
    signal?.addEventListener("abort", abortInnerSignal);
    try {
      let pendingResponse = this.#pendingResponses.get(blockId);
      if (pendingResponse == null) {
        this.#attempts++;
        pendingResponse = fetch(gwUrl.toString(), {
          signal: innerController.signal,
          headers: {
            Accept: "application/vnd.ipld.raw"
          },
          cache: "force-cache"
        }).then(async (res) => {
          this.log("GET %s %d", gwUrl, res.status);
          if (!res.ok) {
            this.#errors++;
            throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);
          }
          this.#successes++;
          return new Uint8Array(await res.arrayBuffer());
        });
        this.#pendingResponses.set(blockId, pendingResponse);
      }
      return await pendingResponse;
    } catch (cause) {
      if (signal?.aborted === true) {
        throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);
      }
      this.#errors++;
      throw new Error(`unable to fetch raw block for CID ${cid}`);
    } finally {
      signal?.removeEventListener("abort", abortInnerSignal);
      this.#pendingResponses.delete(blockId);
    }
  }
  /**
   * Encapsulate the logic for determining whether a gateway is considered
   * reliable, for prioritization. This is based on the number of successful attempts made
   * and the number of errors encountered.
   *
   * Unused gateways have 100% reliability; They will be prioritized over
   * gateways with a 100% success rate to ensure that we attempt all gateways.
   */
  reliability() {
    if (this.#attempts === 0) {
      return 1;
    }
    if (this.#invalidBlocks > 0) {
      return -Infinity;
    }
    return this.#successes / (this.#attempts + this.#errors * 3);
  }
  /**
   * Increment the number of invalid blocks returned by this gateway.
   */
  incrementInvalidBlocks() {
    this.#invalidBlocks++;
  }
  getStats() {
    return {
      attempts: this.#attempts,
      errors: this.#errors,
      invalidBlocks: this.#invalidBlocks,
      successes: this.#successes,
      pendingResponses: this.#pendingResponses.size
    };
  }
};

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/utils.js
function filterNonHTTPMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
  return multiaddrs.filter((ma) => {
    if (HTTPS.matches(ma) || allowInsecure && HTTP.matches(ma)) {
      if (allowLocal) {
        return true;
      }
      if (DNS2.matches(ma)) {
        return true;
      }
      return isPrivateIp(ma.toOptions().host) === false;
    }
    return false;
  });
}
async function* findHttpGatewayProviders(cid, routing, logger2, allowInsecure, allowLocal, options2) {
  for await (const provider of routing.findProviders(cid, options2)) {
    const httpAddresses = filterNonHTTPMultiaddrs(provider.multiaddrs, allowInsecure, allowLocal);
    if (httpAddresses.length === 0) {
      continue;
    }
    const uri = multiaddrToUri(httpAddresses[0]);
    yield new TrustlessGateway(uri, logger2);
  }
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/session.js
var TrustlessGatewaySession = class extends AbstractSession {
  routing;
  allowInsecure;
  allowLocal;
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:trustless-gateway:session"
    });
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
  }
  async queryProvider(cid, provider, options2) {
    this.log("fetching BLOCK for %c from %s", cid, provider.url);
    const block = await provider.getRawBlock(cid, options2.signal);
    this.log.trace("got block for %c from %s", cid, provider.url);
    await options2.validateFn?.(block);
    return block;
  }
  async *findNewProviders(cid, options2 = {}) {
    yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, options2);
  }
  toEvictionKey(provider) {
    return provider.url.toString();
  }
  equals(providerA, providerB) {
    return providerA.url.toString() === providerB.url.toString();
  }
};
function createTrustlessGatewaySession(components, init) {
  return new TrustlessGatewaySession(components, init);
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js
var TrustlessGatewayBlockBroker = class {
  allowInsecure;
  allowLocal;
  routing;
  log;
  logger;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("helia:trustless-gateway-block-broker");
    this.logger = components.logger;
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
  }
  async retrieve(cid, options2 = {}) {
    const aggregateErrors = [];
    for await (const gateway of findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, options2)) {
      this.log("getting block for %c from %s", cid, gateway.url);
      try {
        const block = await gateway.getRawBlock(cid, options2.signal);
        this.log.trace("got block for %c from %s", cid, gateway.url);
        try {
          await options2.validateFn?.(block);
        } catch (err) {
          this.log.error("failed to validate block for %c from %s", cid, gateway.url, err);
          continue;
        }
        return block;
      } catch (err) {
        this.log.error("failed to get block for %c from %s", cid, gateway.url, err);
        if (err instanceof Error) {
          aggregateErrors.push(err);
        } else {
          aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
        }
        if (options2.signal?.aborted === true) {
          this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", cid, gateway.url);
          break;
        }
      }
    }
    if (aggregateErrors.length > 0) {
      throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
    } else {
      throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
    }
  }
  createSession(options2 = {}) {
    return createTrustlessGatewaySession({
      logger: this.logger,
      routing: this.routing
    }, {
      ...options2,
      allowLocal: this.allowLocal,
      allowInsecure: this.allowInsecure
    });
  }
};

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js
var DEFAULT_ALLOW_INSECURE = false;
var DEFAULT_ALLOW_LOCAL = false;
function trustlessGateway(init = {}) {
  return (components) => new TrustlessGatewayBlockBroker(components, init);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/any-signal/dist/src/index.js
function anySignal3(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options2 = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options2.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// node_modules/ipns/dist/src/index.js
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports9 = {};
__export(base10_exports9, {
  base10: () => base109
});

// node_modules/ipns/node_modules/multiformats/dist/src/bytes.js
var empty12 = new Uint8Array(0);
function equals24(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce12(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString16(str) {
  return new TextEncoder().encode(str);
}
function toString17(b) {
  return new TextDecoder().decode(b);
}

// node_modules/ipns/node_modules/multiformats/dist/src/vendor/base-x.js
function base14(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src11 = base14;
var _brrp__multiformats_scope_baseX11 = src11;
var base_x_default12 = _brrp__multiformats_scope_baseX11;

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base.js
var Encoder12 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder12 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or13(this, decoder);
  }
};
var ComposedDecoder12 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or13(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or13(left, right) {
  return new ComposedDecoder12({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec12 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder12(name29, prefix, baseEncode);
    this.decoder = new Decoder12(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from20({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec12(name29, prefix, encode116, decode144);
}
function baseX11({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default12(alphabet27, name29);
  return from20({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce12(decode144(text))
  });
}
function decode49(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode40(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464812({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from20({
    prefix,
    name: name29,
    encode(input) {
      return encode40(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode49(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base10.js
var base109 = baseX11({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports9 = {};
__export(base16_exports9, {
  base16: () => base169,
  base16upper: () => base16upper9
});
var base169 = rfc464812({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper9 = rfc464812({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports9 = {};
__export(base2_exports9, {
  base2: () => base29
});
var base29 = rfc464812({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports9 = {};
__export(base256emoji_exports9, {
  base256emoji: () => base256emoji9
});
var alphabet9 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars9 = alphabet9.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes9 = alphabet9.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode41(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars9[c];
    return p;
  }, "");
}
function decode50(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes9[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji9 = from20({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode41,
  decode: decode50
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports9 = {};
__export(base32_exports9, {
  base32: () => base3210,
  base32hex: () => base32hex10,
  base32hexpad: () => base32hexpad10,
  base32hexpadupper: () => base32hexpadupper10,
  base32hexupper: () => base32hexupper10,
  base32pad: () => base32pad10,
  base32padupper: () => base32padupper10,
  base32upper: () => base32upper10,
  base32z: () => base32z10
});
var base3210 = rfc464812({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper10 = rfc464812({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad10 = rfc464812({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper10 = rfc464812({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex10 = rfc464812({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper10 = rfc464812({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad10 = rfc464812({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper10 = rfc464812({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z10 = rfc464812({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports9 = {};
__export(base36_exports9, {
  base36: () => base369,
  base36upper: () => base36upper9
});
var base369 = baseX11({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper9 = baseX11({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports9 = {};
__export(base58_exports9, {
  base58btc: () => base58btc11,
  base58flickr: () => base58flickr11
});
var base58btc11 = baseX11({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr11 = baseX11({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports9 = {};
__export(base64_exports9, {
  base64: () => base6412,
  base64pad: () => base64pad12,
  base64url: () => base64url12,
  base64urlpad: () => base64urlpad12
});
var base6412 = rfc464812({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad12 = rfc464812({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url12 = rfc464812({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad12 = rfc464812({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports9 = {};
__export(base8_exports9, {
  base8: () => base89
});
var base89 = rfc464812({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports17 = {};
__export(identity_exports17, {
  identity: () => identity17
});
var identity17 = from20({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString17(buf3),
  decode: (str) => fromString16(str)
});

// node_modules/ipns/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder12 = new TextEncoder();
var textDecoder11 = new TextDecoder();

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports18 = {};
__export(identity_exports18, {
  identity: () => identity18
});

// node_modules/ipns/node_modules/multiformats/dist/src/vendor/varint.js
var encode_19 = encode42;
var MSB10 = 128;
var REST10 = 127;
var MSBALL9 = ~REST10;
var INT9 = Math.pow(2, 31);
function encode42(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT9) {
    out[offset++] = num & 255 | MSB10;
    num /= 128;
  }
  while (num & MSBALL9) {
    out[offset++] = num & 255 | MSB10;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode42.bytes = offset - oldOffset + 1;
  return out;
}
var decode51 = read10;
var MSB$19 = 128;
var REST$19 = 127;
function read10(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read10.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$19);
  read10.bytes = counter - offset;
  return res;
}
var N110 = Math.pow(2, 7);
var N210 = Math.pow(2, 14);
var N310 = Math.pow(2, 21);
var N410 = Math.pow(2, 28);
var N510 = Math.pow(2, 35);
var N610 = Math.pow(2, 42);
var N710 = Math.pow(2, 49);
var N89 = Math.pow(2, 56);
var N99 = Math.pow(2, 63);
var length10 = function(value) {
  return value < N110 ? 1 : value < N210 ? 2 : value < N310 ? 3 : value < N410 ? 4 : value < N510 ? 5 : value < N610 ? 6 : value < N710 ? 7 : value < N89 ? 8 : value < N99 ? 9 : 10;
};
var varint9 = {
  encode: encode_19,
  decode: decode51,
  encodingLength: length10
};
var _brrp_varint9 = varint9;
var varint_default9 = _brrp_varint9;

// node_modules/ipns/node_modules/multiformats/dist/src/varint.js
function decode52(data, offset = 0) {
  const code33 = varint_default9.decode(data, offset);
  return [code33, varint_default9.decode.bytes];
}
function encodeTo9(int, target, offset = 0) {
  varint_default9.encode(int, target, offset);
  return target;
}
function encodingLength10(int) {
  return varint_default9.encodingLength(int);
}

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/digest.js
function create11(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength10(code33);
  const digestOffset = sizeOffset + encodingLength10(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo9(code33, bytes3, 0);
  encodeTo9(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest9(code33, size, digest27, bytes3);
}
function decode53(multihash) {
  const bytes3 = coerce12(multihash);
  const [code33, sizeOffset] = decode52(bytes3);
  const [size, digestOffset] = decode52(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest9(code33, size, digest27, bytes3);
}
function equals25(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals24(a.bytes, data.bytes);
  }
}
var Digest9 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/identity.js
var code14 = 0;
var name9 = "identity";
var encode43 = coerce12;
function digest9(input) {
  return create11(code14, encode43(input));
}
var identity18 = { code: code14, name: name9, encode: encode43, digest: digest9 };

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports9 = {};
__export(sha2_browser_exports9, {
  sha256: () => sha25610,
  sha512: () => sha51210
});

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/hasher.js
function from21({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher9(name29, code33, encode116);
}
var Hasher9 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create11(this.code, result) : result.then((digest27) => create11(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha9(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25610 = from21({
  name: "sha2-256",
  code: 18,
  encode: sha9("SHA-256")
});
var sha51210 = from21({
  name: "sha2-512",
  code: 19,
  encode: sha9("SHA-512")
});

// node_modules/ipns/node_modules/multiformats/dist/src/cid.js
function format9(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV09(bytes3, baseCache9(link), base45 ?? base58btc11.encoder);
    default:
      return toStringV19(bytes3, baseCache9(link), base45 ?? base3210.encoder);
  }
}
var cache10 = /* @__PURE__ */ new WeakMap();
function baseCache9(cid) {
  const baseCache28 = cache10.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache10.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID9 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE9) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE9) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create11(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals25(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format9(this, base45);
  }
  toJSON() {
    return { "/": format9(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID9(version3, code33, multihash.bytes));
    } else if (value[cidSymbol9] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode53(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE9) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID9(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE9, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce12(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest9(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode52(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE9;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes9(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache9(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes9(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc11;
      return [
        base58btc11.prefix,
        decoder.decode(`${base58btc11.prefix}${source}`)
      ];
    }
    case base58btc11.prefix: {
      const decoder = base45 ?? base58btc11;
      return [base58btc11.prefix, decoder.decode(source)];
    }
    case base3210.prefix: {
      const decoder = base45 ?? base3210;
      return [base3210.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV09(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc11.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV19(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE9 = 112;
var SHA_256_CODE9 = 18;
function encodeCID9(version3, code33, multihash) {
  const codeOffset = encodingLength10(version3);
  const hashOffset = codeOffset + encodingLength10(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo9(version3, bytes3, 0);
  encodeTo9(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

// node_modules/ipns/node_modules/multiformats/dist/src/basics.js
var bases9 = { ...identity_exports17, ...base2_exports9, ...base8_exports9, ...base10_exports9, ...base16_exports9, ...base32_exports9, ...base36_exports9, ...base58_exports9, ...base64_exports9, ...base256emoji_exports9 };
var hashes9 = { ...sha2_browser_exports9, ...identity_exports18 };

// node_modules/ipns/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe12(size = 0) {
  return new Uint8Array(size);
}

// node_modules/ipns/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec10(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string10 = createCodec10("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii9 = createCodec10("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe12(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES9 = {
  utf8: string10,
  "utf-8": string10,
  hex: bases9.base16,
  latin1: ascii9,
  ascii: ascii9,
  binary: ascii9,
  ...bases9
};
var bases_default9 = BASES9;

// node_modules/ipns/node_modules/uint8arrays/dist/src/from-string.js
function fromString17(string27, encoding = "utf8") {
  const base45 = bases_default9[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/ipns/node_modules/uint8arrays/dist/src/to-string.js
function toString18(array, encoding = "utf8") {
  const base45 = bases_default9[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/ipns/node_modules/interface-datastore/dist/src/key.js
var pathSepS2 = "/";
var pathSepB2 = new TextEncoder().encode(pathSepS2);
var pathSep2 = pathSepB2[0];

// node_modules/ipns/dist/src/index.js
var import_timestamp_nano = __toESM(require_timestamp_min(), 1);

// node_modules/ipns/node_modules/uint8arrays/dist/src/equals.js
function equals26(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/ipns/dist/src/errors.js
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_VALUE = "ERR_INVALID_VALUE";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
var ERR_RECORD_TOO_LARGE = "ERR_RECORD_TOO_LARGE";

// node_modules/ipns/dist/src/pb/ipns.js
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null) {
          w2.uint32(10);
          w2.bytes(obj.value);
        }
        if (obj.signatureV1 != null) {
          w2.uint32(18);
          w2.bytes(obj.signatureV1);
        }
        if (obj.validityType != null) {
          w2.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w2);
        }
        if (obj.validity != null) {
          w2.uint32(34);
          w2.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w2.uint32(40);
          w2.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w2.uint32(48);
          w2.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w2.uint32(58);
          w2.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w2.uint32(66);
          w2.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w2.uint32(74);
          w2.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader.bytes();
              break;
            case 2:
              obj.signatureV1 = reader.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader);
              break;
            case 4:
              obj.validity = reader.bytes();
              break;
            case 5:
              obj.sequence = reader.uint64();
              break;
            case 6:
              obj.ttl = reader.uint64();
              break;
            case 7:
              obj.pubKey = reader.bytes();
              break;
            case 8:
              obj.signatureV2 = reader.bytes();
              break;
            case 9:
              obj.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf3) => {
    return decodeMessage(buf3, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));

// node_modules/ipns/node_modules/cborg/lib/is.js
var typeofs2 = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames2 = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs2.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer3(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer3(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/ipns/node_modules/cborg/lib/token.js
var Type2 = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name29, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name29;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type2.uint = new Type2(0, "uint", true);
Type2.negint = new Type2(1, "negint", true);
Type2.bytes = new Type2(2, "bytes", true);
Type2.string = new Type2(3, "string", true);
Type2.array = new Type2(4, "array", false);
Type2.map = new Type2(5, "map", false);
Type2.tag = new Type2(6, "tag", false);
Type2.float = new Type2(7, "float", true);
Type2.false = new Type2(7, "false", true);
Type2.true = new Type2(7, "true", true);
Type2.null = new Type2(7, "null", true);
Type2.undefined = new Type2(7, "undefined", true);
Type2.break = new Type2(7, "break", true);
var Token2 = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/ipns/node_modules/cborg/lib/byte-utils.js
var useBuffer2 = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder12 = new TextDecoder();
var textEncoder13 = new TextEncoder();
function isBuffer4(buf3) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
}
function asU8A2(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
var toString19 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return end - start2 > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes3.subarray(start2, end)).toString("utf8")
    ) : utf8Slice2(bytes3, start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return end - start2 > 64 ? textDecoder12.decode(bytes3.subarray(start2, end)) : utf8Slice2(bytes3, start2, end);
  }
);
var fromString18 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string27) => {
    return string27.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string27)
    ) : utf8ToBytes4(string27);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string27) => {
    return string27.length > 64 ? textEncoder13.encode(string27) : utf8ToBytes4(string27);
  }
);
var slice2 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    if (isBuffer4(bytes3)) {
      return new Uint8Array(bytes3.subarray(start2, end));
    }
    return bytes3.slice(start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes3, start2, end) => {
    return bytes3.slice(start2, end);
  }
);
var concat6 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length30) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A2(globalThis.Buffer.concat(chunks, length30));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length30) => {
    const out = new Uint8Array(length30);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc7 = useBuffer2 ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare2(b1, b2) {
  if (isBuffer4(b1) && isBuffer4(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes4(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice2(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}

// node_modules/ipns/node_modules/cborg/lib/bl.js
var defaultChunkSize2 = 256;
var Bl2 = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize2) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes3) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes3.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes3, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
        topChunk = alloc7(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes3, 0);
      } else {
        this.chunks.push(bytes3);
        this.maxCursor += bytes3.length;
      }
    }
    this.cursor += bytes3.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice2(chunk, 0, this.cursor);
      }
    } else {
      byts = concat6(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/ipns/node_modules/cborg/lib/common.js
var decodeErrPrefix2 = "CBOR decode error:";
var encodeErrPrefix2 = "CBOR encode error:";
var uintMinorPrefixBytes2 = [];
uintMinorPrefixBytes2[23] = 1;
uintMinorPrefixBytes2[24] = 2;
uintMinorPrefixBytes2[25] = 3;
uintMinorPrefixBytes2[26] = 5;
uintMinorPrefixBytes2[27] = 9;
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}

// node_modules/ipns/node_modules/cborg/lib/0uint.js
var uintBoundaries2 = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint82(data, offset, options2) {
  assertEnoughData2(data, offset, 1);
  const value = data[offset];
  if (options2.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint162(data, offset, options2) {
  assertEnoughData2(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options2.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint322(data, offset, options2) {
  assertEnoughData2(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options2.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint642(data, offset, options2) {
  assertEnoughData2(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options2.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options2.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
function decodeUint82(data, pos, _minor, options2) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options2), 2);
}
function decodeUint162(data, pos, _minor, options2) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options2), 3);
}
function decodeUint322(data, pos, _minor, options2) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options2), 5);
}
function decodeUint642(data, pos, _minor, options2) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options2), 9);
}
function encodeUint2(buf3, token) {
  return encodeUintValue2(buf3, 0, token.value);
}
function encodeUintValue2(buf3, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf3.push(set);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint2.encodedSize = function encodedSize9(token) {
  return encodeUintValue2.encodedSize(token.value);
};
encodeUintValue2.encodedSize = function encodedSize10(uint) {
  if (uint < uintBoundaries2[0]) {
    return 1;
  }
  if (uint < uintBoundaries2[1]) {
    return 2;
  }
  if (uint < uintBoundaries2[2]) {
    return 3;
  }
  if (uint < uintBoundaries2[3]) {
    return 5;
  }
  return 9;
};
encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/ipns/node_modules/cborg/lib/1negint.js
function decodeNegint82(data, pos, _minor, options2) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options2), 2);
}
function decodeNegint162(data, pos, _minor, options2) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options2), 3);
}
function decodeNegint322(data, pos, _minor, options2) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options2), 5);
}
var neg1b2 = BigInt(-1);
var pos1b2 = BigInt(1);
function decodeNegint642(data, pos, _minor, options2) {
  const int = readUint642(data, pos + 1, options2);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options2.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int), 9);
}
function encodeNegint2(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf3, token.type.majorEncoded, unsigned);
}
encodeNegint2.encodedSize = function encodedSize11(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  if (unsigned < uintBoundaries2[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries2[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries2[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries2[3]) {
    return 5;
  }
  return 9;
};
encodeNegint2.compareTokens = function compareTokens5(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/ipns/node_modules/cborg/lib/2bytes.js
function toToken5(data, pos, prefix, length30) {
  assertEnoughData2(data, pos, prefix + length30);
  const buf3 = slice2(data, pos + prefix, pos + prefix + length30);
  return new Token2(Type2.bytes, buf3, prefix + length30);
}
function decodeBytesCompact2(data, pos, minor, _options) {
  return toToken5(data, pos, 1, minor);
}
function decodeBytes82(data, pos, _minor, options2) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options2));
}
function decodeBytes162(data, pos, _minor, options2) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options2));
}
function decodeBytes322(data, pos, _minor, options2) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options2));
}
function decodeBytes642(data, pos, _minor, options2) {
  const l = readUint642(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l);
}
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString18(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes2(buf3, token) {
  const bytes3 = tokenBytes2(token);
  encodeUintValue2(buf3, token.type.majorEncoded, bytes3.length);
  buf3.push(bytes3);
}
encodeBytes2.encodedSize = function encodedSize12(token) {
  const bytes3 = tokenBytes2(token);
  return encodeUintValue2.encodedSize(bytes3.length) + bytes3.length;
};
encodeBytes2.compareTokens = function compareTokens6(tok1, tok2) {
  return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
};
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}

// node_modules/ipns/node_modules/cborg/lib/3string.js
function toToken6(data, pos, prefix, length30, options2) {
  const totLength = prefix + length30;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString19(data, pos + prefix, pos + totLength), totLength);
  if (options2.retainStringBytes === true) {
    tok.byteValue = slice2(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact2(data, pos, minor, options2) {
  return toToken6(data, pos, 1, minor, options2);
}
function decodeString82(data, pos, _minor, options2) {
  return toToken6(data, pos, 2, readUint82(data, pos + 1, options2), options2);
}
function decodeString162(data, pos, _minor, options2) {
  return toToken6(data, pos, 3, readUint162(data, pos + 1, options2), options2);
}
function decodeString322(data, pos, _minor, options2) {
  return toToken6(data, pos, 5, readUint322(data, pos + 1, options2), options2);
}
function decodeString642(data, pos, _minor, options2) {
  const l = readUint642(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken6(data, pos, 9, l, options2);
}
var encodeString2 = encodeBytes2;

// node_modules/ipns/node_modules/cborg/lib/4array.js
function toToken7(_data, _pos, prefix, length30) {
  return new Token2(Type2.array, length30, prefix);
}
function decodeArrayCompact2(data, pos, minor, _options) {
  return toToken7(data, pos, 1, minor);
}
function decodeArray82(data, pos, _minor, options2) {
  return toToken7(data, pos, 2, readUint82(data, pos + 1, options2));
}
function decodeArray162(data, pos, _minor, options2) {
  return toToken7(data, pos, 3, readUint162(data, pos + 1, options2));
}
function decodeArray322(data, pos, _minor, options2) {
  return toToken7(data, pos, 5, readUint322(data, pos + 1, options2));
}
function decodeArray642(data, pos, _minor, options2) {
  const l = readUint642(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken7(data, pos, 9, l);
}
function decodeArrayIndefinite2(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken7(data, pos, 1, Infinity);
}
function encodeArray2(buf3, token) {
  encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
}
encodeArray2.compareTokens = encodeUint2.compareTokens;
encodeArray2.encodedSize = function encodedSize13(token) {
  return encodeUintValue2.encodedSize(token.value);
};

// node_modules/ipns/node_modules/cborg/lib/5map.js
function toToken8(_data, _pos, prefix, length30) {
  return new Token2(Type2.map, length30, prefix);
}
function decodeMapCompact2(data, pos, minor, _options) {
  return toToken8(data, pos, 1, minor);
}
function decodeMap82(data, pos, _minor, options2) {
  return toToken8(data, pos, 2, readUint82(data, pos + 1, options2));
}
function decodeMap162(data, pos, _minor, options2) {
  return toToken8(data, pos, 3, readUint162(data, pos + 1, options2));
}
function decodeMap322(data, pos, _minor, options2) {
  return toToken8(data, pos, 5, readUint322(data, pos + 1, options2));
}
function decodeMap642(data, pos, _minor, options2) {
  const l = readUint642(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken8(data, pos, 9, l);
}
function decodeMapIndefinite2(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken8(data, pos, 1, Infinity);
}
function encodeMap2(buf3, token) {
  encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
}
encodeMap2.compareTokens = encodeUint2.compareTokens;
encodeMap2.encodedSize = function encodedSize14(token) {
  return encodeUintValue2.encodedSize(token.value);
};

// node_modules/ipns/node_modules/cborg/lib/6tag.js
function decodeTagCompact2(_data, _pos, minor, _options) {
  return new Token2(Type2.tag, minor, 1);
}
function decodeTag82(data, pos, _minor, options2) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options2), 2);
}
function decodeTag162(data, pos, _minor, options2) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options2), 3);
}
function decodeTag322(data, pos, _minor, options2) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options2), 5);
}
function decodeTag642(data, pos, _minor, options2) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options2), 9);
}
function encodeTag2(buf3, token) {
  encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
}
encodeTag2.compareTokens = encodeUint2.compareTokens;
encodeTag2.encodedSize = function encodedSize15(token) {
  return encodeUintValue2.encodedSize(token.value);
};

// node_modules/ipns/node_modules/cborg/lib/7float.js
var MINOR_FALSE2 = 20;
var MINOR_TRUE2 = 21;
var MINOR_NULL2 = 22;
var MINOR_UNDEFINED2 = 23;
function decodeUndefined2(_data, _pos, _minor, options2) {
  if (options2.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options2.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
function decodeBreak2(_data, _pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
function createToken2(value, bytes3, options2) {
  if (options2) {
    if (options2.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options2.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes3);
}
function decodeFloat162(data, pos, _minor, options2) {
  return createToken2(readFloat162(data, pos + 1), 3, options2);
}
function decodeFloat322(data, pos, _minor, options2) {
  return createToken2(readFloat322(data, pos + 1), 5, options2);
}
function decodeFloat642(data, pos, _minor, options2) {
  return createToken2(readFloat642(data, pos + 1), 9, options2);
}
function encodeFloat2(buf3, token, options2) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float === true) {
    buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float === null) {
    buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float === void 0) {
    buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success = false;
    if (!options2 || options2.float64 !== true) {
      encodeFloat162(float);
      decoded = readFloat162(ui8a2, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a2[0] = 249;
        buf3.push(ui8a2.slice(0, 3));
        success = true;
      } else {
        encodeFloat322(float);
        decoded = readFloat322(ui8a2, 1);
        if (float === decoded) {
          ui8a2[0] = 250;
          buf3.push(ui8a2.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat642(float);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf3.push(ui8a2.slice(0, 9));
    }
  }
}
encodeFloat2.encodedSize = function encodedSize16(token, options2) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options2 || options2.float64 !== true) {
    encodeFloat162(float);
    let decoded = readFloat162(ui8a2, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat322(float);
    decoded = readFloat322(ui8a2, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer2 = new ArrayBuffer(9);
var dataView2 = new DataView(buffer2, 1);
var ui8a2 = new Uint8Array(buffer2, 0);
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat162(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
function readFloat322(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
function readFloat642(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat2.compareTokens = encodeUint2.compareTokens;

// node_modules/ipns/node_modules/cborg/lib/jump.js
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
var jump2 = [];
for (let i = 0; i <= 23; i++) {
  jump2[i] = invalidMinor2;
}
jump2[24] = decodeUint82;
jump2[25] = decodeUint162;
jump2[26] = decodeUint322;
jump2[27] = decodeUint642;
jump2[28] = invalidMinor2;
jump2[29] = invalidMinor2;
jump2[30] = invalidMinor2;
jump2[31] = invalidMinor2;
for (let i = 32; i <= 55; i++) {
  jump2[i] = invalidMinor2;
}
jump2[56] = decodeNegint82;
jump2[57] = decodeNegint162;
jump2[58] = decodeNegint322;
jump2[59] = decodeNegint642;
jump2[60] = invalidMinor2;
jump2[61] = invalidMinor2;
jump2[62] = invalidMinor2;
jump2[63] = invalidMinor2;
for (let i = 64; i <= 87; i++) {
  jump2[i] = decodeBytesCompact2;
}
jump2[88] = decodeBytes82;
jump2[89] = decodeBytes162;
jump2[90] = decodeBytes322;
jump2[91] = decodeBytes642;
jump2[92] = invalidMinor2;
jump2[93] = invalidMinor2;
jump2[94] = invalidMinor2;
jump2[95] = errorer2("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump2[i] = decodeStringCompact2;
}
jump2[120] = decodeString82;
jump2[121] = decodeString162;
jump2[122] = decodeString322;
jump2[123] = decodeString642;
jump2[124] = invalidMinor2;
jump2[125] = invalidMinor2;
jump2[126] = invalidMinor2;
jump2[127] = errorer2("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump2[i] = decodeArrayCompact2;
}
jump2[152] = decodeArray82;
jump2[153] = decodeArray162;
jump2[154] = decodeArray322;
jump2[155] = decodeArray642;
jump2[156] = invalidMinor2;
jump2[157] = invalidMinor2;
jump2[158] = invalidMinor2;
jump2[159] = decodeArrayIndefinite2;
for (let i = 160; i <= 183; i++) {
  jump2[i] = decodeMapCompact2;
}
jump2[184] = decodeMap82;
jump2[185] = decodeMap162;
jump2[186] = decodeMap322;
jump2[187] = decodeMap642;
jump2[188] = invalidMinor2;
jump2[189] = invalidMinor2;
jump2[190] = invalidMinor2;
jump2[191] = decodeMapIndefinite2;
for (let i = 192; i <= 215; i++) {
  jump2[i] = decodeTagCompact2;
}
jump2[216] = decodeTag82;
jump2[217] = decodeTag162;
jump2[218] = decodeTag322;
jump2[219] = decodeTag642;
jump2[220] = invalidMinor2;
jump2[221] = invalidMinor2;
jump2[222] = invalidMinor2;
jump2[223] = invalidMinor2;
for (let i = 224; i <= 243; i++) {
  jump2[i] = errorer2("simple values are not supported");
}
jump2[244] = invalidMinor2;
jump2[245] = invalidMinor2;
jump2[246] = invalidMinor2;
jump2[247] = decodeUndefined2;
jump2[248] = errorer2("simple values are not supported");
jump2[249] = decodeFloat162;
jump2[250] = decodeFloat322;
jump2[251] = decodeFloat642;
jump2[252] = invalidMinor2;
jump2[253] = invalidMinor2;
jump2[254] = invalidMinor2;
jump2[255] = decodeBreak2;
var quick2 = [];
for (let i = 0; i < 24; i++) {
  quick2[i] = new Token2(Type2.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick2[31 - i] = new Token2(Type2.negint, i, 1);
}
quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
quick2[96] = new Token2(Type2.string, "", 1);
quick2[128] = new Token2(Type2.array, 0, 1);
quick2[160] = new Token2(Type2.map, 0, 1);
quick2[244] = new Token2(Type2.false, false, 1);
quick2[245] = new Token2(Type2.true, true, 1);
quick2[246] = new Token2(Type2.null, null, 1);

// node_modules/ipns/node_modules/cborg/lib/encode.js
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes2;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
var cborEncoders2 = makeCborEncoders2();
var buf2 = new Bl2();
var Ref2 = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix2} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens2 = {
  null: new Token2(Type2.null, null),
  undefined: new Token2(Type2.undefined, void 0),
  true: new Token2(Type2.true, true),
  false: new Token2(Type2.false, false),
  emptyArray: new Token2(Type2.array, 0),
  emptyMap: new Token2(Type2.map, 0)
};
var typeEncoders2 = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token2(Type2.float, obj);
    } else if (obj >= 0) {
      return new Token2(Type2.uint, obj);
    } else {
      return new Token2(Type2.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token2(Type2.uint, obj);
    } else {
      return new Token2(Type2.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token2(Type2.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens2.true : simpleTokens2.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens2.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens2.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options2, refStack) {
    if (!obj.length) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens2.emptyArray, new Token2(Type2.break)];
      }
      return simpleTokens2.emptyArray;
    }
    refStack = Ref2.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens2(e, options2, refStack);
    }
    if (options2.addBreakTokens) {
      return [new Token2(Type2.array, obj.length), entries, new Token2(Type2.break)];
    }
    return [new Token2(Type2.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options2, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length30 = isMap ? obj.size : keys.length;
    if (!length30) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens2.emptyMap, new Token2(Type2.break)];
      }
      return simpleTokens2.emptyMap;
    }
    refStack = Ref2.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens2(key, options2, refStack),
        objectToTokens2(isMap ? obj.get(key) : obj[key], options2, refStack)
      ];
    }
    sortMapEntries2(entries, options2);
    if (options2.addBreakTokens) {
      return [new Token2(Type2.map, length30), entries, new Token2(Type2.break)];
    }
    return [new Token2(Type2.map, length30), entries];
  }
};
typeEncoders2.Map = typeEncoders2.Object;
typeEncoders2.Buffer = typeEncoders2.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
}
function objectToTokens2(obj, options2 = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options2 && options2.typeEncoders && /** @type {OptionalTypeEncoder} */
  options2.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options2, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options2, refStack);
}
function sortMapEntries2(entries, options2) {
  if (options2.mapSorter) {
    entries.sort(options2.mapSorter);
  }
}

// node_modules/ipns/node_modules/cborg/lib/decode.js
var defaultDecodeOptions2 = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser2 = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick2[byt];
    if (token === void 0) {
      const decoder = jump2[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE2 = Symbol.for("DONE");
var BREAK2 = Symbol.for("BREAK");
function tokenToArray2(token, tokeniser, options2) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options2);
    if (value === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap2(token, tokeniser, options2) {
  const useMaps = options2.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options2);
    if (key === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    if (options2.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject2(tokeniser, options2);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject2(tokeniser, options2) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK2;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options2);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options2);
  }
  if (token.type === Type2.tag) {
    if (options2.tags && typeof options2.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options2);
      return options2.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst3(data, options2) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options2 = Object.assign({}, defaultDecodeOptions2, options2);
  const tokeniser = options2.tokenizer || new Tokeniser2(data, options2);
  const decoded = tokensToObject2(tokeniser, options2);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK2) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode54(data, options2) {
  const [decoded, remainder] = decodeFirst3(data, options2);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/ipns/dist/src/utils.js
var import_err_code2 = __toESM(require_err_code(), 1);

// node_modules/ipns/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array4(buf3) {
  return buf3;
}

// node_modules/ipns/node_modules/uint8arrays/dist/src/concat.js
function concat7(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe12(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array4(output3);
}

// node_modules/ipns/dist/src/utils.js
var log4 = logger("ipns:utils");
var IPNS_PREFIX = fromString17("/ipns/");
var LIBP2P_CID_CODEC = 114;
var extractPublicKey = async (peerId2, record) => {
  if (record == null || peerId2 == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log4.error(error);
    throw (0, import_err_code2.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (record.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey2(record.pubKey);
    } catch (err) {
      log4.error(err);
      throw err;
    }
    const otherId = await peerIdFromKeys(record.pubKey);
    if (!otherId.equals(peerId2)) {
      throw (0, import_err_code2.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId2.publicKey != null) {
    pubKey = unmarshalPublicKey2(peerId2.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw (0, import_err_code2.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
var ipnsRecordDataForV2Sig = (data) => {
  const entryData = fromString17("ipns-signature:");
  return concat7([entryData, data]);
};
var marshal = (obj) => {
  if ("signatureV1" in obj) {
    return IpnsEntry.encode({
      value: fromString17(obj.value),
      signatureV1: obj.signatureV1,
      validityType: obj.validityType,
      validity: fromString17(obj.validity),
      sequence: obj.sequence,
      ttl: obj.ttl,
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  } else {
    return IpnsEntry.encode({
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  }
};
function unmarshal(buf3) {
  const message2 = IpnsEntry.decode(buf3);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  if (message2.signatureV2 == null || message2.data == null) {
    throw (0, import_err_code2.default)(new Error("missing data or signatureV2"), ERR_SIGNATURE_VERIFICATION);
  }
  const data = parseCborData(message2.data);
  const value = normalizeValue(data.Value);
  const validity = toString18(data.Validity);
  if (message2.value != null && message2.signatureV1 != null) {
    validateCborDataMatchesPbData(message2);
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV1: message2.signatureV1,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else if (message2.signatureV2 != null) {
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else {
    throw new Error("invalid record: does not include signatureV1 or signatureV2");
  }
}
var peerIdToRoutingKey = (peerId2) => {
  return concat7([
    IPNS_PREFIX,
    peerId2.toBytes()
  ]);
};
var peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));
};
var parseCborData = (buf3) => {
  const data = decode54(buf3);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw (0, import_err_code2.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};
var normalizeValue = (value) => {
  if (value != null) {
    if (isPeerId(value)) {
      return `/ipns/${value.toCID().toString(base369)}`;
    }
    if (value instanceof Uint8Array) {
      const string28 = toString18(value);
      if (string28.startsWith("/")) {
        value = string28;
      }
    }
    const string27 = value.toString().trim();
    if (string27.startsWith("/") && string27.length > 1) {
      return string27;
    }
    const cid = CID9.asCID(value);
    if (cid != null) {
      if (cid.code === LIBP2P_CID_CODEC) {
        return `/ipns/${cid.toString(base369)}`;
      }
      return `/ipfs/${cid.toV1().toString()}`;
    }
    try {
      if (value instanceof Uint8Array) {
        return `/ipfs/${CID9.decode(value).toV1().toString()}`;
      }
      return `/ipfs/${CID9.parse(string27).toV1().toString()}`;
    } catch {
    }
  }
  throw (0, import_err_code2.default)(new Error("Value must be a valid content path starting with /"), ERR_INVALID_VALUE);
};
var validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw (0, import_err_code2.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals26(data.Value, entry.value ?? new Uint8Array(0))) {
    throw (0, import_err_code2.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals26(data.Validity, entry.validity ?? new Uint8Array(0))) {
    throw (0, import_err_code2.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code2.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code2.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code2.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};

// node_modules/ipns/dist/src/index.js
var log5 = logger("ipns");
var ID_MULTIHASH_CODE = identity18.code;
var DEFAULT_TTL_NS = 60 * 60 * 1e9;
var namespace = "/ipns/";
var namespaceLength = namespace.length;

// node_modules/ipns/dist/src/validator.js
var import_err_code4 = __toESM(require_err_code(), 1);
var import_timestamp_nano2 = __toESM(require_timestamp_min(), 1);
var log6 = logger("ipns:validator");
var MAX_RECORD_SIZE = 1024 * 10;
var validate2 = async (publicKey, buf3) => {
  const record = unmarshal(buf3);
  let isValid;
  try {
    const dataForSignature = ipnsRecordDataForV2Sig(record.data);
    isValid = await publicKey.verify(dataForSignature, record.signatureV2);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log6.error("record signature verification failed");
    throw (0, import_err_code4.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (record.validityType === IpnsEntry.ValidityType.EOL) {
    if (import_timestamp_nano2.default.fromString(record.validity).toDate().getTime() < Date.now()) {
      log6.error("record has expired");
      throw (0, import_err_code4.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (record.validityType != null) {
    log6.error("unrecognized validity type");
    throw (0, import_err_code4.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log6("ipns record for %s is valid", record.value);
};
async function ipnsValidator(key, marshalledData) {
  if (marshalledData.byteLength > MAX_RECORD_SIZE) {
    throw (0, import_err_code4.default)(new Error("record too large"), ERR_RECORD_TOO_LARGE);
  }
  const peerId2 = peerIdFromRoutingKey(key);
  const receivedRecord = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId2, receivedRecord);
  await validate2(pubKey, marshalledData);
}

// node_modules/it-ndjson/dist/src/parse.js
async function* parse2(source) {
  const matcher = /\r?\n/;
  const decoder = new TextDecoder("utf8");
  let buffer3 = "";
  for await (let chunk of source) {
    if (typeof chunk === "string") {
      chunk = new TextEncoder().encode(chunk);
    }
    buffer3 += decoder.decode(chunk, { stream: true });
    const parts = buffer3.split(matcher);
    buffer3 = parts.pop() ?? "";
    for (let i = 0; i < parts.length; i++) {
      yield JSON.parse(parts[i]);
    }
  }
  buffer3 += decoder.decode();
  if (buffer3 !== "") {
    yield JSON.parse(buffer3);
  }
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/p-defer/index.js
function pDefer5() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/it-first/dist/src/index.js
function isAsyncIterable10(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function first(source) {
  if (isAsyncIterable10(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
var src_default13 = first;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/it-peekable/dist/src/index.js
function peekable4(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default14 = peekable4;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/it-map/dist/src/index.js
function isAsyncIterable11(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map2(source, func2) {
  let index = 0;
  if (isAsyncIterable11(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val, index++);
      }
    }();
  }
  const peekable8 = src_default14(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = func2(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable8) {
        yield func2(val, index++);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable8) {
      yield fn(val, index++);
    }
  }();
}
var src_default15 = map2;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/uint8arrays/dist/src/equals.js
function equals27(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports10 = {};
__export(base10_exports10, {
  base10: () => base1010
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bytes.js
var empty13 = new Uint8Array(0);
function equals28(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce13(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString19(str) {
  return new TextEncoder().encode(str);
}
function toString20(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/vendor/base-x.js
function base15(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src12 = base15;
var _brrp__multiformats_scope_baseX12 = src12;
var base_x_default13 = _brrp__multiformats_scope_baseX12;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base.js
var Encoder13 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder13 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or14(this, decoder);
  }
};
var ComposedDecoder13 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or14(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or14(left, right) {
  return new ComposedDecoder13({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec13 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder13(name29, prefix, baseEncode);
    this.decoder = new Decoder13(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from22({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec13(name29, prefix, encode116, decode144);
}
function baseX12({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default13(alphabet27, name29);
  return from22({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce13(decode144(text))
  });
}
function decode55(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode45(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464813({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from22({
    prefix,
    name: name29,
    encode(input) {
      return encode45(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode55(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base10.js
var base1010 = baseX12({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports10 = {};
__export(base16_exports10, {
  base16: () => base1610,
  base16upper: () => base16upper10
});
var base1610 = rfc464813({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper10 = rfc464813({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports10 = {};
__export(base2_exports10, {
  base2: () => base210
});
var base210 = rfc464813({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports10 = {};
__export(base256emoji_exports10, {
  base256emoji: () => base256emoji10
});
var alphabet10 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars10 = alphabet10.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes10 = alphabet10.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode46(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars10[c];
    return p;
  }, "");
}
function decode56(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes10[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji10 = from22({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode46,
  decode: decode56
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports10 = {};
__export(base32_exports10, {
  base32: () => base3211,
  base32hex: () => base32hex11,
  base32hexpad: () => base32hexpad11,
  base32hexpadupper: () => base32hexpadupper11,
  base32hexupper: () => base32hexupper11,
  base32pad: () => base32pad11,
  base32padupper: () => base32padupper11,
  base32upper: () => base32upper11,
  base32z: () => base32z11
});
var base3211 = rfc464813({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper11 = rfc464813({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad11 = rfc464813({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper11 = rfc464813({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex11 = rfc464813({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper11 = rfc464813({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad11 = rfc464813({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper11 = rfc464813({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z11 = rfc464813({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports10 = {};
__export(base36_exports10, {
  base36: () => base3610,
  base36upper: () => base36upper10
});
var base3610 = baseX12({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper10 = baseX12({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports10 = {};
__export(base58_exports10, {
  base58btc: () => base58btc12,
  base58flickr: () => base58flickr12
});
var base58btc12 = baseX12({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr12 = baseX12({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports10 = {};
__export(base64_exports10, {
  base64: () => base6413,
  base64pad: () => base64pad13,
  base64url: () => base64url13,
  base64urlpad: () => base64urlpad13
});
var base6413 = rfc464813({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad13 = rfc464813({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url13 = rfc464813({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad13 = rfc464813({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports10 = {};
__export(base8_exports10, {
  base8: () => base810
});
var base810 = rfc464813({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports19 = {};
__export(identity_exports19, {
  identity: () => identity19
});
var identity19 = from22({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString20(buf3),
  decode: (str) => fromString19(str)
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder14 = new TextEncoder();
var textDecoder13 = new TextDecoder();

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports20 = {};
__export(identity_exports20, {
  identity: () => identity20
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/vendor/varint.js
var encode_110 = encode47;
var MSB11 = 128;
var REST11 = 127;
var MSBALL10 = ~REST11;
var INT10 = Math.pow(2, 31);
function encode47(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT10) {
    out[offset++] = num & 255 | MSB11;
    num /= 128;
  }
  while (num & MSBALL10) {
    out[offset++] = num & 255 | MSB11;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode47.bytes = offset - oldOffset + 1;
  return out;
}
var decode57 = read11;
var MSB$110 = 128;
var REST$110 = 127;
function read11(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read11.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$110);
  read11.bytes = counter - offset;
  return res;
}
var N111 = Math.pow(2, 7);
var N211 = Math.pow(2, 14);
var N311 = Math.pow(2, 21);
var N411 = Math.pow(2, 28);
var N511 = Math.pow(2, 35);
var N611 = Math.pow(2, 42);
var N711 = Math.pow(2, 49);
var N810 = Math.pow(2, 56);
var N910 = Math.pow(2, 63);
var length11 = function(value) {
  return value < N111 ? 1 : value < N211 ? 2 : value < N311 ? 3 : value < N411 ? 4 : value < N511 ? 5 : value < N611 ? 6 : value < N711 ? 7 : value < N810 ? 8 : value < N910 ? 9 : 10;
};
var varint10 = {
  encode: encode_110,
  decode: decode57,
  encodingLength: length11
};
var _brrp_varint10 = varint10;
var varint_default10 = _brrp_varint10;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/varint.js
function decode58(data, offset = 0) {
  const code33 = varint_default10.decode(data, offset);
  return [code33, varint_default10.decode.bytes];
}
function encodeTo10(int, target, offset = 0) {
  varint_default10.encode(int, target, offset);
  return target;
}
function encodingLength11(int) {
  return varint_default10.encodingLength(int);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/digest.js
function create12(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength11(code33);
  const digestOffset = sizeOffset + encodingLength11(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo10(code33, bytes3, 0);
  encodeTo10(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest10(code33, size, digest27, bytes3);
}
function decode59(multihash) {
  const bytes3 = coerce13(multihash);
  const [code33, sizeOffset] = decode58(bytes3);
  const [size, digestOffset] = decode58(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest10(code33, size, digest27, bytes3);
}
function equals29(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals28(a.bytes, data.bytes);
  }
}
var Digest10 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/identity.js
var code15 = 0;
var name10 = "identity";
var encode48 = coerce13;
function digest10(input) {
  return create12(code15, encode48(input));
}
var identity20 = { code: code15, name: name10, encode: encode48, digest: digest10 };

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports10 = {};
__export(sha2_browser_exports10, {
  sha256: () => sha25611,
  sha512: () => sha51211
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/hasher.js
function from23({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher10(name29, code33, encode116);
}
var Hasher10 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create12(this.code, result) : result.then((digest27) => create12(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha10(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25611 = from23({
  name: "sha2-256",
  code: 18,
  encode: sha10("SHA-256")
});
var sha51211 = from23({
  name: "sha2-512",
  code: 19,
  encode: sha10("SHA-512")
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/cid.js
function format10(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV010(bytes3, baseCache10(link), base45 ?? base58btc12.encoder);
    default:
      return toStringV110(bytes3, baseCache10(link), base45 ?? base3211.encoder);
  }
}
var cache11 = /* @__PURE__ */ new WeakMap();
function baseCache10(cid) {
  const baseCache28 = cache11.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache11.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID10 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE10) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE10) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create12(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals29(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format10(this, base45);
  }
  toJSON() {
    return { "/": format10(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID10(version3, code33, multihash.bytes));
    } else if (value[cidSymbol10] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode59(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE10) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID10(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE10, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce13(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest10(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode58(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE10;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes10(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache10(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes10(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc12;
      return [
        base58btc12.prefix,
        decoder.decode(`${base58btc12.prefix}${source}`)
      ];
    }
    case base58btc12.prefix: {
      const decoder = base45 ?? base58btc12;
      return [base58btc12.prefix, decoder.decode(source)];
    }
    case base3211.prefix: {
      const decoder = base45 ?? base3211;
      return [base3211.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV010(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc12.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV110(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE10 = 112;
var SHA_256_CODE10 = 18;
function encodeCID10(version3, code33, multihash) {
  const codeOffset = encodingLength11(version3);
  const hashOffset = codeOffset + encodingLength11(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo10(version3, bytes3, 0);
  encodeTo10(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol10 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/basics.js
var bases10 = { ...identity_exports19, ...base2_exports10, ...base8_exports10, ...base10_exports10, ...base16_exports10, ...base32_exports10, ...base36_exports10, ...base58_exports10, ...base64_exports10, ...base256emoji_exports10 };
var hashes10 = { ...sha2_browser_exports10, ...identity_exports20 };

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe13(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec11(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string11 = createCodec11("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii10 = createCodec11("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe13(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES10 = {
  utf8: string11,
  "utf-8": string11,
  hex: bases10.base16,
  latin1: ascii10,
  ascii: ascii10,
  binary: ascii10,
  ...bases10
};
var bases_default10 = BASES10;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/uint8arrays/dist/src/from-string.js
function fromString20(string27, encoding = "utf8") {
  const base45 = bases_default10[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js
var IPNS_PREFIX2 = fromString20("/ipns/");
function isIPNSKey(key) {
  return equals27(key.subarray(0, IPNS_PREFIX2.byteLength), IPNS_PREFIX2);
}
var peerIdFromRoutingKey2 = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX2.length));
};
var DelegatedRoutingV1HttpApiClientContentRouting = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async *findProviders(cid, options2 = {}) {
    yield* src_default15(this.client.getProviders(cid, options2), (record) => {
      return {
        id: record.ID,
        multiaddrs: record.Addrs ?? []
      };
    });
  }
  async provide() {
  }
  async put(key, value, options2) {
    if (!isIPNSKey(key)) {
      return;
    }
    const peerId2 = peerIdFromRoutingKey2(key);
    const record = unmarshal(value);
    await this.client.putIPNS(peerId2, record, options2);
  }
  async get(key, options2) {
    if (!isIPNSKey(key)) {
      throw new CodeError("Not found", "ERR_NOT_FOUND");
    }
    const peerId2 = peerIdFromRoutingKey2(key);
    try {
      const record = await this.client.getIPNS(peerId2, options2);
      return marshal(record);
    } catch (err) {
      if (err.code === "ERR_BAD_RESPONSE") {
        throw new CodeError("Not found", "ERR_NOT_FOUND");
      }
      throw err;
    }
  }
};
var DelegatedRoutingV1HttpApiClientPeerRouting = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async findPeer(peerId2, options2 = {}) {
    const peer = await src_default13(this.client.getPeers(peerId2, options2));
    if (peer != null) {
      return {
        id: peer.ID,
        multiaddrs: peer.Addrs ?? []
      };
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options2 = {}) {
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js
var log7 = logger("delegated-routing-v1-http-api-client");
var defaultValues = {
  concurrentRequests: 4,
  timeout: 3e4
};
var DefaultDelegatedRoutingV1HttpApiClient = class {
  started;
  httpQueue;
  shutDownController;
  clientUrl;
  timeout;
  contentRouting;
  peerRouting;
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(url, init = {}) {
    this.started = false;
    this.shutDownController = new AbortController();
    setMaxListeners2(Infinity, this.shutDownController.signal);
    this.httpQueue = new PQueue({
      concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
    });
    this.clientUrl = url instanceof URL ? url : new URL(url);
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.contentRouting = new DelegatedRoutingV1HttpApiClientContentRouting(this);
    this.peerRouting = new DelegatedRoutingV1HttpApiClientPeerRouting(this);
  }
  get [contentRoutingSymbol]() {
    return this.contentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.peerRouting;
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.shutDownController.abort();
    this.started = false;
  }
  async *getProviders(cid, options2 = {}) {
    log7("getProviders starts: %c", cid);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal3([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners2(Infinity, timeoutSignal, signal);
    const onStart = pDefer5();
    const onFinish = pDefer5();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const resource = `${this.clientUrl}routing/v1/providers/${cid.toString()}`;
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await fetch(resource, getOptions);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("Routing response had no body", "ERR_BAD_RESPONSE");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const provider of body.Providers) {
          const record = this.#conformToPeerSchema(provider);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const provider of parse2(browserReadableStreamToIt(res.body))) {
          const record = this.#conformToPeerSchema(provider);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log7.error("getProviders errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log7("getProviders finished: %c", cid);
    }
  }
  async *getPeers(peerId2, options2 = {}) {
    log7("getPeers starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal3([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners2(Infinity, timeoutSignal, signal);
    const onStart = pDefer5();
    const onFinish = pDefer5();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const resource = `${this.clientUrl}routing/v1/peers/${peerId2.toCID().toString()}`;
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await fetch(resource, getOptions);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("Routing response had no body", "ERR_BAD_RESPONSE");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const peer of body.Peers) {
          const record = this.#conformToPeerSchema(peer);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const peer of parse2(browserReadableStreamToIt(res.body))) {
          const record = this.#conformToPeerSchema(peer);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log7.error("getPeers errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log7("getPeers finished: %c", peerId2);
    }
  }
  async getIPNS(peerId2, options2 = {}) {
    log7("getIPNS starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal3([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners2(Infinity, timeoutSignal, signal);
    const onStart = pDefer5();
    const onFinish = pDefer5();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${peerId2.toCID().toString()}`;
    try {
      await onStart.promise;
      const getOptions = { headers: { Accept: "application/vnd.ipfs.ipns-record" }, signal };
      const res = await fetch(resource, getOptions);
      log7("getIPNS GET %s %d", resource, res.status);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("GET ipns response had no body", "ERR_BAD_RESPONSE");
      }
      const buf3 = await res.arrayBuffer();
      const body = new Uint8Array(buf3, 0, buf3.byteLength);
      if (options2.validate !== false) {
        await ipnsValidator(peerIdToRoutingKey(peerId2), body);
      }
      return unmarshal(body);
    } catch (err) {
      log7.error("getIPNS GET %s error:", resource, err);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log7("getIPNS finished: %c", peerId2);
    }
  }
  async putIPNS(peerId2, record, options2 = {}) {
    log7("putIPNS starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal3([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners2(Infinity, timeoutSignal, signal);
    const onStart = pDefer5();
    const onFinish = pDefer5();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${peerId2.toCID().toString()}`;
    try {
      await onStart.promise;
      const body = marshal(record);
      const getOptions = { method: "PUT", headers: { "Content-Type": "application/vnd.ipfs.ipns-record" }, body, signal };
      const res = await fetch(resource, getOptions);
      log7("putIPNS PUT %s %d", resource, res.status);
      if (res.status !== 200) {
        throw new CodeError("PUT ipns response had status other than 200", "ERR_BAD_RESPONSE");
      }
    } catch (err) {
      log7.error("putIPNS PUT %s error:", resource, err.stack);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log7("putIPNS finished: %c", peerId2);
    }
  }
  #conformToPeerSchema(record) {
    const protocols = [];
    const multiaddrs = record.Addrs?.map(multiaddr) ?? [];
    if (record.Protocols != null) {
      protocols.push(...record.Protocols);
    }
    if (record.Protocol != null) {
      protocols.push(record.Protocol);
      delete record.Protocol;
    }
    return {
      ...record,
      Schema: "peer",
      ID: peerIdFromString(record.ID),
      Addrs: multiaddrs,
      Protocols: protocols
    };
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js
function createDelegatedRoutingV1HttpApiClient(url, init = {}) {
  return new DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports11 = {};
__export(base10_exports11, {
  base10: () => base1011
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bytes.js
var empty14 = new Uint8Array(0);
function equals30(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce14(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString21(str) {
  return new TextEncoder().encode(str);
}
function toString21(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/vendor/base-x.js
function base17(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src13 = base17;
var _brrp__multiformats_scope_baseX13 = src13;
var base_x_default14 = _brrp__multiformats_scope_baseX13;

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base.js
var Encoder14 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder14 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or15(this, decoder);
  }
};
var ComposedDecoder14 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or15(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or15(left, right) {
  return new ComposedDecoder14({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec14 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder14(name29, prefix, baseEncode);
    this.decoder = new Decoder14(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from24({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec14(name29, prefix, encode116, decode144);
}
function baseX13({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default14(alphabet27, name29);
  return from24({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce14(decode144(text))
  });
}
function decode60(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode49(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464814({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from24({
    prefix,
    name: name29,
    encode(input) {
      return encode49(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode60(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base10.js
var base1011 = baseX13({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports11 = {};
__export(base16_exports11, {
  base16: () => base1611,
  base16upper: () => base16upper11
});
var base1611 = rfc464814({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper11 = rfc464814({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports11 = {};
__export(base2_exports11, {
  base2: () => base211
});
var base211 = rfc464814({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports11 = {};
__export(base256emoji_exports11, {
  base256emoji: () => base256emoji11
});
var alphabet11 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars11 = alphabet11.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes11 = alphabet11.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode50(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars11[c];
    return p;
  }, "");
}
function decode61(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes11[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji11 = from24({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode50,
  decode: decode61
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports11 = {};
__export(base32_exports11, {
  base32: () => base3212,
  base32hex: () => base32hex12,
  base32hexpad: () => base32hexpad12,
  base32hexpadupper: () => base32hexpadupper12,
  base32hexupper: () => base32hexupper12,
  base32pad: () => base32pad12,
  base32padupper: () => base32padupper12,
  base32upper: () => base32upper12,
  base32z: () => base32z12
});
var base3212 = rfc464814({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper12 = rfc464814({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad12 = rfc464814({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper12 = rfc464814({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex12 = rfc464814({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper12 = rfc464814({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad12 = rfc464814({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper12 = rfc464814({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z12 = rfc464814({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports11 = {};
__export(base36_exports11, {
  base36: () => base3611,
  base36upper: () => base36upper11
});
var base3611 = baseX13({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper11 = baseX13({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports11 = {};
__export(base58_exports11, {
  base58btc: () => base58btc13,
  base58flickr: () => base58flickr13
});
var base58btc13 = baseX13({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr13 = baseX13({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports11 = {};
__export(base64_exports11, {
  base64: () => base6414,
  base64pad: () => base64pad14,
  base64url: () => base64url14,
  base64urlpad: () => base64urlpad14
});
var base6414 = rfc464814({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad14 = rfc464814({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url14 = rfc464814({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad14 = rfc464814({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports11 = {};
__export(base8_exports11, {
  base8: () => base811
});
var base811 = rfc464814({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports21 = {};
__export(identity_exports21, {
  identity: () => identity21
});
var identity21 = from24({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString21(buf3),
  decode: (str) => fromString21(str)
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder15 = new TextEncoder();
var textDecoder14 = new TextDecoder();

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports22 = {};
__export(identity_exports22, {
  identity: () => identity22
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/vendor/varint.js
var encode_111 = encode51;
var MSB12 = 128;
var REST12 = 127;
var MSBALL11 = ~REST12;
var INT11 = Math.pow(2, 31);
function encode51(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT11) {
    out[offset++] = num & 255 | MSB12;
    num /= 128;
  }
  while (num & MSBALL11) {
    out[offset++] = num & 255 | MSB12;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode51.bytes = offset - oldOffset + 1;
  return out;
}
var decode62 = read12;
var MSB$111 = 128;
var REST$111 = 127;
function read12(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read12.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$111) << shift : (b & REST$111) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$111);
  read12.bytes = counter - offset;
  return res;
}
var N112 = Math.pow(2, 7);
var N212 = Math.pow(2, 14);
var N312 = Math.pow(2, 21);
var N412 = Math.pow(2, 28);
var N512 = Math.pow(2, 35);
var N612 = Math.pow(2, 42);
var N712 = Math.pow(2, 49);
var N811 = Math.pow(2, 56);
var N911 = Math.pow(2, 63);
var length12 = function(value) {
  return value < N112 ? 1 : value < N212 ? 2 : value < N312 ? 3 : value < N412 ? 4 : value < N512 ? 5 : value < N612 ? 6 : value < N712 ? 7 : value < N811 ? 8 : value < N911 ? 9 : 10;
};
var varint11 = {
  encode: encode_111,
  decode: decode62,
  encodingLength: length12
};
var _brrp_varint11 = varint11;
var varint_default11 = _brrp_varint11;

// node_modules/@helia/routers/node_modules/multiformats/dist/src/varint.js
function decode63(data, offset = 0) {
  const code33 = varint_default11.decode(data, offset);
  return [code33, varint_default11.decode.bytes];
}
function encodeTo11(int, target, offset = 0) {
  varint_default11.encode(int, target, offset);
  return target;
}
function encodingLength12(int) {
  return varint_default11.encodingLength(int);
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/digest.js
function create13(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength12(code33);
  const digestOffset = sizeOffset + encodingLength12(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo11(code33, bytes3, 0);
  encodeTo11(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest11(code33, size, digest27, bytes3);
}
function decode64(multihash) {
  const bytes3 = coerce14(multihash);
  const [code33, sizeOffset] = decode63(bytes3);
  const [size, digestOffset] = decode63(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest11(code33, size, digest27, bytes3);
}
function equals31(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals30(a.bytes, data.bytes);
  }
}
var Digest11 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/identity.js
var code16 = 0;
var name11 = "identity";
var encode52 = coerce14;
function digest11(input) {
  return create13(code16, encode52(input));
}
var identity22 = { code: code16, name: name11, encode: encode52, digest: digest11 };

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports11 = {};
__export(sha2_browser_exports11, {
  sha256: () => sha25612,
  sha512: () => sha51212
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/hasher.js
function from25({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher11(name29, code33, encode116);
}
var Hasher11 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create13(this.code, result) : result.then((digest27) => create13(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha11(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25612 = from25({
  name: "sha2-256",
  code: 18,
  encode: sha11("SHA-256")
});
var sha51212 = from25({
  name: "sha2-512",
  code: 19,
  encode: sha11("SHA-512")
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/cid.js
function format11(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV011(bytes3, baseCache11(link), base45 ?? base58btc13.encoder);
    default:
      return toStringV111(bytes3, baseCache11(link), base45 ?? base3212.encoder);
  }
}
var cache12 = /* @__PURE__ */ new WeakMap();
function baseCache11(cid) {
  const baseCache28 = cache12.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache12.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID11 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE11) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE11) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create13(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals31(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format11(this, base45);
  }
  toJSON() {
    return { "/": format11(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID11(version3, code33, multihash.bytes));
    } else if (value[cidSymbol11] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode64(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE11) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE11}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID11(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE11, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce14(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest11(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode63(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE11;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes11(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache11(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes11(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc13;
      return [
        base58btc13.prefix,
        decoder.decode(`${base58btc13.prefix}${source}`)
      ];
    }
    case base58btc13.prefix: {
      const decoder = base45 ?? base58btc13;
      return [base58btc13.prefix, decoder.decode(source)];
    }
    case base3212.prefix: {
      const decoder = base45 ?? base3212;
      return [base3212.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV011(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc13.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV111(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE11 = 112;
var SHA_256_CODE11 = 18;
function encodeCID11(version3, code33, multihash) {
  const codeOffset = encodingLength12(version3);
  const hashOffset = codeOffset + encodingLength12(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo11(version3, bytes3, 0);
  encodeTo11(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol11 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/routers/node_modules/multiformats/dist/src/basics.js
var bases11 = { ...identity_exports21, ...base2_exports11, ...base8_exports11, ...base10_exports11, ...base16_exports11, ...base32_exports11, ...base36_exports11, ...base58_exports11, ...base64_exports11, ...base256emoji_exports11 };
var hashes11 = { ...sha2_browser_exports11, ...identity_exports22 };

// node_modules/@helia/routers/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe14(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@helia/routers/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec12(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string12 = createCodec12("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii11 = createCodec12("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe14(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES11 = {
  utf8: string12,
  "utf-8": string12,
  hex: bases11.base16,
  latin1: ascii11,
  ascii: ascii11,
  binary: ascii11,
  ...bases11
};
var bases_default11 = BASES11;

// node_modules/@helia/routers/node_modules/uint8arrays/dist/src/from-string.js
function fromString22(string27, encoding = "utf8") {
  const base45 = bases_default11[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@multiformats/uri-to-multiaddr/node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/function-timeout/browser.js
function functionTimeout(function_) {
  const wrappedFunction = (...arguments_) => function_(...arguments_);
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
function isTimeoutError() {
  return false;
}

// node_modules/is-regexp/index.js
var { toString: toString22 } = Object.prototype;
function isRegexp(value) {
  return toString22.call(value) === "[object RegExp]";
}

// node_modules/clone-regexp/index.js
var flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}

// node_modules/super-regex/index.js
function isMatch(regex, string27, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string27), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}

// node_modules/@multiformats/uri-to-multiaddr/node_modules/is-ip/index.js
var maxIPv4Length = 15;
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIPv62(string27) {
  if (string27.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ip_regex_default.v6({ exact: true }), string27, options);
}
function isIPv42(string27) {
  if (string27.length > maxIPv4Length) {
    return false;
  }
  return isMatch(ip_regex_default.v4({ exact: true }), string27, options);
}

// node_modules/@multiformats/uri-to-multiaddr/dist/src/index.js
var portFor = {
  http: "80",
  https: "443",
  ws: "80",
  wss: "443"
};
var BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
function uriToMultiaddr(uriStr, opts) {
  opts = opts ?? {};
  const defaultDnsType = opts.defaultDnsType ?? "dns4";
  const { scheme, hostname, port } = parseUri(uriStr);
  const parts = [
    tupleForHostname(hostname, defaultDnsType),
    tupleForPort(port, scheme),
    tupleForScheme(scheme)
  ];
  const multiaddrStr = "/" + parts.filter((x) => Boolean(x)).reduce((a, b) => a.concat(b), []).join("/");
  return multiaddr(multiaddrStr);
}
function parseUri(uriStr) {
  const [scheme] = uriStr.split(":");
  if (!BROWSER_SCHEMES.includes(scheme)) {
    uriStr = "http" + uriStr.substring(scheme.length);
  }
  let { protocol, hostname, port } = new URL(uriStr);
  if (port == null || port === "") {
    const protocolPort = portForProtocol(scheme);
    if (protocolPort != null) {
      port = protocolPort;
    }
    if (protocolPort == null && protocol === "http:") {
      port = "80";
    }
  }
  return { scheme, hostname, port };
}
function tupleForHostname(hostname, defaultDnsType) {
  if (hostname == null || hostname === "") {
    return void 0;
  }
  if (isIPv42(hostname)) {
    return ["ip4", hostname];
  }
  if (isIPv62(hostname)) {
    return ["ip6", hostname];
  }
  if (hostname[0] === "[") {
    const trimmed = hostname.substring(1, hostname.length - 1);
    if (isIPv62(trimmed)) {
      return ["ip6", trimmed];
    }
  }
  return [defaultDnsType, hostname];
}
function tupleForPort(port, scheme) {
  if (port == null || port === "") {
    return void 0;
  }
  if (scheme === "udp") {
    return ["udp", port];
  }
  return ["tcp", port];
}
function tupleForScheme(scheme) {
  if (scheme.match(/^tcp$|^udp$/) != null) {
    return void 0;
  }
  return [scheme];
}
function portForProtocol(protocol) {
  if (protocol == null || protocol === "" || portFor[protocol] == null) {
    return void 0;
  }
  return portFor[protocol];
}

// node_modules/@helia/routers/node_modules/uint8arrays/dist/src/to-string.js
function toString23(array, encoding = "utf8") {
  const base45 = bases_default11[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@helia/routers/dist/src/http-gateway-routing.js
var DEFAULT_TRUSTLESS_GATEWAYS = [
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://trustless-gateway.link",
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://4everland.io"
];
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
var inspect3 = Symbol.for("nodejs.util.inspect.custom");
var URLPeerId = class {
  type = "url";
  multihash;
  privateKey;
  publicKey;
  url;
  constructor(url) {
    this.url = url.toString();
    this.multihash = identity22.digest(fromString22(this.url));
  }
  [inspect3]() {
    return `PeerId(${this.url})`;
  }
  [peerIdSymbol] = true;
  toString() {
    return this.toCID().toString();
  }
  toCID() {
    return CID11.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE2, this.multihash);
  }
  toBytes() {
    return this.toCID().bytes;
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString23(other);
    }
    return other.toString() === this.toString();
  }
};
function toPeerInfo(url) {
  url = url.toString();
  return {
    id: new URLPeerId(new URL(url)),
    multiaddrs: [
      uriToMultiaddr(url)
    ]
  };
}
var HTTPGatwayRouter = class {
  gateways;
  constructor(init = {}) {
    this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS).map((url) => toPeerInfo(url));
  }
  async *findProviders(cid, options2) {
    yield* this.gateways.toSorted(() => Math.random() > 0.5 ? 1 : -1).map((info) => ({
      ...info,
      protocols: ["transport-ipfs-gateway-http"]
    }));
  }
};
function httpGatewayRouting(init = {}) {
  return new HTTPGatwayRouter(init);
}

// node_modules/@helia/routers/dist/src/libp2p-routing.js
var Libp2pRouter = class {
  libp2p;
  constructor(libp2p) {
    this.libp2p = libp2p;
  }
  async provide(cid, options2) {
    await this.libp2p.contentRouting.provide(cid, options2);
  }
  async *findProviders(cid, options2) {
    yield* this.libp2p.contentRouting.findProviders(cid, options2);
  }
  async put(key, value, options2) {
    await this.libp2p.contentRouting.put(key, value, options2);
  }
  async get(key, options2) {
    return this.libp2p.contentRouting.get(key, options2);
  }
  async findPeer(peerId2, options2) {
    return this.libp2p.peerRouting.findPeer(peerId2, options2);
  }
  async *getClosestPeers(key, options2) {
    yield* this.libp2p.peerRouting.getClosestPeers(key, options2);
  }
};
function libp2pRouting(libp2p) {
  return new Libp2pRouter(libp2p);
}

// node_modules/helia/node_modules/blockstore-core/dist/src/errors.js
var errors_exports3 = {};
__export(errors_exports3, {
  abortedError: () => abortedError2,
  closeFailedError: () => closeFailedError2,
  deleteFailedError: () => deleteFailedError2,
  getFailedError: () => getFailedError2,
  hasFailedError: () => hasFailedError2,
  notFoundError: () => notFoundError2,
  openFailedError: () => openFailedError2,
  putFailedError: () => putFailedError2
});
var import_err_code5 = __toESM(require_err_code(), 1);
function openFailedError2(err) {
  err = err ?? new Error("Open failed");
  return (0, import_err_code5.default)(err, "ERR_OPEN_FAILED");
}
function closeFailedError2(err) {
  err = err ?? new Error("Close failed");
  return (0, import_err_code5.default)(err, "ERR_CLOSE_FAILED");
}
function putFailedError2(err) {
  err = err ?? new Error("Put failed");
  return (0, import_err_code5.default)(err, "ERR_PUT_FAILED");
}
function getFailedError2(err) {
  err = err ?? new Error("Get failed");
  return (0, import_err_code5.default)(err, "ERR_GET_FAILED");
}
function deleteFailedError2(err) {
  err = err ?? new Error("Delete failed");
  return (0, import_err_code5.default)(err, "ERR_DELETE_FAILED");
}
function hasFailedError2(err) {
  err = err ?? new Error("Has failed");
  return (0, import_err_code5.default)(err, "ERR_HAS_FAILED");
}
function notFoundError2(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code5.default)(err, "ERR_NOT_FOUND");
}
function abortedError2(err) {
  err = err ?? new Error("Aborted");
  return (0, import_err_code5.default)(err, "ERR_ABORTED");
}

// node_modules/helia/node_modules/blockstore-core/dist/src/base.js
var BaseBlockstore2 = class {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options2);
      yield cid;
    }
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
};

// node_modules/helia/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports12 = {};
__export(base32_exports12, {
  base32: () => base3213,
  base32hex: () => base32hex13,
  base32hexpad: () => base32hexpad13,
  base32hexpadupper: () => base32hexpadupper13,
  base32hexupper: () => base32hexupper13,
  base32pad: () => base32pad13,
  base32padupper: () => base32padupper13,
  base32upper: () => base32upper13,
  base32z: () => base32z13
});

// node_modules/helia/node_modules/multiformats/dist/src/bytes.js
var empty15 = new Uint8Array(0);
function equals32(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce15(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString23(str) {
  return new TextEncoder().encode(str);
}
function toString24(b) {
  return new TextDecoder().decode(b);
}

// node_modules/helia/node_modules/multiformats/dist/src/vendor/base-x.js
function base18(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src14 = base18;
var _brrp__multiformats_scope_baseX14 = src14;
var base_x_default15 = _brrp__multiformats_scope_baseX14;

// node_modules/helia/node_modules/multiformats/dist/src/bases/base.js
var Encoder15 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder15 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or16(this, decoder);
  }
};
var ComposedDecoder15 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or16(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or16(left, right) {
  return new ComposedDecoder15({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec15 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder15(name29, prefix, baseEncode);
    this.decoder = new Decoder15(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from26({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec15(name29, prefix, encode116, decode144);
}
function baseX14({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default15(alphabet27, name29);
  return from26({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce15(decode144(text))
  });
}
function decode65(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode53(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464815({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from26({
    prefix,
    name: name29,
    encode(input) {
      return encode53(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode65(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/helia/node_modules/multiformats/dist/src/bases/base32.js
var base3213 = rfc464815({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper13 = rfc464815({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad13 = rfc464815({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper13 = rfc464815({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex13 = rfc464815({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper13 = rfc464815({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad13 = rfc464815({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper13 = rfc464815({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z13 = rfc464815({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports12 = {};
__export(base58_exports12, {
  base58btc: () => base58btc14,
  base58flickr: () => base58flickr14
});
var base58btc14 = baseX14({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr14 = baseX14({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/helia/node_modules/multiformats/dist/src/vendor/varint.js
var encode_112 = encode54;
var MSB13 = 128;
var REST13 = 127;
var MSBALL12 = ~REST13;
var INT12 = Math.pow(2, 31);
function encode54(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT12) {
    out[offset++] = num & 255 | MSB13;
    num /= 128;
  }
  while (num & MSBALL12) {
    out[offset++] = num & 255 | MSB13;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode54.bytes = offset - oldOffset + 1;
  return out;
}
var decode66 = read13;
var MSB$112 = 128;
var REST$112 = 127;
function read13(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read13.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$112) << shift : (b & REST$112) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$112);
  read13.bytes = counter - offset;
  return res;
}
var N113 = Math.pow(2, 7);
var N213 = Math.pow(2, 14);
var N313 = Math.pow(2, 21);
var N413 = Math.pow(2, 28);
var N513 = Math.pow(2, 35);
var N613 = Math.pow(2, 42);
var N713 = Math.pow(2, 49);
var N812 = Math.pow(2, 56);
var N912 = Math.pow(2, 63);
var length13 = function(value) {
  return value < N113 ? 1 : value < N213 ? 2 : value < N313 ? 3 : value < N413 ? 4 : value < N513 ? 5 : value < N613 ? 6 : value < N713 ? 7 : value < N812 ? 8 : value < N912 ? 9 : 10;
};
var varint12 = {
  encode: encode_112,
  decode: decode66,
  encodingLength: length13
};
var _brrp_varint12 = varint12;
var varint_default12 = _brrp_varint12;

// node_modules/helia/node_modules/multiformats/dist/src/varint.js
function decode67(data, offset = 0) {
  const code33 = varint_default12.decode(data, offset);
  return [code33, varint_default12.decode.bytes];
}
function encodeTo12(int, target, offset = 0) {
  varint_default12.encode(int, target, offset);
  return target;
}
function encodingLength13(int) {
  return varint_default12.encodingLength(int);
}

// node_modules/helia/node_modules/multiformats/dist/src/hashes/digest.js
function create14(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength13(code33);
  const digestOffset = sizeOffset + encodingLength13(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo12(code33, bytes3, 0);
  encodeTo12(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest12(code33, size, digest27, bytes3);
}
function decode68(multihash) {
  const bytes3 = coerce15(multihash);
  const [code33, sizeOffset] = decode67(bytes3);
  const [size, digestOffset] = decode67(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest12(code33, size, digest27, bytes3);
}
function equals33(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals32(a.bytes, data.bytes);
  }
}
var Digest12 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/helia/node_modules/multiformats/dist/src/cid.js
function format12(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV012(bytes3, baseCache12(link), base45 ?? base58btc14.encoder);
    default:
      return toStringV112(bytes3, baseCache12(link), base45 ?? base3213.encoder);
  }
}
var cache13 = /* @__PURE__ */ new WeakMap();
function baseCache12(cid) {
  const baseCache28 = cache13.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache13.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID12 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE12) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE12) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create14(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals33(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format12(this, base45);
  }
  toJSON() {
    return { "/": format12(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID12(version3, code33, multihash.bytes));
    } else if (value[cidSymbol12] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode68(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE12) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE12}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID12(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE12, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce15(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest12(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode67(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE12;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes12(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache12(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes12(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc14;
      return [
        base58btc14.prefix,
        decoder.decode(`${base58btc14.prefix}${source}`)
      ];
    }
    case base58btc14.prefix: {
      const decoder = base45 ?? base58btc14;
      return [base58btc14.prefix, decoder.decode(source)];
    }
    case base3213.prefix: {
      const decoder = base45 ?? base3213;
      return [base3213.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV012(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc14.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV112(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE12 = 112;
var SHA_256_CODE12 = 18;
function encodeCID12(version3, code33, multihash) {
  const codeOffset = encodingLength13(version3);
  const hashOffset = codeOffset + encodingLength13(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo12(version3, bytes3, 0);
  encodeTo12(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol12 = Symbol.for("@ipld/js-cid/CID");

// node_modules/helia/node_modules/multiformats/dist/src/codecs/raw.js
var code17 = 85;

// node_modules/helia/node_modules/blockstore-core/dist/src/memory.js
var MemoryBlockstore2 = class extends BaseBlockstore2 {
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(base3213.encode(key.multihash.bytes), val);
    return key;
  }
  get(key) {
    const buf3 = this.data.get(base3213.encode(key.multihash.bytes));
    if (buf3 == null) {
      throw notFoundError2();
    }
    return buf3;
  }
  has(key) {
    return this.data.has(base3213.encode(key.multihash.bytes));
  }
  async delete(key) {
    this.data.delete(base3213.encode(key.multihash.bytes));
  }
  async *getAll() {
    for (const [key, value] of this.data.entries()) {
      yield {
        cid: CID12.createV1(code17, decode68(base3213.decode(key))),
        block: value
      };
    }
  }
};

// node_modules/helia/node_modules/blockstore-core/dist/src/tiered.js
var log8 = logger("blockstore:core:tiered");

// node_modules/helia/node_modules/blockstore-core/dist/src/index.js
var Errors2 = {
  ...errors_exports3
};

// node_modules/datastore-core/dist/src/errors.js
var import_err_code6 = __toESM(require_err_code(), 1);
function notFoundError3(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code6.default)(err, "ERR_NOT_FOUND");
}

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports12 = {};
__export(base10_exports12, {
  base10: () => base1012
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bytes.js
var empty16 = new Uint8Array(0);
function equals34(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce16(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString24(str) {
  return new TextEncoder().encode(str);
}
function toString25(b) {
  return new TextDecoder().decode(b);
}

// node_modules/datastore-core/node_modules/multiformats/dist/src/vendor/base-x.js
function base19(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src15 = base19;
var _brrp__multiformats_scope_baseX15 = src15;
var base_x_default16 = _brrp__multiformats_scope_baseX15;

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base.js
var Encoder16 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder16 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or17(this, decoder);
  }
};
var ComposedDecoder16 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or17(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or17(left, right) {
  return new ComposedDecoder16({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec16 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder16(name29, prefix, baseEncode);
    this.decoder = new Decoder16(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from27({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec16(name29, prefix, encode116, decode144);
}
function baseX15({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default16(alphabet27, name29);
  return from27({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce16(decode144(text))
  });
}
function decode69(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode55(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464816({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from27({
    prefix,
    name: name29,
    encode(input) {
      return encode55(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode69(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base10.js
var base1012 = baseX15({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports12 = {};
__export(base16_exports12, {
  base16: () => base1612,
  base16upper: () => base16upper12
});
var base1612 = rfc464816({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper12 = rfc464816({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports12 = {};
__export(base2_exports12, {
  base2: () => base212
});
var base212 = rfc464816({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports12 = {};
__export(base256emoji_exports12, {
  base256emoji: () => base256emoji12
});
var alphabet12 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars12 = alphabet12.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes12 = alphabet12.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode56(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars12[c];
    return p;
  }, "");
}
function decode70(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes12[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji12 = from27({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode56,
  decode: decode70
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports13 = {};
__export(base32_exports13, {
  base32: () => base3214,
  base32hex: () => base32hex14,
  base32hexpad: () => base32hexpad14,
  base32hexpadupper: () => base32hexpadupper14,
  base32hexupper: () => base32hexupper14,
  base32pad: () => base32pad14,
  base32padupper: () => base32padupper14,
  base32upper: () => base32upper14,
  base32z: () => base32z14
});
var base3214 = rfc464816({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper14 = rfc464816({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad14 = rfc464816({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper14 = rfc464816({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex14 = rfc464816({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper14 = rfc464816({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad14 = rfc464816({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper14 = rfc464816({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z14 = rfc464816({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports12 = {};
__export(base36_exports12, {
  base36: () => base3612,
  base36upper: () => base36upper12
});
var base3612 = baseX15({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper12 = baseX15({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports13 = {};
__export(base58_exports13, {
  base58btc: () => base58btc15,
  base58flickr: () => base58flickr15
});
var base58btc15 = baseX15({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr15 = baseX15({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports12 = {};
__export(base64_exports12, {
  base64: () => base6415,
  base64pad: () => base64pad15,
  base64url: () => base64url15,
  base64urlpad: () => base64urlpad15
});
var base6415 = rfc464816({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad15 = rfc464816({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url15 = rfc464816({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad15 = rfc464816({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports12 = {};
__export(base8_exports12, {
  base8: () => base812
});
var base812 = rfc464816({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports23 = {};
__export(identity_exports23, {
  identity: () => identity23
});
var identity23 = from27({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString25(buf3),
  decode: (str) => fromString24(str)
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder16 = new TextEncoder();
var textDecoder15 = new TextDecoder();

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports24 = {};
__export(identity_exports24, {
  identity: () => identity24
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/vendor/varint.js
var encode_113 = encode57;
var MSB14 = 128;
var REST14 = 127;
var MSBALL13 = ~REST14;
var INT13 = Math.pow(2, 31);
function encode57(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT13) {
    out[offset++] = num & 255 | MSB14;
    num /= 128;
  }
  while (num & MSBALL13) {
    out[offset++] = num & 255 | MSB14;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode57.bytes = offset - oldOffset + 1;
  return out;
}
var decode71 = read14;
var MSB$113 = 128;
var REST$113 = 127;
function read14(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read14.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$113) << shift : (b & REST$113) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$113);
  read14.bytes = counter - offset;
  return res;
}
var N114 = Math.pow(2, 7);
var N214 = Math.pow(2, 14);
var N314 = Math.pow(2, 21);
var N414 = Math.pow(2, 28);
var N514 = Math.pow(2, 35);
var N614 = Math.pow(2, 42);
var N714 = Math.pow(2, 49);
var N813 = Math.pow(2, 56);
var N913 = Math.pow(2, 63);
var length14 = function(value) {
  return value < N114 ? 1 : value < N214 ? 2 : value < N314 ? 3 : value < N414 ? 4 : value < N514 ? 5 : value < N614 ? 6 : value < N714 ? 7 : value < N813 ? 8 : value < N913 ? 9 : 10;
};
var varint13 = {
  encode: encode_113,
  decode: decode71,
  encodingLength: length14
};
var _brrp_varint13 = varint13;
var varint_default13 = _brrp_varint13;

// node_modules/datastore-core/node_modules/multiformats/dist/src/varint.js
function decode72(data, offset = 0) {
  const code33 = varint_default13.decode(data, offset);
  return [code33, varint_default13.decode.bytes];
}
function encodeTo13(int, target, offset = 0) {
  varint_default13.encode(int, target, offset);
  return target;
}
function encodingLength14(int) {
  return varint_default13.encodingLength(int);
}

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/digest.js
function create15(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength14(code33);
  const digestOffset = sizeOffset + encodingLength14(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo13(code33, bytes3, 0);
  encodeTo13(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest13(code33, size, digest27, bytes3);
}
function decode73(multihash) {
  const bytes3 = coerce16(multihash);
  const [code33, sizeOffset] = decode72(bytes3);
  const [size, digestOffset] = decode72(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest13(code33, size, digest27, bytes3);
}
function equals35(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals34(a.bytes, data.bytes);
  }
}
var Digest13 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/identity.js
var code18 = 0;
var name12 = "identity";
var encode58 = coerce16;
function digest12(input) {
  return create15(code18, encode58(input));
}
var identity24 = { code: code18, name: name12, encode: encode58, digest: digest12 };

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports12 = {};
__export(sha2_browser_exports12, {
  sha256: () => sha25613,
  sha512: () => sha51213
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/hasher.js
function from28({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher12(name29, code33, encode116);
}
var Hasher12 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create15(this.code, result) : result.then((digest27) => create15(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/datastore-core/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha12(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25613 = from28({
  name: "sha2-256",
  code: 18,
  encode: sha12("SHA-256")
});
var sha51213 = from28({
  name: "sha2-512",
  code: 19,
  encode: sha12("SHA-512")
});

// node_modules/datastore-core/node_modules/multiformats/dist/src/cid.js
function format13(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV013(bytes3, baseCache13(link), base45 ?? base58btc15.encoder);
    default:
      return toStringV113(bytes3, baseCache13(link), base45 ?? base3214.encoder);
  }
}
var cache14 = /* @__PURE__ */ new WeakMap();
function baseCache13(cid) {
  const baseCache28 = cache14.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache14.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID13 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE13) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE13) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create15(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals35(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format13(this, base45);
  }
  toJSON() {
    return { "/": format13(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID13(version3, code33, multihash.bytes));
    } else if (value[cidSymbol13] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode73(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE13) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE13}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID13(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE13, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce16(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest13(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode72(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE13;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes13(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache13(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes13(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc15;
      return [
        base58btc15.prefix,
        decoder.decode(`${base58btc15.prefix}${source}`)
      ];
    }
    case base58btc15.prefix: {
      const decoder = base45 ?? base58btc15;
      return [base58btc15.prefix, decoder.decode(source)];
    }
    case base3214.prefix: {
      const decoder = base45 ?? base3214;
      return [base3214.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV013(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc15.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV113(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE13 = 112;
var SHA_256_CODE13 = 18;
function encodeCID13(version3, code33, multihash) {
  const codeOffset = encodingLength14(version3);
  const hashOffset = codeOffset + encodingLength14(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo13(version3, bytes3, 0);
  encodeTo13(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol13 = Symbol.for("@ipld/js-cid/CID");

// node_modules/datastore-core/node_modules/multiformats/dist/src/basics.js
var bases12 = { ...identity_exports23, ...base2_exports12, ...base8_exports12, ...base10_exports12, ...base16_exports12, ...base32_exports13, ...base36_exports12, ...base58_exports13, ...base64_exports12, ...base256emoji_exports12 };
var hashes12 = { ...sha2_browser_exports12, ...identity_exports24 };

// node_modules/datastore-core/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe15(size = 0) {
  return new Uint8Array(size);
}

// node_modules/datastore-core/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec13(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string13 = createCodec13("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii12 = createCodec13("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe15(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES12 = {
  utf8: string13,
  "utf-8": string13,
  hex: bases12.base16,
  latin1: ascii12,
  ascii: ascii12,
  binary: ascii12,
  ...bases12
};
var bases_default12 = BASES12;

// node_modules/datastore-core/node_modules/uint8arrays/dist/src/from-string.js
function fromString25(string27, encoding = "utf8") {
  const base45 = bases_default12[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/datastore-core/node_modules/uint8arrays/dist/src/to-string.js
function toString26(array, encoding = "utf8") {
  const base45 = bases_default12[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/datastore-core/node_modules/interface-datastore/dist/src/key.js
var pathSepS3 = "/";
var pathSepB3 = new TextEncoder().encode(pathSepS3);
var pathSep3 = pathSepB3[0];
var Key3 = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString25(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep3) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString26(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS3));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB3;
    }
    if (this._buf[0] !== pathSep3) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep3, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep3) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS3).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType2(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue2(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS3)) {
      p += pathSepS3;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS3);
    }
    return new _Key(list.slice(0, -1).join(pathSepS3));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS3) {
      return key;
    } else if (key.toString() === pathSepS3) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten2(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType2(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue2(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten2(arr) {
  return [].concat(...arr);
}

// node_modules/datastore-core/dist/src/shard.js
var SHARDING_FN = "SHARDING";

// node_modules/datastore-core/node_modules/it-drain/dist/src/index.js
function isAsyncIterable12(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain3(source) {
  if (isAsyncIterable12(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default19 = drain3;

// node_modules/datastore-core/node_modules/it-peekable/dist/src/index.js
function peekable5(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default20 = peekable5;

// node_modules/datastore-core/node_modules/it-filter/dist/src/index.js
function isAsyncIterable13(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter2(source, fn) {
  let index = 0;
  if (isAsyncIterable13(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable8 = src_default20(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable8) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func2 = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable8) {
      if (func2(entry, index++)) {
        yield entry;
      }
    }
  }();
}
var src_default21 = filter2;

// node_modules/it-sort/node_modules/it-all/dist/src/index.js
function isAsyncIterable14(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable14(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default22 = all;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable15(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable15(source)) {
    return async function* () {
      const arr = await src_default22(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default22(source);
    yield* arr.sort(sorter);
  }();
}
var src_default23 = sort;

// node_modules/datastore-core/node_modules/it-take/dist/src/index.js
function isAsyncIterable16(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take2(source, limit) {
  if (isAsyncIterable16(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default24 = take2;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options2 = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options2);
      yield key;
    }
  }
  async *getMany(source, options2 = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options2)
      };
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options2) => {
        await src_default19(this.putMany(puts, options2));
        puts = [];
        await src_default19(this.deleteMany(dels, options2));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options2) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options2) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options2) {
    let it = this._all(q, options2);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default21(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default21(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default23(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default21(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default24(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options2) {
    let it = this._allKeys(q, options2);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default21(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default21(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default23(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default21(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default24(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw notFoundError3();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key3(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key3(key);
    }
  }
};

// node_modules/datastore-core/dist/src/sharding.js
var shardKey = new Key3(SHARDING_FN);

// node_modules/datastore-core/dist/src/tiered.js
var log9 = logger("datastore:core:tiered");

// node_modules/helia/dist/src/helia-p2p.js
var HeliaP2P = class extends Helia {
  libp2p;
  constructor(init) {
    super({
      ...init,
      components: {
        libp2p: init.libp2p
      }
    });
    this.libp2p = init.libp2p;
  }
  async start() {
    await super.start();
    await this.libp2p.start();
  }
  async stop() {
    await super.stop();
    await this.libp2p.stop();
  }
};

// node_modules/it-queueless-pushable/node_modules/p-defer/index.js
function pDefer6() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  readNext;
  haveNext;
  ended;
  nextResult;
  constructor() {
    this.ended = false;
    this.readNext = pDefer6();
    this.haveNext = pDefer6();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer6();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    await this._push(void 0);
    return result;
  }
  async push(value, options2) {
    await this._push(value, options2);
  }
  async end(err, options2) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options2);
    }
  }
  async _push(value, options2) {
    if (value != null && this.ended) {
      throw new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer6();
    await raceSignal(this.readNext.promise, options2?.signal, options2);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

// node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError2 = class extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// node_modules/it-byte-stream/dist/src/index.js
var CodeError3 = class extends Error {
  code;
  constructor(message2, code33) {
    super(message2);
    this.code = code33;
  }
};
var AbortError6 = class extends CodeError3 {
  type;
  constructor(message2) {
    super(message2, "ABORT_ERR");
    this.type = "aborted";
    this.name = "AbortError";
  }
};
function byteStream(duplex, opts) {
  const write3 = queuelessPushable();
  duplex.sink(write3).catch(async (err) => {
    await write3.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf3 of source2) {
      await write3.push(buf3);
    }
    await write3.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes3, options2) => {
      options2?.signal?.throwIfAborted();
      let listener;
      const abortPromise = new Promise((resolve, reject) => {
        listener = () => {
          reject(new AbortError6("Read aborted"));
        };
        options2?.signal?.addEventListener("abort", listener);
      });
      try {
        if (bytes3 == null) {
          const { done, value } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            return new Uint8ArrayList();
          }
          return value;
        }
        while (readBuffer.byteLength < bytes3) {
          const { value, done } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            throw new UnexpectedEOFError2("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf3 = readBuffer.sublist(0, bytes3);
        readBuffer.consume(bytes3);
        return buf3;
      } finally {
        if (listener != null) {
          options2?.signal?.removeEventListener("abort", listener);
        }
      }
    },
    write: async (data, options2) => {
      options2?.signal?.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write3.push(data, options2);
      } else {
        await write3.push(data.subarray(), options2);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if (opts?.yieldBytes === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError2 = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError2 = class extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError2 = class extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};

// node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes3 = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = opts?.lengthDecoder ?? decode;
  const encodeLength = opts?.lengthEncoder ?? encode;
  const W = {
    read: async (options2) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes3.read(1, options2));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError2("Invalid message length");
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError2("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError2("message length too long");
      }
      return bytes3.read(dataLength, options2);
    },
    write: async (data, options2) => {
      await bytes3.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options2);
    },
    writeV: async (data, options2) => {
      const list = new Uint8ArrayList(...data.flatMap((buf3) => [encodeLength(buf3.byteLength), buf3]));
      await bytes3.write(list, options2);
    },
    unwrap: () => {
      return bytes3.unwrap();
    }
  };
  return W;
}

// node_modules/it-pair/node_modules/p-defer/index.js
function pDefer7() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer7();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}

// node_modules/@chainsafe/libp2p-noise/node_modules/it-pipe/dist/src/index.js
function pipe3(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex2(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable2(first4) || isAsyncIterable17(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex2(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex2(fns[i])) {
        fns[i] = duplexPipelineFn2(fns[i]);
      }
    }
  }
  return rawPipe2(...fns);
}
var rawPipe2 = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable17 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable2 = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex2 = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn2 = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable17(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable2(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/alloc.js
function alloc8(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe16(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

// node_modules/@noble/ciphers/esm/_assert.js
function number3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes2(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/ciphers/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error(`string expected, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes5(data);
  else if (isBytes3(data))
    data = copyBytes(data);
  else
    throw new Error(`Uint8Array expected, got ${typeof data}`);
  return data;
}
function checkOpts2(defaults2, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function copyBytes(bytes3) {
  return Uint8Array.from(bytes3);
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}

// node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
var sigma16 = _utf8ToBytes("expand 16-byte k");
var sigma32 = _utf8ToBytes("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
var sigma = sigma32_32.slice();
function rotl2(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma2, key, nonce, data, output3, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output3);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output3) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma2, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take4 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take4 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take4; j++) {
      posj = pos + j;
      output3[posj] = data[posj] ^ block[j];
    }
    pos += take4;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number3(counterLength);
  number3(rounds);
  bool(counterRight);
  bool(allowShortKeys);
  return (key, nonce, data, output3, counter = 0) => {
    bytes2(key);
    bytes2(nonce);
    bytes2(data);
    const len = data.length;
    if (output3 === void 0)
      output3 = new Uint8Array(len);
    bytes2(output3);
    number3(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output3.length < len)
      throw new Error(`arx: output (${output3.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma2;
    if (l === 32) {
      toClean.push(k = copyBytes(key));
      sigma2 = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma2 = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce))
      toClean.push(nonce = copyBytes(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma2, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma2, k32, n32, data, output3, counter, rounds);
    clean(...toClean);
    return output3;
  };
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes3(key);
    bytes2(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h: h2, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h2[0] + (t0 & 8191);
    let h1 = h2[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h22 = h2[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h2[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h2[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h2[5] + (t4 >>> 1 & 8191);
    let h6 = h2[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h2[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h2[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h2[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h22 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h22 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h22 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h22 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h22 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h22 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h22 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h22 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h22 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h22 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h2[0] = d0;
    h2[1] = d1;
    h2[2] = d2;
    h2[3] = d3;
    h2[4] = d4;
    h2[5] = d5;
    h2[6] = d6;
    h2[7] = d7;
    h2[8] = d8;
    h2[9] = d9;
  }
  finalize() {
    const { h: h2, pad } = this;
    const g = new Uint16Array(10);
    let c = h2[1] >>> 13;
    h2[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h2[i] += c;
      c = h2[i] >>> 13;
      h2[i] &= 8191;
    }
    h2[0] += c * 5;
    c = h2[0] >>> 13;
    h2[0] &= 8191;
    h2[1] += c;
    c = h2[1] >>> 13;
    h2[1] &= 8191;
    h2[2] += c;
    g[0] = h2[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h2[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h2[i] = h2[i] & mask | g[i];
    h2[0] = (h2[0] | h2[1] << 13) & 65535;
    h2[1] = (h2[1] >>> 3 | h2[2] << 10) & 65535;
    h2[2] = (h2[2] >>> 6 | h2[3] << 7) & 65535;
    h2[3] = (h2[3] >>> 9 | h2[4] << 4) & 65535;
    h2[4] = (h2[4] >>> 12 | h2[5] << 1 | h2[6] << 14) & 65535;
    h2[5] = (h2[6] >>> 2 | h2[7] << 11) & 65535;
    h2[6] = (h2[7] >>> 5 | h2[8] << 8) & 65535;
    h2[7] = (h2[8] >>> 8 | h2[9] << 5) & 65535;
    let f = h2[0] + pad[0];
    h2[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h2[i] + pad[i] | 0) + (f >>> 16) | 0;
      h2[i] = f & 65535;
    }
    clean(g);
  }
  update(data) {
    exists2(this);
    const { buffer: buffer3, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take4 = Math.min(blockLen - this.pos, len - pos);
      if (take4 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take4), this.pos);
      this.pos += take4;
      pos += take4;
      if (this.pos === blockLen) {
        this.process(buffer3, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer: buffer3, h: h2 } = this;
    let { pos } = this;
    if (pos) {
      buffer3[pos++] = 1;
      for (; pos < 16; pos++)
        buffer3[pos] = 0;
      this.process(buffer3, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h2[i] >>> 0;
      out[opos++] = h2[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s2, k, n, out, cnt, rounds = 20) {
  let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s2, k, i, o32) {
  let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h2, msg) => {
  h2.update(msg);
  const left = msg.length % 16;
  if (left)
    h2.update(ZEROS16.subarray(left));
};
var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h2 = poly1305.create(authKey);
  if (AAD)
    updatePadded(h2, AAD);
  updatePadded(h2, data);
  const num = new Uint8Array(16);
  const view = createView2(num);
  setBigUint642(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint642(view, 8, BigInt(data.length), true);
  h2.update(num);
  const res = h2.digest();
  clean(authKey, num);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  bytes2(key, 32);
  bytes2(nonce);
  return {
    encrypt(plaintext, output3) {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output3) {
        bytes2(output3, clength);
      } else {
        output3 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output3, 1);
      const tag = computeTag(xorStream, key, nonce, output3.subarray(0, -tagLength), AAD);
      output3.set(tag, plength);
      clean(tag);
      return output3;
    },
    decrypt(ciphertext, output3) {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output3) {
        bytes2(output3, plength);
      } else {
        output3 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output3, 1);
      clean(tag);
      return output3;
    }
  };
};
var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash2, ikm, salt) {
  hash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER2 = /* @__PURE__ */ new Uint8Array();
function expand(hash2, prk, info, length30 = 32) {
  hash(hash2);
  number(length30);
  if (length30 > 255 * hash2.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length30 / hash2.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER2;
  const okm = new Uint8Array(blocks * hash2.outputLen);
  const HMAC2 = hmac.create(hash2, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER2 : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash2.outputLen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length30);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha2564(data.subarray());
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha2564, ikm, ck);
    const okmU8Array = expand(sha2564, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomPrivateKey();
    const publicKey = x25519.getPublicKey(secretKey);
    return {
      publicKey,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey = x25519.getPublicKey(seed);
    return {
      publicKey,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray());
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
var defaultCrypto = pureJsCrypto;

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
function wrapCrypto(crypto3) {
  return {
    generateKeypair: crypto3.generateX25519KeyPair,
    dh: (keypair, publicKey) => crypto3.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
    encrypt: crypto3.chaCha20Poly1305Encrypt,
    decrypt: crypto3.chaCha20Poly1305Decrypt,
    hash: crypto3.hashSHA256,
    hkdf: crypto3.getHKDF
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var uint16BEEncode = (value) => {
  const target = allocUnsafe16(2);
  target[0] = value >> 8;
  target[1] = value;
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    let value = 0;
    value += data[0] << 8;
    value += data[1];
    return value;
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;

// node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports13 = {};
__export(base10_exports13, {
  base10: () => base1013
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bytes.js
var empty17 = new Uint8Array(0);
function equals36(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce17(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString26(str) {
  return new TextEncoder().encode(str);
}
function toString27(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/vendor/base-x.js
function base20(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src16 = base20;
var _brrp__multiformats_scope_baseX16 = src16;
var base_x_default17 = _brrp__multiformats_scope_baseX16;

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base.js
var Encoder17 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder17 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or18(this, decoder);
  }
};
var ComposedDecoder17 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or18(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or18(left, right) {
  return new ComposedDecoder17({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec17 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder17(name29, prefix, baseEncode);
    this.decoder = new Decoder17(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from29({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec17(name29, prefix, encode116, decode144);
}
function baseX16({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default17(alphabet27, name29);
  return from29({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce17(decode144(text))
  });
}
function decode74(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode59(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464817({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from29({
    prefix,
    name: name29,
    encode(input) {
      return encode59(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode74(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base10.js
var base1013 = baseX16({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports13 = {};
__export(base16_exports13, {
  base16: () => base1613,
  base16upper: () => base16upper13
});
var base1613 = rfc464817({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper13 = rfc464817({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports13 = {};
__export(base2_exports13, {
  base2: () => base213
});
var base213 = rfc464817({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports13 = {};
__export(base256emoji_exports13, {
  base256emoji: () => base256emoji13
});
var alphabet13 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars13 = alphabet13.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes13 = alphabet13.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode60(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars13[c];
    return p;
  }, "");
}
function decode75(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes13[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji13 = from29({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode60,
  decode: decode75
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports14 = {};
__export(base32_exports14, {
  base32: () => base3215,
  base32hex: () => base32hex15,
  base32hexpad: () => base32hexpad15,
  base32hexpadupper: () => base32hexpadupper15,
  base32hexupper: () => base32hexupper15,
  base32pad: () => base32pad15,
  base32padupper: () => base32padupper15,
  base32upper: () => base32upper15,
  base32z: () => base32z15
});
var base3215 = rfc464817({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper15 = rfc464817({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad15 = rfc464817({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper15 = rfc464817({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex15 = rfc464817({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper15 = rfc464817({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad15 = rfc464817({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper15 = rfc464817({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z15 = rfc464817({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports13 = {};
__export(base36_exports13, {
  base36: () => base3613,
  base36upper: () => base36upper13
});
var base3613 = baseX16({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper13 = baseX16({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports14 = {};
__export(base58_exports14, {
  base58btc: () => base58btc16,
  base58flickr: () => base58flickr16
});
var base58btc16 = baseX16({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr16 = baseX16({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports13 = {};
__export(base64_exports13, {
  base64: () => base6416,
  base64pad: () => base64pad16,
  base64url: () => base64url16,
  base64urlpad: () => base64urlpad16
});
var base6416 = rfc464817({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad16 = rfc464817({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url16 = rfc464817({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad16 = rfc464817({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports13 = {};
__export(base8_exports13, {
  base8: () => base813
});
var base813 = rfc464817({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports25 = {};
__export(identity_exports25, {
  identity: () => identity25
});
var identity25 = from29({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString27(buf3),
  decode: (str) => fromString26(str)
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder17 = new TextEncoder();
var textDecoder16 = new TextDecoder();

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports26 = {};
__export(identity_exports26, {
  identity: () => identity26
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/vendor/varint.js
var encode_114 = encode61;
var MSB15 = 128;
var REST15 = 127;
var MSBALL14 = ~REST15;
var INT14 = Math.pow(2, 31);
function encode61(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT14) {
    out[offset++] = num & 255 | MSB15;
    num /= 128;
  }
  while (num & MSBALL14) {
    out[offset++] = num & 255 | MSB15;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode61.bytes = offset - oldOffset + 1;
  return out;
}
var decode76 = read15;
var MSB$114 = 128;
var REST$114 = 127;
function read15(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read15.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$114) << shift : (b & REST$114) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$114);
  read15.bytes = counter - offset;
  return res;
}
var N115 = Math.pow(2, 7);
var N215 = Math.pow(2, 14);
var N315 = Math.pow(2, 21);
var N415 = Math.pow(2, 28);
var N515 = Math.pow(2, 35);
var N615 = Math.pow(2, 42);
var N715 = Math.pow(2, 49);
var N814 = Math.pow(2, 56);
var N914 = Math.pow(2, 63);
var length15 = function(value) {
  return value < N115 ? 1 : value < N215 ? 2 : value < N315 ? 3 : value < N415 ? 4 : value < N515 ? 5 : value < N615 ? 6 : value < N715 ? 7 : value < N814 ? 8 : value < N914 ? 9 : 10;
};
var varint14 = {
  encode: encode_114,
  decode: decode76,
  encodingLength: length15
};
var _brrp_varint14 = varint14;
var varint_default14 = _brrp_varint14;

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/varint.js
function decode77(data, offset = 0) {
  const code33 = varint_default14.decode(data, offset);
  return [code33, varint_default14.decode.bytes];
}
function encodeTo14(int, target, offset = 0) {
  varint_default14.encode(int, target, offset);
  return target;
}
function encodingLength15(int) {
  return varint_default14.encodingLength(int);
}

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/digest.js
function create16(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength15(code33);
  const digestOffset = sizeOffset + encodingLength15(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo14(code33, bytes3, 0);
  encodeTo14(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest14(code33, size, digest27, bytes3);
}
function decode78(multihash) {
  const bytes3 = coerce17(multihash);
  const [code33, sizeOffset] = decode77(bytes3);
  const [size, digestOffset] = decode77(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest14(code33, size, digest27, bytes3);
}
function equals37(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals36(a.bytes, data.bytes);
  }
}
var Digest14 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/identity.js
var code19 = 0;
var name13 = "identity";
var encode62 = coerce17;
function digest13(input) {
  return create16(code19, encode62(input));
}
var identity26 = { code: code19, name: name13, encode: encode62, digest: digest13 };

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports13 = {};
__export(sha2_browser_exports13, {
  sha256: () => sha25614,
  sha512: () => sha51214
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/hasher.js
function from30({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher13(name29, code33, encode116);
}
var Hasher13 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create16(this.code, result) : result.then((digest27) => create16(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha13(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25614 = from30({
  name: "sha2-256",
  code: 18,
  encode: sha13("SHA-256")
});
var sha51214 = from30({
  name: "sha2-512",
  code: 19,
  encode: sha13("SHA-512")
});

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/cid.js
function format14(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV014(bytes3, baseCache14(link), base45 ?? base58btc16.encoder);
    default:
      return toStringV114(bytes3, baseCache14(link), base45 ?? base3215.encoder);
  }
}
var cache15 = /* @__PURE__ */ new WeakMap();
function baseCache14(cid) {
  const baseCache28 = cache15.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache15.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID14 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE14) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE14) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create16(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals37(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format14(this, base45);
  }
  toJSON() {
    return { "/": format14(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID14(version3, code33, multihash.bytes));
    } else if (value[cidSymbol14] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode78(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE14) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE14}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID14(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE14, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce17(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest14(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode77(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE14;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes14(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache14(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes14(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc16;
      return [
        base58btc16.prefix,
        decoder.decode(`${base58btc16.prefix}${source}`)
      ];
    }
    case base58btc16.prefix: {
      const decoder = base45 ?? base58btc16;
      return [base58btc16.prefix, decoder.decode(source)];
    }
    case base3215.prefix: {
      const decoder = base45 ?? base3215;
      return [base3215.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV014(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc16.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV114(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE14 = 112;
var SHA_256_CODE14 = 18;
function encodeCID14(version3, code33, multihash) {
  const codeOffset = encodingLength15(version3);
  const hashOffset = codeOffset + encodingLength15(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo14(version3, bytes3, 0);
  encodeTo14(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol14 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/basics.js
var bases13 = { ...identity_exports25, ...base2_exports13, ...base8_exports13, ...base10_exports13, ...base16_exports13, ...base32_exports14, ...base36_exports13, ...base58_exports14, ...base64_exports13, ...base256emoji_exports13 };
var hashes13 = { ...sha2_browser_exports13, ...identity_exports26 };

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec14(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string14 = createCodec14("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii13 = createCodec14("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe16(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES13 = {
  utf8: string14,
  "utf-8": string14,
  hex: bases13.base16,
  latin1: ascii13,
  ascii: ascii13,
  binary: ascii13,
  ...bases13
};
var bases_default13 = BASES13;

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/to-string.js
function toString28(array, encoding = "utf8") {
  const base45 = bases_default13[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
function logLocalStaticKeys(s2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (s2) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString28(s2.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString28(s2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local static keys.");
  }
}
function logLocalEphemeralKeys(e, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString28(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString28(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString28(rs.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote static public key.");
  }
}
function logRemoteEphemeralKey(re, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString28(re.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote ephemeral keys.");
  }
}
function logCipherState(cs1, cs2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString28(cs1.k, "hex")}`);
  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString28(cs2.k, "hex")}`);
}

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/equals.js
function equals38(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array5(buf3) {
  return buf3;
}

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/concat.js
function concat8(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe16(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array5(output3);
}

// node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/from-string.js
function fromString27(string27, encoding = "utf8") {
  const base45 = bases_default13[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var UnexpectedPeerError = class _UnexpectedPeerError extends Error {
  code;
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.code = _UnexpectedPeerError.code;
  }
  static code = "ERR_UNEXPECTED_PEER";
};
var InvalidCryptoExchangeError = class _InvalidCryptoExchangeError extends Error {
  code;
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = _InvalidCryptoExchangeError.code;
  }
  static code = "ERR_INVALID_CRYPTO_EXCHANGE";
};

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  n;
  bytes;
  view;
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = alloc8(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
var ZEROLEN = alloc8(0);
var CipherState = class {
  k;
  n;
  crypto;
  constructor(crypto3, k = void 0, n = 0) {
    this.crypto = crypto3;
    this.k = k;
    this.n = new Nonce(n);
  }
  hasKey() {
    return Boolean(this.k);
  }
  encryptWithAd(ad, plaintext) {
    if (!this.hasKey()) {
      return plaintext;
    }
    this.n.assertValue();
    const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
    this.n.increment();
    return e;
  }
  decryptWithAd(ad, ciphertext, dst) {
    if (!this.hasKey()) {
      return ciphertext;
    }
    this.n.assertValue();
    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
    this.n.increment();
    return plaintext;
  }
};
var SymmetricState = class {
  cs;
  ck;
  h;
  crypto;
  constructor(crypto3, protocolName) {
    this.crypto = crypto3;
    const protocolNameBytes = fromString27(protocolName, "utf-8");
    this.h = hashProtocolName(crypto3, protocolNameBytes);
    this.ck = this.h;
    this.cs = new CipherState(crypto3);
  }
  mixKey(ikm) {
    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
    this.ck = ck;
    this.cs = new CipherState(this.crypto, tempK);
  }
  mixHash(data) {
    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
  }
  encryptAndHash(plaintext) {
    const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
    this.mixHash(ciphertext);
    return ciphertext;
  }
  decryptAndHash(ciphertext) {
    const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
    this.mixHash(ciphertext);
    return plaintext;
  }
  split() {
    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
  }
};
var AbstractHandshakeState = class {
  ss;
  s;
  e;
  rs;
  re;
  initiator;
  crypto;
  constructor(init) {
    const { crypto: crypto3, protocolName, prologue, initiator, s: s2, e, rs, re } = init;
    this.crypto = crypto3;
    this.ss = new SymmetricState(crypto3, protocolName);
    this.ss.mixHash(prologue);
    this.initiator = initiator;
    this.s = s2;
    this.e = e;
    this.rs = rs;
    this.re = re;
  }
  writeE() {
    if (this.e) {
      throw new Error("ephemeral keypair is already set");
    }
    const e = this.crypto.generateKeypair();
    this.ss.mixHash(e.publicKey);
    this.e = e;
    return e.publicKey;
  }
  writeS() {
    if (!this.s) {
      throw new Error("static keypair is not set");
    }
    return this.ss.encryptAndHash(this.s.publicKey);
  }
  writeEE() {
    if (!this.e) {
      throw new Error("ephemeral keypair is not set");
    }
    if (!this.re) {
      throw new Error("remote ephemeral public key is not set");
    }
    this.ss.mixKey(this.crypto.dh(this.e, this.re));
  }
  writeES() {
    if (this.initiator) {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    } else {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    }
  }
  writeSE() {
    if (this.initiator) {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    } else {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    }
  }
  readE(message2, offset = 0) {
    if (this.re) {
      throw new Error("remote ephemeral public key is already set");
    }
    if (message2.byteLength < offset + 32) {
      throw new Error("message is not long enough");
    }
    this.re = message2.sublist(offset, offset + 32);
    this.ss.mixHash(this.re);
  }
  readS(message2, offset = 0) {
    if (this.rs) {
      throw new Error("remote static public key is already set");
    }
    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
    if (message2.byteLength < offset + cipherLength) {
      throw new Error("message is not long enough");
    }
    const temp = message2.sublist(offset, offset + cipherLength);
    this.rs = this.ss.decryptAndHash(temp);
    return cipherLength;
  }
  readEE() {
    this.writeEE();
  }
  readES() {
    this.writeES();
  }
  readSE() {
    this.writeSE();
  }
};
var XXHandshakeState = class extends AbstractHandshakeState {
  // e
  writeMessageA(payload) {
    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
  }
  // e, ee, s, es
  writeMessageB(payload) {
    const e = this.writeE();
    this.writeEE();
    const encS = this.writeS();
    this.writeES();
    return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload));
  }
  // s, se
  writeMessageC(payload) {
    const encS = this.writeS();
    this.writeSE();
    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
  }
  // e
  readMessageA(message2) {
    try {
      this.readE(message2);
      return this.ss.decryptAndHash(message2.sublist(32));
    } catch (e) {
      throw new InvalidCryptoExchangeError(`handshake stage 0 validation fail: ${e.message}`);
    }
  }
  // e, ee, s, es
  readMessageB(message2) {
    try {
      this.readE(message2);
      this.readEE();
      const consumed = this.readS(message2, 32);
      this.readES();
      return this.ss.decryptAndHash(message2.sublist(32 + consumed));
    } catch (e) {
      throw new InvalidCryptoExchangeError(`handshake stage 1 validation fail: ${e.message}`);
    }
  }
  // s, se
  readMessageC(message2) {
    try {
      const consumed = this.readS(message2);
      this.readSE();
      return this.ss.decryptAndHash(message2.sublist(consumed));
    } catch (e) {
      throw new InvalidCryptoExchangeError(`handshake stage 2 validation fail: ${e.message}`);
    }
  }
};
function hashProtocolName(crypto3, protocolName) {
  if (protocolName.length <= 32) {
    const h2 = alloc8(32);
    h2.set(protocolName);
    return h2;
  } else {
    return crypto3.hash(protocolName);
  }
}

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value of obj.webtransportCerthashes) {
            w2.uint32(10);
            w2.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          webtransportCerthashes: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.webtransportCerthashes.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf3) => {
    return decodeMessage(buf3, NoiseExtensions2.codec());
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.identityKey);
        }
        if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w2.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          identityKey: alloc8(0),
          identitySig: alloc8(0)
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.identityKey = reader.bytes();
              break;
            }
            case 2: {
              obj.identitySig = reader.bytes();
              break;
            }
            case 4: {
              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf3) => {
    return decodeMessage(buf3, NoiseHandshakePayload2.codec());
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
  return NoiseHandshakePayload.encode({
    identityKey: privateKey.public.bytes,
    identitySig,
    extensions
  });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
  try {
    const payload = NoiseHandshakePayload.decode(payloadBytes);
    if (remoteIdentityKey) {
      const remoteIdentityKeyBytes = remoteIdentityKey.subarray();
      if (!equals38(remoteIdentityKeyBytes, payload.identityKey)) {
        throw new Error(`Payload identity key ${toString28(payload.identityKey, "hex")} does not match expected remote identity key ${toString28(remoteIdentityKeyBytes, "hex")}`);
      }
    }
    if (!remoteStaticKey) {
      throw new Error("Remote static does not exist");
    }
    const signaturePayload = getSignaturePayload(remoteStaticKey);
    const publicKey = unmarshalPublicKey2(payload.identityKey);
    if (!await publicKey.verify(signaturePayload, payload.identitySig)) {
      throw new Error("Invalid payload signature");
    }
    return payload;
  } catch (e) {
    throw new UnexpectedPeerError(e.message);
  }
}
function getSignaturePayload(publicKey) {
  const prefix = fromString27("noise-libp2p-static-key:");
  if (publicKey instanceof Uint8Array) {
    return concat8([prefix, publicKey], prefix.length + publicKey.length);
  }
  publicKey.prepend(prefix);
  return publicKey;
}

// node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
async function performHandshakeInitiator(init, options2) {
  const { log: log10, connection, crypto: crypto3, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto3,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: true,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log10);
  log10.trace("Stage 0 - Initiator starting to send first message.");
  await connection.write(xx.writeMessageA(ZEROLEN), options2);
  log10.trace("Stage 0 - Initiator finished sending first message.");
  logLocalEphemeralKeys(xx.e, log10);
  log10.trace("Stage 1 - Initiator waiting to receive first message from responder...");
  const plaintext = xx.readMessageB(await connection.read(options2));
  log10.trace("Stage 1 - Initiator received the message.");
  logRemoteEphemeralKey(xx.re, log10);
  logRemoteStaticKey(xx.rs, log10);
  log10.trace("Initiator going to check remote's signature...");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  log10.trace("All good with the signature!");
  log10.trace("Stage 2 - Initiator sending third handshake message.");
  await connection.write(xx.writeMessageC(payload), options2);
  log10.trace("Stage 2 - Initiator sent message with signed payload.");
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log10);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
async function performHandshakeResponder(init, options2) {
  const { log: log10, connection, crypto: crypto3, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto3,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: false,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log10);
  log10.trace("Stage 0 - Responder waiting to receive first message.");
  xx.readMessageA(await connection.read(options2));
  log10.trace("Stage 0 - Responder received first message.");
  logRemoteEphemeralKey(xx.re, log10);
  log10.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
  await connection.write(xx.writeMessageB(payload), options2);
  log10.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
  logLocalEphemeralKeys(xx.e, log10);
  log10.trace("Stage 2 - Responder waiting for third handshake message...");
  const plaintext = xx.readMessageC(await connection.read(options2));
  log10.trace("Stage 2 - Responder received the message, finished handshake.");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log10);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js
var CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        let data;
        if (chunk instanceof Uint8Array) {
          data = handshake.encrypt(chunk.subarray(i, end));
        } else {
          data = handshake.encrypt(chunk.sublist(i, end));
        }
        metrics?.encryptedPackets.increment();
        yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);
      }
    }
  };
}
function decryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - CHACHA_TAG_LENGTH < i) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.sublist(i, end);
        const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
        try {
          const plaintext = handshake.decrypt(encrypted, dst);
          metrics?.decryptedPackets.increment();
          yield plaintext;
        } catch (e) {
          metrics?.decryptErrors.increment();
          throw e;
        }
      }
    }
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  protocol = "/noise";
  crypto;
  prologue;
  staticKey;
  extensions;
  metrics;
  components;
  constructor(components, init = {}) {
    const { staticNoiseKey, extensions, crypto: crypto3, prologueBytes } = init;
    const { metrics } = components;
    this.components = components;
    const _crypto = crypto3 ?? defaultCrypto;
    this.crypto = wrapCrypto(_crypto);
    this.extensions = extensions;
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKey = _crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? alloc8(0);
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
  [serviceCapabilities] = [
    "@libp2p/connection-encryption",
    "@chainsafe/libp2p-noise"
  ];
  async secureOutbound(...args) {
    const { localPeer, connection, remotePeer, signal } = this.parseArgs(args);
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    if (!localPeer.privateKey) {
      throw new CodeError("local peerId does not contain private key", "ERR_NO_PRIVATE_KEY");
    }
    const privateKey = await unmarshalPrivateKey3(localPeer.privateKey);
    const remoteIdentityKey = remotePeer?.publicKey;
    const handshake = await this.performHandshakeInitiator(wrappedConnection, privateKey, remoteIdentityKey, {
      signal
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: await peerIdFromKeys(handshake.payload.identityKey)
    };
  }
  async secureInbound(...args) {
    const { localPeer, connection, remotePeer, signal } = this.parseArgs(args);
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    if (!localPeer.privateKey) {
      throw new CodeError("local peerId does not contain private key", "ERR_NO_PRIVATE_KEY");
    }
    const privateKey = await unmarshalPrivateKey3(localPeer.privateKey);
    const remoteIdentityKey = remotePeer?.publicKey;
    const handshake = await this.performHandshakeResponder(wrappedConnection, privateKey, remoteIdentityKey, {
      signal
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: await peerIdFromKeys(handshake.payload.identityKey)
    };
  }
  /**
   * Perform XX handshake as initiator.
   */
  async performHandshakeInitiator(connection, privateKey, remoteIdentityKey, options2) {
    let result;
    try {
      result = await performHandshakeInitiator({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: this.extensions
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e;
    }
    return result;
  }
  /**
   * Perform XX handshake as responder.
   */
  async performHandshakeResponder(connection, privateKey, remoteIdentityKey, options2) {
    let result;
    try {
      result = await performHandshakeResponder({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: this.extensions
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e;
    }
    return result;
  }
  async createSecureConnection(connection, handshake) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe3(
      secure,
      // write to wrapper
      encryptStream(handshake, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      (source) => decode2(source, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
  /**
   * Detect call signature in `libp2p@1.x.x` or `libp2p@2.x.x` style.
   *
   * TODO: remove this after `libp2p@2.x.x` is released and only support the
   * newer style
   */
  parseArgs(args) {
    if (isPeerId(args[0])) {
      return {
        localPeer: args[0],
        connection: args[1],
        remotePeer: args[2]
      };
    } else {
      return {
        localPeer: this.components.peerId,
        connection: args[0],
        remotePeer: args[1]?.remotePeer,
        signal: args[1]?.signal
      };
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return (components) => new Noise(components, init);
}

// node_modules/@chainsafe/libp2p-yamux/node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
var ERR_INVALID_FRAME = "ERR_INVALID_FRAME";
var ERR_UNREQUESTED_PING = "ERR_UNREQUESTED_PING";
var ERR_NOT_MATCHING_PING = "ERR_NOT_MATCHING_PING";
var ERR_STREAM_ALREADY_EXISTS = "ERR_STREAM_ALREADY_EXISTS";
var ERR_DECODE_INVALID_VERSION = "ERR_DECODE_INVALID_VERSION";
var ERR_BOTH_CLIENTS = "ERR_BOTH_CLIENTS";
var ERR_RECV_WINDOW_EXCEEDED = "ERR_RECV_WINDOW_EXCEEDED";
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  ERR_INVALID_FRAME,
  ERR_UNREQUESTED_PING,
  ERR_NOT_MATCHING_PING,
  ERR_STREAM_ALREADY_EXISTS,
  ERR_DECODE_INVALID_VERSION,
  ERR_BOTH_CLIENTS,
  ERR_RECV_WINDOW_EXCEEDED
]);
var ERR_INVALID_CONFIG = "ERR_INVALID_CONFIG";
var ERR_MUXER_LOCAL_CLOSED = "ERR_MUXER_LOCAL_CLOSED";
var ERR_MUXER_REMOTE_CLOSED = "ERR_MUXER_REMOTE_CLOSED";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = "ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED";
var ERR_DECODE_IN_PROGRESS = "ERR_DECODE_IN_PROGRESS";
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
var defaultConfig = {
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  initialStreamWindowSize: INITIAL_STREAM_WINDOW,
  maxStreamWindowSize: MAX_STREAM_WINDOW,
  maxMessageSize: 64 * 1024
};
function verifyConfig(config) {
  if (config.keepAliveInterval <= 0) {
    throw new CodeError("keep-alive interval must be positive", ERR_INVALID_CONFIG);
  }
  if (config.maxInboundStreams < 0) {
    throw new CodeError("max inbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.maxOutboundStreams < 0) {
    throw new CodeError("max outbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {
    throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32", ERR_INVALID_CONFIG);
  }
  if (config.maxMessageSize < 1024) {
    throw new CodeError("MaxMessageSize must be greater than a kilobyte", ERR_INVALID_CONFIG);
  }
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;

// node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new CodeError("Invalid frame version", ERR_DECODE_INVALID_VERSION);
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
var Decoder18 = class {
  source;
  /** Buffer for in-progress frames */
  buffer;
  /** Used to sanity check against decoding while in an inconsistent state */
  frameInProgress;
  constructor(source) {
    this.source = returnlessSource(source);
    this.buffer = new Uint8ArrayList();
    this.frameInProgress = false;
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  async *emitFrames() {
    for await (const chunk of this.source) {
      this.buffer.append(chunk);
      while (true) {
        const header = this.readHeader();
        if (header === void 0) {
          break;
        }
        const { type, length: length30 } = header;
        if (type === FrameType.Data) {
          this.frameInProgress = true;
          yield {
            header,
            readData: this.readBytes.bind(this, length30)
          };
        } else {
          yield { header };
        }
      }
    }
  }
  readHeader() {
    if (this.frameInProgress) {
      throw new CodeError("decoding frame already in progress", ERR_DECODE_IN_PROGRESS);
    }
    if (this.buffer.length < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    this.buffer.consume(HEADER_LENGTH);
    return header;
  }
  async readBytes(length30) {
    if (this.buffer.length < length30) {
      for await (const chunk of this.source) {
        this.buffer.append(chunk);
        if (this.buffer.length >= length30) {
          break;
        }
      }
    }
    const out = this.buffer.sublist(0, length30);
    this.buffer.consume(length30);
    this.frameInProgress = false;
    return out;
  }
};
function returnlessSource(source) {
  if (source[Symbol.iterator] !== void 0) {
    const iterator = source[Symbol.iterator]();
    iterator.return = void 0;
    return {
      [Symbol.iterator]() {
        return iterator;
      }
    };
  } else if (source[Symbol.asyncIterator] !== void 0) {
    const iterator = source[Symbol.asyncIterator]();
    iterator.return = void 0;
    return {
      [Symbol.asyncIterator]() {
        return iterator;
      }
    };
  } else {
    throw new Error("a source must be either an iterable or an async iterable");
  }
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}

// node_modules/@libp2p/utils/node_modules/get-iterator/dist/src/index.js
function getIterator2(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/@libp2p/utils/dist/src/is-promise.js
function isPromise3(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@libp2p/utils/dist/src/close-source.js
function closeSource(source, log10) {
  const res = getIterator2(source).return?.();
  if (isPromise3(res)) {
    res.catch((err) => {
      log10.error("could not cause iterator to return", err);
    });
  }
}

// node_modules/@libp2p/utils/dist/src/abstract-stream.js
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_SINK_INVALID_STATE = "ERR_SINK_INVALID_STATE";
var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
function isPromise4(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
var AbstractStream = class {
  id;
  direction;
  timeline;
  protocol;
  metadata;
  source;
  status;
  readStatus;
  writeStatus;
  log;
  sinkController;
  sinkEnd;
  closed;
  endErr;
  streamSource;
  onEnd;
  onCloseRead;
  onCloseWrite;
  onReset;
  onAbort;
  sendCloseWriteTimeout;
  sendingData;
  constructor(init) {
    this.sinkController = new AbortController();
    this.sinkEnd = pDefer2();
    this.closed = pDefer2();
    this.log = init.log;
    this.status = "open";
    this.readStatus = "ready";
    this.writeStatus = "ready";
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.direction = init.direction;
    this.timeline = {
      open: Date.now()
    };
    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
    this.onEnd = init.onEnd;
    this.onCloseRead = init?.onCloseRead;
    this.onCloseWrite = init?.onCloseWrite;
    this.onReset = init?.onReset;
    this.onAbort = init?.onAbort;
    this.source = this.streamSource = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log.trace("source ended with error", err);
        } else {
          this.log.trace("source ended");
        }
        this.onSourceEnd(err);
      }
    });
    this.sink = this.sink.bind(this);
  }
  async sink(source) {
    if (this.writeStatus !== "ready") {
      throw new CodeError(`writable end state is "${this.writeStatus}" not "ready"`, ERR_SINK_INVALID_STATE);
    }
    try {
      this.writeStatus = "writing";
      const options2 = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const res = this.sendNewStream(options2);
        if (isPromise4(res)) {
          await res;
        }
      }
      const abortListener = () => {
        closeSource(source, this.log);
      };
      try {
        this.sinkController.signal.addEventListener("abort", abortListener);
        this.log.trace("sink reading from source");
        for await (let data of source) {
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data, options2);
          if (isPromise4(res)) {
            this.sendingData = pDefer2();
            await res;
            this.sendingData.resolve();
            this.sendingData = void 0;
          }
        }
      } finally {
        this.sinkController.signal.removeEventListener("abort", abortListener);
      }
      this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
      if (this.writeStatus === "writing") {
        this.writeStatus = "closing";
        this.log.trace("send close write to remote");
        await this.sendCloseWrite({
          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
        });
        this.writeStatus = "closed";
      }
      this.onSinkEnd();
    } catch (err) {
      this.log.trace("sink ended with error, calling abort with error", err);
      this.abort(err);
      throw err;
    } finally {
      this.log.trace("resolve sink end");
      this.sinkEnd.resolve();
    }
  }
  onSourceEnd(err) {
    if (this.timeline.closeRead != null) {
      return;
    }
    this.timeline.closeRead = Date.now();
    this.readStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    this.onCloseRead?.();
    if (this.timeline.closeWrite != null) {
      this.log.trace("source and sink ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("source ended, waiting for sink to end");
    }
  }
  onSinkEnd(err) {
    if (this.timeline.closeWrite != null) {
      return;
    }
    this.timeline.closeWrite = Date.now();
    this.writeStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    this.onCloseWrite?.();
    if (this.timeline.closeRead != null) {
      this.log.trace("sink and source ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("sink ended, waiting for source to end");
    }
  }
  // Close for both Reading and Writing
  async close(options2) {
    this.log.trace("closing gracefully");
    this.status = "closing";
    await raceSignal(Promise.all([
      this.closeWrite(options2),
      this.closeRead(options2),
      this.closed.promise
    ]), options2?.signal);
    this.status = "closed";
    this.log.trace("closed gracefully");
  }
  async closeRead(options2 = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const readStatus = this.readStatus;
    this.readStatus = "closing";
    if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
      this.log.trace("send close read to remote");
      await this.sendCloseRead(options2);
    }
    if (readStatus === "ready") {
      this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
      this.streamSource.end();
    }
    this.log.trace("closed readable end of stream");
  }
  async closeWrite(options2 = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    if (this.writeStatus === "ready") {
      this.log.trace("sink was never sunk, sink an empty array");
      await raceSignal(this.sink([]), options2.signal);
    }
    if (this.writeStatus === "writing") {
      if (this.sendingData != null) {
        await raceSignal(this.sendingData.promise, options2.signal);
      }
      this.log.trace("aborting source passed to .sink");
      this.sinkController.abort();
      await raceSignal(this.sinkEnd.promise, options2.signal);
    }
    this.writeStatus = "closed";
    this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    this.log("abort with error", err);
    this.log("try to send reset to remote");
    const res = this.sendReset();
    if (isPromise4(res)) {
      res.catch((err2) => {
        this.log.error("error sending reset message", err2);
      });
    }
    this.status = "aborted";
    this.timeline.abort = Date.now();
    this._closeSinkAndSource(err);
    this.onAbort?.(err);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    const err = new CodeError("stream reset", ERR_STREAM_RESET);
    this.status = "reset";
    this.timeline.reset = Date.now();
    this._closeSinkAndSource(err);
    this.onReset?.();
  }
  _closeSinkAndSource(err) {
    this._closeSink(err);
    this._closeSource(err);
  }
  _closeSink(err) {
    if (this.writeStatus === "writing") {
      this.log.trace("end sink source");
      this.sinkController.abort();
    }
    this.onSinkEnd(err);
  }
  _closeSource(err) {
    if (this.readStatus !== "closing" && this.readStatus !== "closed") {
      this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
      this.readStatus = "closing";
      this.streamSource.end(err);
    }
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write");
    this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read");
    this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("stream destroyed");
    this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
})(StreamState || (StreamState = {}));
var YamuxStream = class extends AbstractStream {
  name;
  state;
  config;
  _id;
  /** The number of available bytes to send */
  sendWindowCapacity;
  /** Callback to notify that the sendWindowCapacity has been updated */
  sendWindowCapacityUpdate;
  /** The number of bytes available to receive in a full window */
  recvWindow;
  /** The number of available bytes to receive */
  recvWindowCapacity;
  /**
   * An 'epoch' is the time it takes to process and read data
   *
   * Used in conjunction with RTT to determine whether to increase the recvWindow
   */
  epochStart;
  getRTT;
  sendFrame;
  constructor(init) {
    super({
      ...init,
      onEnd: (err) => {
        this.state = StreamState.Finished;
        init.onEnd?.(err);
      }
    });
    this.config = init.config;
    this._id = parseInt(init.id, 10);
    this.name = init.name;
    this.state = init.state;
    this.sendWindowCapacity = INITIAL_STREAM_WINDOW;
    this.recvWindow = this.config.initialStreamWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.sendFrame = init.sendFrame;
    this.source = src_default12(this.source, () => {
      this.sendWindowUpdate();
    });
  }
  /**
   * Send a message to the remote muxer informing them a new stream is being
   * opened.
   *
   * This is a noop for Yamux because the first window update is sent when
   * .newStream is called on the muxer which opens the stream on the remote.
   */
  async sendNewStream() {
  }
  /**
   * Send a data message to the remote muxer
   */
  async sendData(buf3, options2 = {}) {
    buf3 = buf3.sublist();
    while (buf3.byteLength !== 0) {
      if (this.sendWindowCapacity === 0) {
        this.log?.trace("wait for send window capacity, status %s", this.status);
        await this.waitForSendWindowCapacity(options2);
        if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
          this.log?.trace("%s while waiting for send window capacity", this.status);
          return;
        }
      }
      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf3.length);
      const flags = this.getSendFlags();
      this.sendFrame({
        type: FrameType.Data,
        flag: flags,
        streamID: this._id,
        length: toSend
      }, buf3.sublist(0, toSend));
      this.sendWindowCapacity -= toSend;
      buf3.consume(toSend);
    }
  }
  /**
   * Send a reset message to the remote muxer
   */
  async sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream
   */
  async sendCloseRead() {
  }
  /**
   * Wait for the send window to be non-zero
   *
   * Will throw with ERR_STREAM_ABORT if the stream gets aborted
   */
  async waitForSendWindowCapacity(options2 = {}) {
    if (this.sendWindowCapacity > 0) {
      return;
    }
    let resolve;
    let reject;
    const abort = () => {
      if (this.status === "open" || this.status === "closing") {
        reject(new CodeError("stream aborted", ERR_STREAM_ABORT));
      } else {
        resolve();
      }
    };
    options2.signal?.addEventListener("abort", abort);
    try {
      await new Promise((_resolve, _reject) => {
        this.sendWindowCapacityUpdate = () => {
          _resolve();
        };
        reject = _reject;
        resolve = _resolve;
      });
    } finally {
      options2.signal?.removeEventListener("abort", abort);
    }
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(header) {
    this.log?.trace("stream received window update id=%s", this._id);
    this.processFlags(header.flag);
    const available = this.sendWindowCapacity;
    this.sendWindowCapacity += header.length;
    if (available === 0 && header.length > 0) {
      this.sendWindowCapacityUpdate?.();
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  async handleData(header, readData) {
    this.log?.trace("stream received data id=%s", this._id);
    this.processFlags(header.flag);
    if (this.recvWindowCapacity < header.length) {
      throw new CodeError("receive window exceeded", ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: header.length });
    }
    const data = await readData();
    this.recvWindowCapacity -= header.length;
    this.sourcePush(data);
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.remoteCloseWrite();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.reset();
    }
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * potentially sends a window update enabling further writes to take place.
   */
  sendWindowUpdate() {
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: delta
    });
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
var CLOSE_TIMEOUT = 500;
var Yamux = class {
  protocol = YAMUX_PROTOCOL_ID;
  _components;
  _init;
  constructor(components, init = {}) {
    this._components = components;
    this._init = init;
  }
  createStreamMuxer(init) {
    return new YamuxMuxer(this._components, {
      ...this._init,
      ...init
    });
  }
};
var YamuxMuxer = class {
  protocol = YAMUX_PROTOCOL_ID;
  source;
  sink;
  config;
  log;
  logger;
  /** Used to close the muxer from either the sink or source */
  closeController;
  /** The next stream id to be used when initiating a new stream */
  nextStreamID;
  /** Primary stream mapping, streamID => stream */
  _streams;
  /** The next ping id to be used when pinging */
  nextPingID;
  /** Tracking info for the currently active ping */
  activePing;
  /** Round trip time */
  rtt;
  /** True if client, false if server */
  client;
  localGoAway;
  remoteGoAway;
  /** Number of tracked inbound streams */
  numInboundStreams;
  /** Number of tracked outbound streams */
  numOutboundStreams;
  onIncomingStream;
  onStreamEnd;
  constructor(components, init) {
    this.client = init.direction === "outbound";
    this.config = { ...defaultConfig, ...init };
    this.logger = components.logger;
    this.log = this.logger.forComponent("libp2p:yamux");
    verifyConfig(this.config);
    this.closeController = new AbortController();
    setMaxListeners2(Infinity, this.closeController.signal);
    this.onIncomingStream = init.onIncomingStream;
    this.onStreamEnd = init.onStreamEnd;
    this._streams = /* @__PURE__ */ new Map();
    this.source = pushable({
      onEnd: () => {
        this.log?.trace("muxer source ended");
        this._streams.forEach((stream) => {
          stream.destroy();
        });
      }
    });
    this.sink = async (source) => {
      const shutDownListener = () => {
        const iterator = getIterator(source);
        if (iterator.return != null) {
          const res = iterator.return();
          if (isPromise5(res)) {
            res.catch((err) => {
              this.log?.("could not cause sink source to return", err);
            });
          }
        }
      };
      let reason, error;
      try {
        const decoder = new Decoder18(source);
        try {
          this.closeController.signal.addEventListener("abort", shutDownListener);
          for await (const frame of decoder.emitFrames()) {
            await this.handleFrame(frame.header, frame.readData);
          }
        } finally {
          this.closeController.signal.removeEventListener("abort", shutDownListener);
        }
        reason = GoAwayCode.NormalTermination;
      } catch (err) {
        const errCode7 = err.code;
        if (PROTOCOL_ERRORS.has(errCode7)) {
          this.log?.error("protocol error in sink", err);
          reason = GoAwayCode.ProtocolError;
        } else {
          this.log?.error("internal error in sink", err);
          reason = GoAwayCode.InternalError;
        }
        error = err;
      }
      this.log?.trace("muxer sink ended");
      if (error != null) {
        this.abort(error, reason);
      } else {
        await this.close({ reason });
      }
    };
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = -1;
    this.log?.trace("muxer created");
    if (this.config.enableKeepAlive) {
      this.keepAliveLoop().catch((e) => this.log?.error("keepalive error: %s", e));
    }
    this.ping().catch((e) => this.log?.error("ping error: %s", e));
  }
  get streams() {
    return Array.from(this._streams.values());
  }
  newStream(name29) {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {
      throw new CodeError("max outbound streams exceeded", ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);
    }
    this.log?.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, name29, StreamState.Init, "outbound");
    this._streams.set(id, stream);
    this.numOutboundStreams++;
    stream.sendWindowUpdate();
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping() {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    if (this.activePing === void 0) {
      let _resolve = () => {
      };
      this.activePing = {
        id: this.nextPingID++,
        // this promise awaits resolution or the close controller aborting
        promise: new Promise((resolve, reject) => {
          const closed = () => {
            reject(new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED));
          };
          this.closeController.signal.addEventListener("abort", closed, { once: true });
          _resolve = () => {
            this.closeController.signal.removeEventListener("abort", closed);
            resolve();
          };
        }),
        resolve: _resolve
      };
      const start2 = Date.now();
      this.sendPing(this.activePing.id);
      try {
        await this.activePing.promise;
      } finally {
        delete this.activePing;
      }
      const end = Date.now();
      this.rtt = end - start2;
    } else {
      await this.activePing.promise;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(options2 = {}) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const reason = options2?.reason ?? GoAwayCode.NormalTermination;
    this.log?.trace("muxer close reason=%s", reason);
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
      setMaxListeners2(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      await Promise.all([...this._streams.values()].map(async (s2) => s2.close(options2)));
      this.sendGoAway(reason);
      this._closeMuxer();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err, reason) {
    if (this.closeController.signal.aborted) {
      return;
    }
    reason = reason ?? GoAwayCode.InternalError;
    this.log?.error("muxer abort reason=%s error=%s", reason, err);
    for (const stream of this._streams.values()) {
      stream.abort(err);
    }
    this.sendGoAway(reason);
    this._closeMuxer();
  }
  isClosed() {
    return this.closeController.signal.aborted;
  }
  /**
   * Called when either the local or remote shuts down the muxer
   */
  _closeMuxer() {
    this.closeController.abort();
    this.source.end();
  }
  /** Create a new stream */
  _newStream(id, name29, state, direction) {
    if (this._streams.get(id) != null) {
      throw new CodeError("Stream already exists", ERR_STREAM_ALREADY_EXISTS, { id });
    }
    const stream = new YamuxStream({
      id: id.toString(),
      name: name29,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      onEnd: () => {
        this.closeStream(id);
        this.onStreamEnd?.(stream);
      },
      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),
      config: this.config,
      getRTT: this.getRTT.bind(this)
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
    this._streams.delete(id);
  }
  async keepAliveLoop() {
    const abortPromise = new Promise((_resolve, reject) => {
      this.closeController.signal.addEventListener("abort", reject, { once: true });
    });
    this.log?.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
    while (true) {
      let timeoutId;
      try {
        await Promise.race([
          abortPromise,
          new Promise((resolve) => {
            timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
          })
        ]);
        this.ping().catch((e) => this.log?.error("ping error: %s", e));
      } catch (e) {
        clearInterval(timeoutId);
        return;
      }
    }
  }
  async handleFrame(header, readData) {
    const { streamID, type, length: length30 } = header;
    this.log?.trace("received frame %o", header);
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length30);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    } else {
      switch (header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          await this.handleStreamMessage(header, readData);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log?.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log?.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new CodeError("Invalid frame flag", ERR_INVALID_FRAME, { header });
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new CodeError("ping not requested", ERR_UNREQUESTED_PING);
    }
    if (this.activePing.id !== pingId) {
      throw new CodeError("ping doesn't match our id", ERR_NOT_MATCHING_PING);
    }
    this.activePing.resolve();
  }
  handleGoAway(reason) {
    this.log?.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    for (const stream of this._streams.values()) {
      stream.reset();
    }
    this._closeMuxer();
  }
  async handleStreamMessage(header, readData) {
    const { streamID, flag, type } = header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this._streams.get(streamID);
    if (stream === void 0) {
      if (type === FrameType.Data) {
        this.log?.("discarding data for stream id=%s", streamID);
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await readData();
      } else {
        this.log?.("frame for missing stream id=%s", streamID);
      }
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(header);
        return;
      }
      case FrameType.Data: {
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await stream.handleData(header, readData);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new CodeError("both endpoints are clients", ERR_BOTH_CLIENTS);
    }
    if (this._streams.has(id)) {
      return;
    }
    this.log?.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.config.maxInboundStreams) {
      this.log?.("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, void 0, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this._streams.set(id, stream);
    this.onIncomingStream?.(stream);
  }
  sendFrame(header, data) {
    this.log?.trace("sending frame %o", header);
    if (header.type === FrameType.Data) {
      if (data === void 0) {
        throw new CodeError("invalid frame", ERR_INVALID_FRAME);
      }
      this.source.push(new Uint8ArrayList(encodeHeader(header), data));
    } else {
      this.source.push(encodeHeader(header));
    }
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log?.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log?.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log?.("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};
function isPromise5(thing) {
  return thing != null && typeof thing.then === "function";
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
function yamux(init = {}) {
  return (components) => new Yamux(components, init);
}

// node_modules/@libp2p/autonat/node_modules/it-first/dist/src/index.js
function isAsyncIterable18(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function first2(source) {
  if (isAsyncIterable18(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
var src_default26 = first2;

// node_modules/@libp2p/autonat/node_modules/it-peekable/dist/src/index.js
function peekable6(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default27 = peekable6;

// node_modules/@libp2p/autonat/node_modules/it-map/dist/src/index.js
function isAsyncIterable19(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map3(source, func2) {
  let index = 0;
  if (isAsyncIterable19(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val, index++);
      }
    }();
  }
  const peekable8 = src_default27(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = func2(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable8) {
        yield func2(val, index++);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable8) {
      yield fn(val, index++);
    }
  }();
}
var src_default28 = map3;

// node_modules/it-parallel/node_modules/p-defer/index.js
function pDefer8() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-parallel/dist/src/index.js
var CustomEvent2 = globalThis.CustomEvent ?? Event;
async function* parallel(source, options2 = {}) {
  let concurrency = options2.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options2.ordered == null ? false : options2.ordered;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer8();
  let resultAvailable = pDefer8();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer8();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].done) {
          const op = ops[i];
          ops.splice(i, 1);
          i--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer8();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}

// node_modules/@libp2p/autonat/node_modules/it-pipe/dist/src/index.js
function pipe4(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex3(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable3(first4) || isAsyncIterable20(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex3(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex3(fns[i])) {
        fns[i] = duplexPipelineFn3(fns[i]);
      }
    }
  }
  return rawPipe3(...fns);
}
var rawPipe3 = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable20 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable3 = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex3 = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn3 = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable20(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable3(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@libp2p/autonat/dist/src/constants.js
var PROTOCOL_PREFIX = "libp2p";
var PROTOCOL_NAME = "autonat";
var PROTOCOL_VERSION = "1.0.0";
var TIMEOUT = 3e4;
var STARTUP_DELAY = 5e3;
var REFRESH_INTERVAL = 6e4;
var MAX_INBOUND_STREAMS = 1;
var MAX_OUTBOUND_STREAMS = 1;

// node_modules/@libp2p/autonat/dist/src/pb/index.js
var Message;
(function(Message5) {
  let MessageType2;
  (function(MessageType3) {
    MessageType3["DIAL"] = "DIAL";
    MessageType3["DIAL_RESPONSE"] = "DIAL_RESPONSE";
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let __MessageTypeValues2;
  (function(__MessageTypeValues3) {
    __MessageTypeValues3[__MessageTypeValues3["DIAL"] = 0] = "DIAL";
    __MessageTypeValues3[__MessageTypeValues3["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
  })(__MessageTypeValues2 || (__MessageTypeValues2 = {}));
  (function(MessageType3) {
    MessageType3.codec = () => {
      return enumeration(__MessageTypeValues2);
    };
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let ResponseStatus;
  (function(ResponseStatus2) {
    ResponseStatus2["OK"] = "OK";
    ResponseStatus2["E_DIAL_ERROR"] = "E_DIAL_ERROR";
    ResponseStatus2["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
    ResponseStatus2["E_BAD_REQUEST"] = "E_BAD_REQUEST";
    ResponseStatus2["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let __ResponseStatusValues;
  (function(__ResponseStatusValues2) {
    __ResponseStatusValues2[__ResponseStatusValues2["OK"] = 0] = "OK";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
    __ResponseStatusValues2[__ResponseStatusValues2["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
    __ResponseStatusValues2[__ResponseStatusValues2["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
  })(__ResponseStatusValues || (__ResponseStatusValues = {}));
  (function(ResponseStatus2) {
    ResponseStatus2.codec = () => {
      return enumeration(__ResponseStatusValues);
    };
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let PeerInfo2;
  (function(PeerInfo3) {
    let _codec2;
    PeerInfo3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.id != null) {
            w2.uint32(10);
            w2.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {
            addrs: []
          };
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader.bytes();
                break;
              case 2:
                obj.addrs.push(reader.bytes());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo3.encode = (obj) => {
      return encodeMessage(obj, PeerInfo3.codec());
    };
    PeerInfo3.decode = (buf3) => {
      return decodeMessage(buf3, PeerInfo3.codec());
    };
  })(PeerInfo2 = Message5.PeerInfo || (Message5.PeerInfo = {}));
  let Dial;
  (function(Dial2) {
    let _codec2;
    Dial2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.peer != null) {
            w2.uint32(10);
            Message5.PeerInfo.codec().encode(obj.peer, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {};
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.peer = Message5.PeerInfo.codec().decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Dial2.encode = (obj) => {
      return encodeMessage(obj, Dial2.codec());
    };
    Dial2.decode = (buf3) => {
      return decodeMessage(buf3, Dial2.codec());
    };
  })(Dial = Message5.Dial || (Message5.Dial = {}));
  let DialResponse;
  (function(DialResponse2) {
    let _codec2;
    DialResponse2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.status != null) {
            w2.uint32(8);
            Message5.ResponseStatus.codec().encode(obj.status, w2);
          }
          if (obj.statusText != null) {
            w2.uint32(18);
            w2.string(obj.statusText);
          }
          if (obj.addr != null) {
            w2.uint32(26);
            w2.bytes(obj.addr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {};
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.status = Message5.ResponseStatus.codec().decode(reader);
                break;
              case 2:
                obj.statusText = reader.string();
                break;
              case 3:
                obj.addr = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    DialResponse2.encode = (obj) => {
      return encodeMessage(obj, DialResponse2.codec());
    };
    DialResponse2.decode = (buf3) => {
      return decodeMessage(buf3, DialResponse2.codec());
    };
  })(DialResponse = Message5.DialResponse || (Message5.DialResponse = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          Message5.MessageType.codec().encode(obj.type, w2);
        }
        if (obj.dial != null) {
          w2.uint32(18);
          Message5.Dial.codec().encode(obj.dial, w2);
        }
        if (obj.dialResponse != null) {
          w2.uint32(26);
          Message5.DialResponse.codec().encode(obj.dialResponse, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message5.MessageType.codec().decode(reader);
              break;
            case 2:
              obj.dial = Message5.Dial.codec().decode(reader, reader.uint32());
              break;
            case 3:
              obj.dialResponse = Message5.DialResponse.codec().decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf3) => {
    return decodeMessage(buf3, Message5.codec());
  };
})(Message || (Message = {}));

// node_modules/@libp2p/autonat/dist/src/autonat.js
var REQUIRED_SUCCESSFUL_DIALS = 4;
var AutoNATService = class {
  components;
  startupDelay;
  refreshInterval;
  protocol;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  verifyAddressTimeout;
  started;
  log;
  constructor(components, init) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:autonat");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.startupDelay = init.startupDelay ?? STARTUP_DELAY;
    this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
    this._verifyExternalAddresses = this._verifyExternalAddresses.bind(this);
  }
  [Symbol.toStringTag] = "@libp2p/autonat";
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleIncomingAutonatStream(data).catch((err) => {
        this.log.error("error handling incoming autonat stream", err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.startupDelay);
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    clearTimeout(this.verifyAddressTimeout);
    this.started = false;
  }
  /**
   * Handle an incoming AutoNAT request
   */
  async handleIncomingAutonatStream(data) {
    const signal = AbortSignal.timeout(this.timeout);
    const onAbort = () => {
      data.stream.abort(new CodeError("handleIncomingAutonatStream timeout", ERR_TIMEOUT));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    setMaxListeners2(Infinity, signal);
    try {
      const self2 = this;
      await pipe4(data.stream, (source) => decode2(source), async function* (stream) {
        const buf3 = await src_default26(stream);
        if (buf3 == null) {
          self2.log("no message received");
          yield Message.encode({
            type: Message.MessageType.DIAL_RESPONSE,
            dialResponse: {
              status: Message.ResponseStatus.E_BAD_REQUEST,
              statusText: "No message was sent"
            }
          });
          return;
        }
        let request;
        try {
          request = Message.decode(buf3);
        } catch (err) {
          self2.log.error("could not decode message", err);
          yield Message.encode({
            type: Message.MessageType.DIAL_RESPONSE,
            dialResponse: {
              status: Message.ResponseStatus.E_BAD_REQUEST,
              statusText: "Could not decode message"
            }
          });
          return;
        }
        yield Message.encode(await self2.handleAutonatMessage(request, data.connection, {
          signal
        }));
      }, (source) => encode2(source), data.stream);
    } catch (err) {
      this.log.error("error handling incoming autonat stream", err);
    } finally {
      signal.removeEventListener("abort", onAbort);
    }
  }
  _verifyExternalAddresses() {
    void this.verifyExternalAddresses().catch((err) => {
      this.log.error("error verifying external address", err);
    });
  }
  async handleAutonatMessage(message2, connection, options2) {
    const ourHosts = this.components.addressManager.getAddresses().map((ma) => ma.toOptions().host);
    const dialRequest = message2.dial;
    if (dialRequest == null) {
      this.log.error("dial was missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "No Dial message found in message"
        }
      };
    }
    let peerId2;
    const peer = dialRequest.peer;
    if (peer?.id == null) {
      this.log.error("PeerId missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "missing peer info"
        }
      };
    }
    try {
      peerId2 = peerIdFromBytes(peer.id);
    } catch (err) {
      this.log.error("invalid PeerId", err);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "bad peer id"
        }
      };
    }
    this.log("incoming request from %p", peerId2);
    if (!connection.remotePeer.equals(peerId2)) {
      this.log("target peer %p did not equal sending peer %p", peerId2, connection.remotePeer);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "peer id mismatch"
        }
      };
    }
    const multiaddrs = peer.addrs.map((buf3) => multiaddr(buf3)).filter((ma) => {
      const isFromSameHost = ma.toOptions().host === connection.remoteAddr.toOptions().host;
      this.log.trace("request to dial %a was sent from %a is same host %s", ma, connection.remoteAddr, isFromSameHost);
      return isFromSameHost;
    }).filter((ma) => {
      const host = ma.toOptions().host;
      const isPublicIp = !(isPrivateIp(host) ?? false);
      this.log.trace("host %s was public %s", host, isPublicIp);
      return isPublicIp;
    }).filter((ma) => {
      const host = ma.toOptions().host;
      const isNotOurHost = !ourHosts.includes(host);
      this.log.trace("host %s was not our host %s", host, isNotOurHost);
      return isNotOurHost;
    }).filter((ma) => {
      const isSupportedTransport = Boolean(this.components.transportManager.dialTransportForMultiaddr(ma));
      this.log.trace("transport for %a is supported %s", ma, isSupportedTransport);
      return isSupportedTransport;
    }).map((ma) => {
      if (ma.getPeerId() == null) {
        ma = ma.encapsulate(`/p2p/${peerId2.toString()}`);
      }
      return ma;
    });
    if (multiaddrs.length === 0) {
      this.log("no valid multiaddrs for %p in message", peerId2);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_DIAL_REFUSED,
          statusText: "no dialable addresses"
        }
      };
    }
    this.log("dial multiaddrs %s for peer %p", multiaddrs.map((ma) => ma.toString()).join(", "), peerId2);
    let errorMessage = "";
    let lastMultiaddr = multiaddrs[0];
    for await (const multiaddr2 of multiaddrs) {
      let connection2;
      lastMultiaddr = multiaddr2;
      try {
        connection2 = await this.components.connectionManager.openConnection(multiaddr2, options2);
        if (!connection2.remoteAddr.equals(multiaddr2)) {
          this.log.error("tried to dial %a but dialed %a", multiaddr2, connection2.remoteAddr);
          throw new Error("Unexpected remote address");
        }
        this.log("Success %p", peerId2);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.OK,
            addr: connection2.remoteAddr.decapsulateCode(getProtocol("p2p").code).bytes
          }
        };
      } catch (err) {
        this.log("could not dial %p", peerId2, err);
        errorMessage = err.message;
      } finally {
        if (connection2 != null) {
          await connection2.close();
        }
      }
    }
    return {
      type: Message.MessageType.DIAL_RESPONSE,
      dialResponse: {
        status: Message.ResponseStatus.E_DIAL_ERROR,
        statusText: errorMessage,
        addr: lastMultiaddr.bytes
      }
    };
  }
  /**
   * Our multicodec topology noticed a new peer that supports autonat
   */
  async verifyExternalAddresses() {
    clearTimeout(this.verifyAddressTimeout);
    if (!this.isStarted()) {
      return;
    }
    const addressManager = this.components.addressManager;
    const multiaddrs = addressManager.getObservedAddrs().filter((ma) => {
      const options2 = ma.toOptions();
      return !(isPrivateIp(options2.host) ?? false);
    });
    if (multiaddrs.length === 0) {
      this.log("no public addresses found, not requesting verification");
      this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
      return;
    }
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners2(Infinity, signal);
    const self2 = this;
    try {
      this.log("verify multiaddrs %s", multiaddrs.map((ma) => ma.toString()).join(", "));
      const request = Message.encode({
        type: Message.MessageType.DIAL,
        dial: {
          peer: {
            id: this.components.peerId.toBytes(),
            addrs: multiaddrs.map((map6) => map6.bytes)
          }
        }
      });
      const results = {};
      const networkSegments = [];
      const verifyAddress = async (peer) => {
        let onAbort = () => {
        };
        try {
          this.log("asking %p to verify multiaddr", peer.id);
          const connection = await self2.components.connectionManager.openConnection(peer.id, {
            signal
          });
          const stream = await connection.newStream(this.protocol, {
            signal
          });
          onAbort = () => {
            stream.abort(new CodeError("verifyAddress timeout", ERR_TIMEOUT));
          };
          signal.addEventListener("abort", onAbort, { once: true });
          const buf3 = await pipe4([request], (source) => encode2(source), stream, (source) => decode2(source), async (stream2) => src_default26(stream2));
          if (buf3 == null) {
            this.log("no response received from %p", connection.remotePeer);
            return void 0;
          }
          const response = Message.decode(buf3);
          if (response.type !== Message.MessageType.DIAL_RESPONSE || response.dialResponse == null) {
            this.log("invalid autonat response from %p", connection.remotePeer);
            return void 0;
          }
          if (response.dialResponse.status === Message.ResponseStatus.OK) {
            const options2 = connection.remoteAddr.toOptions();
            let segment;
            if (options2.family === 4) {
              const octets = options2.host.split(".");
              segment = octets[0];
            } else if (options2.family === 6) {
              const octets = options2.host.split(":");
              segment = octets[0];
            } else {
              this.log('remote address "%s" was not IP4 or IP6?', options2.host);
              return void 0;
            }
            if (networkSegments.includes(segment)) {
              this.log("already have response from network segment %d - %s", segment, options2.host);
              return void 0;
            }
            networkSegments.push(segment);
          }
          return response.dialResponse;
        } catch (err) {
          this.log.error("error asking remote to verify multiaddr", err);
        } finally {
          signal.removeEventListener("abort", onAbort);
        }
      };
      for await (const dialResponse of parallel(src_default28(this.components.randomWalk.walk({
        signal
      }), (peer) => async () => verifyAddress(peer)), {
        concurrency: REQUIRED_SUCCESSFUL_DIALS
      })) {
        try {
          if (dialResponse == null) {
            continue;
          }
          const addr = dialResponse.addr == null ? multiaddrs[0] : multiaddr(dialResponse.addr);
          this.log("autonat response for %a is %s", addr, dialResponse.status);
          if (dialResponse.status === Message.ResponseStatus.E_BAD_REQUEST) {
            continue;
          }
          if (dialResponse.status === Message.ResponseStatus.E_DIAL_REFUSED) {
            continue;
          }
          if (dialResponse.addr == null && multiaddrs.length > 1) {
            continue;
          }
          if (!multiaddrs.some((ma) => ma.equals(addr))) {
            this.log("peer reported %a as %s but it was not in our observed address list", addr, dialResponse.status);
            continue;
          }
          const addrStr = addr.toString();
          if (results[addrStr] == null) {
            results[addrStr] = { success: 0, failure: 0 };
          }
          if (dialResponse.status === Message.ResponseStatus.OK) {
            results[addrStr].success++;
          } else if (dialResponse.status === Message.ResponseStatus.E_DIAL_ERROR) {
            results[addrStr].failure++;
          }
          if (results[addrStr].success === REQUIRED_SUCCESSFUL_DIALS) {
            this.log("%a is externally dialable", addr);
            addressManager.confirmObservedAddr(addr);
            return;
          }
          if (results[addrStr].failure === REQUIRED_SUCCESSFUL_DIALS) {
            this.log("%a is not externally dialable", addr);
            addressManager.removeObservedAddr(addr);
            return;
          }
        } catch (err) {
          this.log.error("could not verify external address", err);
        }
      }
    } finally {
      this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
    }
  }
};

// node_modules/@libp2p/autonat/dist/src/index.js
function autoNAT(init = {}) {
  return (components) => {
    return new AutoNATService(components, init);
  };
}

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS42 = base21("dns4");
var DNS62 = base21("dns6");
var DNSADDR2 = base21("dnsaddr");
var DNS3 = or19(base21("dns"), DNSADDR2, DNS42, DNS62);
var IP2 = or19(base21("ip4"), base21("ip6"));
var TCP2 = or19(and2(IP2, base21("tcp")), and2(DNS3, base21("tcp")));
var UDP2 = and2(IP2, base21("udp"));
var UTP = and2(UDP2, base21("utp"));
var QUIC2 = and2(UDP2, base21("quic"));
var QUICV12 = and2(UDP2, base21("quic-v1"));
var _WebSockets2 = or19(and2(TCP2, base21("ws")), and2(DNS3, base21("ws")));
var WebSockets2 = or19(and2(_WebSockets2, base21("p2p")), _WebSockets2);
var _WebSocketsSecure2 = or19(and2(TCP2, base21("wss")), and2(DNS3, base21("wss")), and2(TCP2, base21("tls"), base21("ws")), and2(DNS3, base21("tls"), base21("ws")));
var WebSocketsSecure2 = or19(and2(_WebSocketsSecure2, base21("p2p")), _WebSocketsSecure2);
var HTTP2 = or19(and2(TCP2, base21("http")), and2(IP2, base21("http")), and2(DNS3, base21("http")));
var HTTPS2 = or19(and2(TCP2, base21("https")), and2(IP2, base21("https")), and2(DNS3, base21("https")));
var _WebRTCDirect2 = and2(UDP2, base21("webrtc-direct"), base21("certhash"));
var WebRTCDirect2 = or19(and2(_WebRTCDirect2, base21("p2p")), _WebRTCDirect2);
var _WebTransport2 = and2(QUICV12, base21("webtransport"), base21("certhash"), base21("certhash"));
var WebTransport2 = or19(and2(_WebTransport2, base21("p2p")), _WebTransport2);
var P2PWebRTCStar = or19(and2(WebSockets2, base21("p2p-webrtc-star"), base21("p2p")), and2(WebSocketsSecure2, base21("p2p-webrtc-star"), base21("p2p")), and2(WebSockets2, base21("p2p-webrtc-star")), and2(WebSocketsSecure2, base21("p2p-webrtc-star")));
var WebSocketStar = or19(and2(WebSockets2, base21("p2p-websocket-star"), base21("p2p")), and2(WebSocketsSecure2, base21("p2p-websocket-star"), base21("p2p")), and2(WebSockets2, base21("p2p-websocket-star")), and2(WebSocketsSecure2, base21("p2p-websocket-star")));
var P2PWebRTCDirect = or19(and2(HTTP2, base21("p2p-webrtc-direct"), base21("p2p")), and2(HTTPS2, base21("p2p-webrtc-direct"), base21("p2p")), and2(HTTP2, base21("p2p-webrtc-direct")), and2(HTTPS2, base21("p2p-webrtc-direct")));
var Reliable = or19(_WebSockets2, _WebSocketsSecure2, HTTP2, HTTPS2, P2PWebRTCStar, P2PWebRTCDirect, TCP2, UTP, QUIC2, DNS3, WebRTCDirect2, WebTransport2);
var Stardust = or19(and2(Reliable, base21("p2p-stardust"), base21("p2p")), and2(Reliable, base21("p2p-stardust")));
var _P2P2 = or19(and2(Reliable, base21("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect2, WebTransport2, base21("p2p"));
var _Circuit2 = or19(and2(_P2P2, base21("p2p-circuit"), _P2P2), and2(_P2P2, base21("p2p-circuit")), and2(base21("p2p-circuit"), _P2P2), and2(Reliable, base21("p2p-circuit")), and2(base21("p2p-circuit"), Reliable), base21("p2p-circuit"));
var CircuitRecursive = () => or19(and2(_Circuit2, CircuitRecursive), _Circuit2);
var Circuit2 = CircuitRecursive();
var P2P2 = or19(and2(Circuit2, _P2P2, Circuit2), and2(_P2P2, Circuit2), and2(Circuit2, _P2P2), Circuit2, _P2P2);
var WebRTC2 = or19(and2(Circuit2, base21("webrtc"), base21("p2p")), and2(Circuit2, base21("webrtc")), and2(Reliable, base21("webrtc"), base21("p2p")), and2(Reliable, base21("webrtc")), base21("webrtc"));
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and2(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or19(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base21(n) {
  const name29 = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name29) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name29) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name29;
    },
    matches,
    partialMatch
  };
}

// node_modules/@libp2p/bootstrap/dist/src/index.js
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_TAG_TTL = 12e4;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var Bootstrap = class extends TypedEventEmitter {
  static tag = "bootstrap";
  log;
  timer;
  list;
  timeout;
  components;
  _init;
  constructor(components, options2 = { list: [] }) {
    if (options2.list == null || options2.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options2.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options2.list) {
      if (!P2P2.matches(candidate)) {
        this.log.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        this.log.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma]
      };
      this.list.push(peerData);
    }
    this._init = options2;
  }
  [peerDiscoverySymbol] = this;
  [Symbol.toStringTag] = "@libp2p/bootstrap";
  [serviceCapabilities] = [
    "@libp2p/peer-discovery"
  ];
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
          }
        }
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/equals.js
function equals39(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports14 = {};
__export(base10_exports14, {
  base10: () => base1014
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bytes.js
var empty18 = new Uint8Array(0);
function equals40(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce18(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString28(str) {
  return new TextEncoder().encode(str);
}
function toString29(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/vendor/base-x.js
function base30(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src17 = base30;
var _brrp__multiformats_scope_baseX17 = src17;
var base_x_default18 = _brrp__multiformats_scope_baseX17;

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base.js
var Encoder18 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder19 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or20(this, decoder);
  }
};
var ComposedDecoder18 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or20(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or20(left, right) {
  return new ComposedDecoder18({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec18 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder18(name29, prefix, baseEncode);
    this.decoder = new Decoder19(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from31({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec18(name29, prefix, encode116, decode144);
}
function baseX17({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default18(alphabet27, name29);
  return from31({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce18(decode144(text))
  });
}
function decode79(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode63(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464818({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from31({
    prefix,
    name: name29,
    encode(input) {
      return encode63(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode79(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base10.js
var base1014 = baseX17({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports14 = {};
__export(base16_exports14, {
  base16: () => base1614,
  base16upper: () => base16upper14
});
var base1614 = rfc464818({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper14 = rfc464818({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports14 = {};
__export(base2_exports14, {
  base2: () => base214
});
var base214 = rfc464818({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports14 = {};
__export(base256emoji_exports14, {
  base256emoji: () => base256emoji14
});
var alphabet14 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars14 = alphabet14.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes14 = alphabet14.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode64(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars14[c];
    return p;
  }, "");
}
function decode80(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes14[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji14 = from31({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode64,
  decode: decode80
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports15 = {};
__export(base32_exports15, {
  base32: () => base3216,
  base32hex: () => base32hex16,
  base32hexpad: () => base32hexpad16,
  base32hexpadupper: () => base32hexpadupper16,
  base32hexupper: () => base32hexupper16,
  base32pad: () => base32pad16,
  base32padupper: () => base32padupper16,
  base32upper: () => base32upper16,
  base32z: () => base32z16
});
var base3216 = rfc464818({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper16 = rfc464818({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad16 = rfc464818({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper16 = rfc464818({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex16 = rfc464818({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper16 = rfc464818({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad16 = rfc464818({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper16 = rfc464818({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z16 = rfc464818({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports14 = {};
__export(base36_exports14, {
  base36: () => base3614,
  base36upper: () => base36upper14
});
var base3614 = baseX17({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper14 = baseX17({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports15 = {};
__export(base58_exports15, {
  base58btc: () => base58btc17,
  base58flickr: () => base58flickr17
});
var base58btc17 = baseX17({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr17 = baseX17({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports14 = {};
__export(base64_exports14, {
  base64: () => base6417,
  base64pad: () => base64pad17,
  base64url: () => base64url17,
  base64urlpad: () => base64urlpad17
});
var base6417 = rfc464818({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad17 = rfc464818({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url17 = rfc464818({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad17 = rfc464818({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports14 = {};
__export(base8_exports14, {
  base8: () => base814
});
var base814 = rfc464818({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports27 = {};
__export(identity_exports27, {
  identity: () => identity27
});
var identity27 = from31({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString29(buf3),
  decode: (str) => fromString28(str)
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder18 = new TextEncoder();
var textDecoder17 = new TextDecoder();

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports28 = {};
__export(identity_exports28, {
  identity: () => identity28
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/vendor/varint.js
var encode_115 = encode65;
var MSB16 = 128;
var REST16 = 127;
var MSBALL15 = ~REST16;
var INT15 = Math.pow(2, 31);
function encode65(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT15) {
    out[offset++] = num & 255 | MSB16;
    num /= 128;
  }
  while (num & MSBALL15) {
    out[offset++] = num & 255 | MSB16;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode65.bytes = offset - oldOffset + 1;
  return out;
}
var decode81 = read16;
var MSB$115 = 128;
var REST$115 = 127;
function read16(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read16.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$115) << shift : (b & REST$115) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$115);
  read16.bytes = counter - offset;
  return res;
}
var N116 = Math.pow(2, 7);
var N216 = Math.pow(2, 14);
var N316 = Math.pow(2, 21);
var N416 = Math.pow(2, 28);
var N516 = Math.pow(2, 35);
var N616 = Math.pow(2, 42);
var N716 = Math.pow(2, 49);
var N815 = Math.pow(2, 56);
var N915 = Math.pow(2, 63);
var length16 = function(value) {
  return value < N116 ? 1 : value < N216 ? 2 : value < N316 ? 3 : value < N416 ? 4 : value < N516 ? 5 : value < N616 ? 6 : value < N716 ? 7 : value < N815 ? 8 : value < N915 ? 9 : 10;
};
var varint15 = {
  encode: encode_115,
  decode: decode81,
  encodingLength: length16
};
var _brrp_varint15 = varint15;
var varint_default15 = _brrp_varint15;

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/varint.js
function decode82(data, offset = 0) {
  const code33 = varint_default15.decode(data, offset);
  return [code33, varint_default15.decode.bytes];
}
function encodeTo15(int, target, offset = 0) {
  varint_default15.encode(int, target, offset);
  return target;
}
function encodingLength16(int) {
  return varint_default15.encodingLength(int);
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/digest.js
function create17(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength16(code33);
  const digestOffset = sizeOffset + encodingLength16(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo15(code33, bytes3, 0);
  encodeTo15(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest15(code33, size, digest27, bytes3);
}
function decode83(multihash) {
  const bytes3 = coerce18(multihash);
  const [code33, sizeOffset] = decode82(bytes3);
  const [size, digestOffset] = decode82(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest15(code33, size, digest27, bytes3);
}
function equals41(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals40(a.bytes, data.bytes);
  }
}
var Digest15 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/identity.js
var code20 = 0;
var name14 = "identity";
var encode66 = coerce18;
function digest14(input) {
  return create17(code20, encode66(input));
}
var identity28 = { code: code20, name: name14, encode: encode66, digest: digest14 };

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports14 = {};
__export(sha2_browser_exports14, {
  sha256: () => sha25615,
  sha512: () => sha51215
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/hasher.js
function from32({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher14(name29, code33, encode116);
}
var Hasher14 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create17(this.code, result) : result.then((digest27) => create17(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha14(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25615 = from32({
  name: "sha2-256",
  code: 18,
  encode: sha14("SHA-256")
});
var sha51215 = from32({
  name: "sha2-512",
  code: 19,
  encode: sha14("SHA-512")
});

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/cid.js
function format15(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV015(bytes3, baseCache15(link), base45 ?? base58btc17.encoder);
    default:
      return toStringV115(bytes3, baseCache15(link), base45 ?? base3216.encoder);
  }
}
var cache16 = /* @__PURE__ */ new WeakMap();
function baseCache15(cid) {
  const baseCache28 = cache16.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache16.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID15 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE15) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE15) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create17(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals41(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format15(this, base45);
  }
  toJSON() {
    return { "/": format15(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID15(version3, code33, multihash.bytes));
    } else if (value[cidSymbol15] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode83(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE15) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE15}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID15(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE15, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce18(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest15(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode82(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE15;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes15(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache15(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes15(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc17;
      return [
        base58btc17.prefix,
        decoder.decode(`${base58btc17.prefix}${source}`)
      ];
    }
    case base58btc17.prefix: {
      const decoder = base45 ?? base58btc17;
      return [base58btc17.prefix, decoder.decode(source)];
    }
    case base3216.prefix: {
      const decoder = base45 ?? base3216;
      return [base3216.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV015(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc17.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV115(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE15 = 112;
var SHA_256_CODE15 = 18;
function encodeCID15(version3, code33, multihash) {
  const codeOffset = encodingLength16(version3);
  const hashOffset = codeOffset + encodingLength16(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo15(version3, bytes3, 0);
  encodeTo15(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol15 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/basics.js
var bases14 = { ...identity_exports27, ...base2_exports14, ...base8_exports14, ...base10_exports14, ...base16_exports14, ...base32_exports15, ...base36_exports14, ...base58_exports15, ...base64_exports14, ...base256emoji_exports14 };
var hashes14 = { ...sha2_browser_exports14, ...identity_exports28 };

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe17(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec15(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string15 = createCodec15("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii14 = createCodec15("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe17(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES14 = {
  utf8: string15,
  "utf-8": string15,
  hex: bases14.base16,
  latin1: ascii14,
  ascii: ascii14,
  binary: ascii14,
  ...bases14
};
var bases_default14 = BASES14;

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/from-string.js
function fromString29(string27, encoding = "utf8") {
  const base45 = bases_default14[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w2.uint32(26);
          w2.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w2.uint32(42);
          w2.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader.bytes();
              break;
            case 2:
              obj.payloadType = reader.bytes();
              break;
            case 3:
              obj.payload = reader.bytes();
              break;
            case 5:
              obj.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf3) => {
    return decodeMessage(buf3, Envelope2.codec());
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var RecordEnvelope = class _RecordEnvelope {
  /**
   * Unmarshal a serialized Envelope protobuf message
   */
  static createFromProtobuf = async (data) => {
    const envelopeData = Envelope.decode(data);
    const peerId2 = await peerIdFromKeys(envelopeData.publicKey);
    return new _RecordEnvelope({
      peerId: peerId2,
      payloadType: envelopeData.payloadType,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  /**
   * Seal marshals the given Record, places the marshaled bytes inside an Envelope
   * and signs it with the given peerId's private key
   */
  static seal = async (record, peerId2) => {
    if (peerId2.privateKey == null) {
      throw new Error("Missing private key");
    }
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const key = await unmarshalPrivateKey3(peerId2.privateKey);
    const signature = await key.sign(signData.subarray());
    return new _RecordEnvelope({
      peerId: peerId2,
      payloadType,
      payload,
      signature
    });
  };
  /**
   * Open and certify a given marshalled envelope.
   * Data is unmarshalled and the signature validated for the given domain.
   */
  static openAndCertify = async (data, domain) => {
    const envelope = await _RecordEnvelope.createFromProtobuf(data);
    const valid = await envelope.validate(domain);
    if (!valid) {
      throw new CodeError("envelope signature is not valid for the given domain", codes2.ERR_SIGNATURE_NOT_VALID);
    }
    return envelope;
  };
  peerId;
  payloadType;
  payload;
  signature;
  marshaled;
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    const { peerId: peerId2, payloadType, payload, signature } = init;
    this.peerId = peerId2;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals39(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey2(this.peerId.publicKey);
    return key.verify(signData.subarray(), this.signature);
  }
};
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString29(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf3) => {
      return decodeMessage(buf3, AddressInfo2.codec());
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w2.uint32(16);
          w2.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader.bytes();
              break;
            case 2:
              obj.seq = reader.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf3) => {
    return decodeMessage(buf3, PeerRecord3.codec());
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord2 = class _PeerRecord {
  /**
   * Unmarshal Peer Record Protobuf
   */
  static createFromProtobuf = (buf3) => {
    const peerRecord = PeerRecord.decode(buf3);
    const peerId2 = peerIdFromBytes(peerRecord.peerId);
    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
    const seqNumber = peerRecord.seq;
    return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
  };
  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  peerId;
  multiaddrs;
  seqNumber;
  domain = _PeerRecord.DOMAIN;
  codec = _PeerRecord.CODEC;
  marshaled;
  constructor(init) {
    const { peerId: peerId2, multiaddrs, seqNumber } = init;
    this.peerId = peerId2;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};

// node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options2) => {
      const value = await lp.read(options2);
      return proto.decode(value);
    },
    write: async (message2, proto, options2) => {
      await lp.write(proto.encode(message2), options2);
    },
    writeV: async (messages2, proto, options2) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options2);
    },
    pb: (proto) => {
      return {
        read: async (options2) => W.read(proto, options2),
        write: async (d2, options2) => W.write(d2, proto, options2),
        writeV: async (d2, options2) => W.writeV(d2, proto, options2),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var CIRCUIT_PROTO_CODE = 290;
var DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 1e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var RELAY_TAG = "circuit-relay-relay";
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS = 300;
var ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL";
var ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED";
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// node_modules/@libp2p/circuit-relay-v2/node_modules/uint8arrays/dist/src/alloc.js
function alloc9(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type3;
  (function(Type4) {
    Type4["RESERVE"] = "RESERVE";
    Type4["CONNECT"] = "CONNECT";
    Type4["STATUS"] = "STATUS";
  })(Type3 = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w2);
        }
        if (obj.peer != null) {
          w2.uint32(18);
          Peer.codec().encode(obj.peer, w2);
        }
        if (obj.reservation != null) {
          w2.uint32(26);
          Reservation.codec().encode(obj.reservation, w2);
        }
        if (obj.limit != null) {
          w2.uint32(34);
          Limit.codec().encode(obj.limit, w2);
        }
        if (obj.status != null) {
          w2.uint32(40);
          Status.codec().encode(obj.status, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf3, opts) => {
    return decodeMessage(buf3, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type3;
  (function(Type4) {
    Type4["CONNECT"] = "CONNECT";
    Type4["STATUS"] = "STATUS";
  })(Type3 = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w2);
        }
        if (obj.peer != null) {
          w2.uint32(18);
          Peer.codec().encode(obj.peer, w2);
        }
        if (obj.limit != null) {
          w2.uint32(26);
          Limit.codec().encode(obj.limit, w2);
        }
        if (obj.status != null) {
          w2.uint32(32);
          Status.codec().encode(obj.status, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf3, opts) => {
    return decodeMessage(buf3, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          id: alloc9(0),
          addrs: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new CodeError2('decode error - map field "addrs" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf3, opts) => {
    return decodeMessage(buf3, Peer3.codec(), opts);
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w2.uint32(8);
          w2.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w2.uint32(26);
          w2.bytes(obj.voucher);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new CodeError2('decode error - map field "addrs" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf3, opts) => {
    return decodeMessage(buf3, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.duration != null) {
          w2.uint32(8);
          w2.uint32(obj.duration);
        }
        if (obj.data != null) {
          w2.uint32(16);
          w2.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf3, opts) => {
    return decodeMessage(buf3, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w2.uint32(24);
          w2.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          relay: alloc9(0),
          peer: alloc9(0),
          expiration: 0n
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf3, opts) => {
    return decodeMessage(buf3, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));

// node_modules/@libp2p/circuit-relay-v2/node_modules/any-signal/dist/src/index.js
function anySignal4(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bytes.js
var empty19 = new Uint8Array(0);
function equals42(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce19(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/vendor/base-x.js
function base31(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src18 = base31;
var _brrp__multiformats_scope_baseX18 = src18;
var base_x_default19 = _brrp__multiformats_scope_baseX18;

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base.js
var Encoder19 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder20 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or21(this, decoder);
  }
};
var ComposedDecoder19 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or21(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or21(left, right) {
  return new ComposedDecoder19({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec19 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder19(name29, prefix, baseEncode);
    this.decoder = new Decoder20(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from33({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec19(name29, prefix, encode116, decode144);
}
function baseX18({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default19(alphabet27, name29);
  return from33({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce19(decode144(text))
  });
}
function decode84(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode67(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464819({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from33({
    prefix,
    name: name29,
    encode(input) {
      return encode67(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode84(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base32.js
var base3217 = rfc464819({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper17 = rfc464819({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad17 = rfc464819({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper17 = rfc464819({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex17 = rfc464819({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper17 = rfc464819({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad17 = rfc464819({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper17 = rfc464819({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z17 = rfc464819({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base58.js
var base58btc18 = baseX18({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr18 = baseX18({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/vendor/varint.js
var encode_116 = encode68;
var MSB17 = 128;
var REST17 = 127;
var MSBALL16 = ~REST17;
var INT16 = Math.pow(2, 31);
function encode68(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT16) {
    out[offset++] = num & 255 | MSB17;
    num /= 128;
  }
  while (num & MSBALL16) {
    out[offset++] = num & 255 | MSB17;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode68.bytes = offset - oldOffset + 1;
  return out;
}
var decode85 = read17;
var MSB$116 = 128;
var REST$116 = 127;
function read17(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read17.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$116) << shift : (b & REST$116) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$116);
  read17.bytes = counter - offset;
  return res;
}
var N117 = Math.pow(2, 7);
var N217 = Math.pow(2, 14);
var N317 = Math.pow(2, 21);
var N417 = Math.pow(2, 28);
var N517 = Math.pow(2, 35);
var N617 = Math.pow(2, 42);
var N717 = Math.pow(2, 49);
var N816 = Math.pow(2, 56);
var N916 = Math.pow(2, 63);
var length17 = function(value) {
  return value < N117 ? 1 : value < N217 ? 2 : value < N317 ? 3 : value < N417 ? 4 : value < N517 ? 5 : value < N617 ? 6 : value < N717 ? 7 : value < N816 ? 8 : value < N916 ? 9 : 10;
};
var varint16 = {
  encode: encode_116,
  decode: decode85,
  encodingLength: length17
};
var _brrp_varint16 = varint16;
var varint_default16 = _brrp_varint16;

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/varint.js
function decode86(data, offset = 0) {
  const code33 = varint_default16.decode(data, offset);
  return [code33, varint_default16.decode.bytes];
}
function encodeTo16(int, target, offset = 0) {
  varint_default16.encode(int, target, offset);
  return target;
}
function encodingLength17(int) {
  return varint_default16.encodingLength(int);
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/digest.js
function create18(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength17(code33);
  const digestOffset = sizeOffset + encodingLength17(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo16(code33, bytes3, 0);
  encodeTo16(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest16(code33, size, digest27, bytes3);
}
function decode87(multihash) {
  const bytes3 = coerce19(multihash);
  const [code33, sizeOffset] = decode86(bytes3);
  const [size, digestOffset] = decode86(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest16(code33, size, digest27, bytes3);
}
function equals43(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals42(a.bytes, data.bytes);
  }
}
var Digest16 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/cid.js
function format16(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV016(bytes3, baseCache16(link), base45 ?? base58btc18.encoder);
    default:
      return toStringV116(bytes3, baseCache16(link), base45 ?? base3217.encoder);
  }
}
var cache17 = /* @__PURE__ */ new WeakMap();
function baseCache16(cid) {
  const baseCache28 = cache17.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache17.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID16 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE16) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE16) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create18(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals43(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format16(this, base45);
  }
  toJSON() {
    return { "/": format16(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID16(version3, code33, multihash.bytes));
    } else if (value[cidSymbol16] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode87(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE16) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE16}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID16(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE16, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce19(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest16(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode86(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE16;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes16(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache16(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes16(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc18;
      return [
        base58btc18.prefix,
        decoder.decode(`${base58btc18.prefix}${source}`)
      ];
    }
    case base58btc18.prefix: {
      const decoder = base45 ?? base58btc18;
      return [base58btc18.prefix, decoder.decode(source)];
    }
    case base3217.prefix: {
      const decoder = base45 ?? base3217;
      return [base3217.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV016(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc18.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV116(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE16 = 112;
var SHA_256_CODE16 = 18;
function encodeCID16(version3, code33, multihash) {
  const codeOffset = encodingLength17(version3);
  const hashOffset = codeOffset + encodingLength17(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo16(version3, bytes3, 0);
  encodeTo16(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol16 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/hasher.js
function from34({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher15(name29, code33, encode116);
}
var Hasher15 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create18(this.code, result) : result.then((digest27) => create18(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha15(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25616 = from34({
  name: "sha2-256",
  code: 18,
  encode: sha15("SHA-256")
});
var sha51216 = from34({
  name: "sha2-512",
  code: 19,
  encode: sha15("SHA-512")
});

// node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
function streamToMaConnection(props) {
  const { stream, remoteAddr, logger: logger2 } = props;
  const log10 = logger2.forComponent("libp2p:stream:converter");
  let closedRead = false;
  let closedWrite = false;
  const streamClose = stream.close.bind(stream);
  stream.close = async (options2) => {
    await streamClose(options2);
    close(true);
  };
  const streamAbort = stream.abort.bind(stream);
  stream.abort = (err) => {
    streamAbort(err);
    close(true);
  };
  const streamSink = stream.sink.bind(stream);
  stream.sink = async (source) => {
    try {
      await streamSink(source);
    } catch (err) {
      if (err.type !== "aborted") {
        log10.error("%s error in sink", remoteAddr, err);
      }
    } finally {
      closedWrite = true;
      close();
    }
  };
  const maConn = {
    log: log10,
    sink: stream.sink,
    source: async function* () {
      try {
        for await (const list of stream.source) {
          if (list instanceof Uint8Array) {
            yield list;
          } else {
            yield* list;
          }
        }
      } finally {
        closedRead = true;
        close();
      }
    }(),
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    close: stream.close,
    abort: stream.abort
  };
  function close(force) {
    if (force === true) {
      closedRead = true;
      closedWrite = true;
    }
    if (closedRead && closedWrite && maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }
  return maConn;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  peerStore;
  registrar;
  connectionManager;
  randomWalk;
  started;
  running;
  topologyId;
  log;
  discoveryController;
  filter;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.started = false;
    this.running = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.connectionManager = components.connectionManager;
    this.randomWalk = components.randomWalk;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners2(Infinity, this.discoveryController.signal);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId2) => {
        this.log("discovered relay %p", peerId2);
        this.safeDispatchEvent("relay:discover", { detail: peerId2 });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.discoveryController?.abort();
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners2(Infinity, this.discoveryController.signal);
    Promise.resolve().then(async () => {
      this.log("searching peer store for relays");
      const peers = await this.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          () => Math.random() < 0.5 ? 1 : -1
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (this.connectionManager.getConnections(peer.id)?.length > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        this.log.trace("wait for space in queue for %p", peer.id);
        await raceSignal(queue.onSizeLessThan(10), this.discoveryController.signal);
        this.log("adding random peer %p to dial queue (length: %d)", peer.id, queue.size);
        queue.add(async () => {
          const signal = anySignal4([this.discoveryController.signal, AbortSignal.timeout(5e3)]);
          setMaxListeners2(Infinity, signal);
          try {
            await this.connectionManager.openConnection(peer.id, { signal });
          } finally {
            signal.clear();
          }
        }, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p", peer.id, err);
        });
      }
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network", err);
      }
    });
  }
  stopDiscovery() {
    this.log("stop discovery");
    this.running = false;
    this.discoveryController?.abort();
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  connectionManager;
  relayStore;
  listeningAddrs;
  log;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.relayStore = components.relayStore;
    this.listeningAddrs = new PeerMap();
    this.relayStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
  }
  _onRemoveRelayPeer = (evt) => {
    this.#removeRelayPeer(evt.detail);
  };
  async listen(addr) {
    this.log("listen on %a", addr);
    const relayAddr = addr.decapsulate("/p2p-circuit");
    const relayConn = await this.connectionManager.openConnection(relayAddr);
    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
      this.log("making reservation on peer %p", relayConn.remotePeer);
      await this.relayStore.addRelay(relayConn.remotePeer, "configured");
      return;
    }
    const reservation = this.relayStore.getReservation(relayConn.remotePeer);
    if (reservation == null) {
      throw new CodeError("Did not have reservation after making reservation", "ERR_NO_RESERVATION");
    }
    if (this.listeningAddrs.has(relayConn.remotePeer)) {
      this.log("already listening on relay %p", relayConn.remotePeer);
      return;
    }
    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map((buf3) => {
      return multiaddr(buf3).encapsulate("/p2p-circuit");
    }));
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  async close() {
  }
  #removeRelayPeer(peerId2) {
    const had = this.listeningAddrs.has(peerId2);
    this.log("relay peer removed %p - had reservation", peerId2, had);
    this.listeningAddrs.delete(peerId2);
    if (had) {
      this.log.trace("removing relay event listener for peer %p", peerId2);
      this.relayStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
      this.safeDispatchEvent("close", {});
    }
  }
};
function createListener(options2) {
  return new CircuitRelayTransportListener(options2);
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/uint8arrays/dist/src/equals.js
function equals44(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore = class extends TypedEventEmitter {
  peerId;
  connectionManager;
  transportManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  maxDiscoveredRelays;
  maxReservationQueueLength;
  reservationCompletionTimeout;
  started;
  log;
  relayFilter;
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.maxDiscoveredRelays = init?.discoverRelays ?? 0;
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createBloomFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("peer:disconnect", (evt) => {
      this.#removeRelay(evt.detail);
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    if (this.reservations.size < this.maxDiscoveredRelays) {
      this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId2, type) {
    if (this.peerId.equals(peerId2)) {
      this.log("not trying to use self as relay");
      return;
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      this.log("not adding potential relay peer %p as the queue is full", peerId2);
      return;
    }
    if (this.reserveQueue.has(peerId2)) {
      this.log("potential relay peer %p is already in the reservation queue", peerId2);
      return;
    }
    if (this.relayFilter.has(peerId2.toBytes())) {
      this.log("potential relay peer %p has failed previously, not trying again", peerId2);
      return;
    }
    this.log("try to reserve relay slot with %p", peerId2);
    await this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId2);
        if (existingReservation != null) {
          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have reservation on relay peer %p and it expires in more than 10 minutes", peerId2);
            return;
          }
          clearTimeout(existingReservation.timeout);
          this.reservations.delete(peerId2);
        }
        if (type === "discovered" && [...this.reservations.values()].reduce((acc, curr) => {
          if (curr.type === "discovered") {
            acc++;
          }
          return acc;
        }, 0) >= this.maxDiscoveredRelays) {
          this.log("already have enough discovered relays");
          return;
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners2(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId2, {
          signal
        });
        if (connection.remoteAddr.protoNames().includes("p2p-circuit")) {
          this.log("not creating reservation over relayed connection");
          return;
        }
        const reservation = await this.#createReservation(connection, {
          signal
        });
        this.log("created reservation on relay peer %p", peerId2);
        const expiration = getExpirationMilliseconds(reservation.expire);
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.addRelay(peerId2, type).catch((err) => {
            this.log.error("could not refresh reservation to relay %p", peerId2, err);
          });
        }, timeoutDuration);
        this.reservations.set(peerId2, {
          timeout,
          reservation,
          type
        });
        await this.peerStore.merge(peerId2, {
          tags: {
            [RELAY_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        await this.transportManager.listen([multiaddr(`/p2p/${peerId2.toString()}/p2p-circuit`)]);
        this.safeDispatchEvent("relay:created-reservation", {
          detail: peerId2
        });
      } catch (err) {
        this.log.error("could not reserve slot on %p after %dms", peerId2, Date.now() - start2, err);
        const reservation = this.reservations.get(peerId2);
        if (reservation != null) {
          clearTimeout(reservation.timeout);
        }
        this.reservations.delete(peerId2);
        this.relayFilter.add(peerId2.toBytes());
      }
    }, {
      peerId: peerId2
    });
  }
  hasReservation(peerId2) {
    return this.reservations.has(peerId2);
  }
  getReservation(peerId2) {
    return this.reservations.get(peerId2)?.reservation;
  }
  reservationCount() {
    return this.reservations.size;
  }
  async #createReservation(connection, options2) {
    options2.signal?.throwIfAborted();
    this.log("requesting reservation from %p", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options2);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    await hopstr.write({ type: HopMessage.Type.RESERVE }, options2);
    let response;
    try {
      response = await hopstr.read(options2);
    } catch (err) {
      stream.abort(err);
      throw err;
    } finally {
      if (stream.status !== "closed") {
        await stream.close(options2);
      }
    }
    if (response.status === Status.OK && response.reservation != null) {
      let hasRelayAddress = false;
      const relayAddressBytes = connection.remoteAddr.bytes;
      for (const buf3 of response.reservation.addrs) {
        if (equals44(relayAddressBytes, buf3)) {
          hasRelayAddress = true;
          break;
        }
      }
      if (!hasRelayAddress) {
        response.reservation.addrs.push(relayAddressBytes);
      }
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    this.log.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  #removeRelay(peerId2) {
    const existingReservation = this.reservations.get(peerId2);
    if (existingReservation == null) {
      return;
    }
    this.log("connection to relay %p closed, removing reservation from local store", peerId2);
    clearTimeout(existingReservation.timeout);
    this.reservations.delete(peerId2);
    this.safeDispatchEvent("relay:removed", { detail: peerId2 });
    if (this.reservations.size < this.maxDiscoveredRelays) {
      this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/transport.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var CircuitRelayTransport = class {
  discovery;
  registrar;
  peerStore;
  connectionManager;
  transportManager;
  peerId;
  upgrader;
  addressManager;
  connectionGater;
  reservationStore;
  logger;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  stopTimeout;
  started;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.stopTimeout = init.stopTimeout ?? defaults.stopTimeout;
    const discoverRelays = init.discoverRelays ?? 0;
    if (discoverRelays > 0) {
      this.discovery = new RelayDiscovery(components, {
        filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
      });
      this.discovery.addEventListener("relay:discover", (evt) => {
        this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
          this.log.error("could not add discovered relay %p", evt.detail, err);
        });
      });
    }
    this.reservationStore = new ReservationStore(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:created-reservation", () => {
      if (this.reservationStore.reservationCount() >= discoverRelays) {
        this.discovery?.stopDiscovery();
      }
    });
    this.started = false;
  }
  [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
  [serviceCapabilities] = [
    "@libp2p/transport",
    "@libp2p/circuit-relay-v2-transport"
  ];
  get [serviceDependencies]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  [transportSymbol] = true;
  isStarted() {
    return this.started;
  }
  async start() {
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      void this.onStop(data).catch((err) => {
        this.log.error("error while handling STOP protocol", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnTransientConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    await stop(this.discovery, this.reservationStore);
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options2) {
    if (ma.protoCodes().filter((code33) => code33 === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      this.log.error(errMsg, ma);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;
      this.log.error(errMsg);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.connectionManager.openConnection(relayPeer, options2);
      disconnectOnFailure = true;
    } else {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC);
      return await this.connectV2({
        stream,
        connection: relayConnection,
        destinationPeer,
        destinationAddr,
        relayAddr,
        ma,
        disconnectOnFailure,
        onProgress: options2.onProgress
      });
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
      if (stream != null) {
        stream.abort(err);
      }
      disconnectOnFailure && await relayConnection.close();
      throw err;
    }
  }
  async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure, onProgress }) {
    try {
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toBytes(),
          addrs: [multiaddr(destinationAddr).bytes]
        }
      });
      onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read();
      if (status.status !== Status.OK) {
        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`, ERR_HOP_REQUEST_FAILED);
      }
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
        logger: this.logger
      });
      this.log("new outbound relayed connection %a", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn, {
        transient: status.limit != null,
        onProgress
      });
    } catch (err) {
      this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);
      disconnectOnFailure && await connection.close();
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options2) {
    return createListener({
      connectionManager: this.connectionManager,
      relayStore: this.reservationStore,
      logger: this.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit2.matches(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }) {
    if (!this.reservationStore.hasReservation(connection.remotePeer)) {
      try {
        this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
        await this.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
      } catch (err) {
        this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
      }
    }
    const signal = AbortSignal.timeout(this.stopTimeout);
    const pbstr = pbStream(stream).pb(StopMessage);
    const request = await pbstr.read({
      signal
    });
    this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
    if (request?.type === void 0) {
      this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (request.type !== StopMessage.Type.CONNECT) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (!isValidStop(request)) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    const remotePeerId = peerIdFromBytes(request.peer.id);
    if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
      this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
        signal
      });
      await stream.close();
      return;
    }
    this.log.trace("sending success response to %p", connection.remotePeer);
    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
      signal
    });
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap().unwrap(),
      remoteAddr,
      localAddr,
      logger: this.logger
    });
    this.log("new inbound relayed connection %a", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn, {
      transient: request.limit != null
    });
    this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}

// node_modules/delay/index.js
var createAbortError = () => {
  const error = new Error("Delay aborted");
  error.name = "AbortError";
  return error;
};
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value, signal } = {}) => {
    if (signal?.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay = createDelay();
var delay_default = delay;

// node_modules/@libp2p/dcutr/dist/src/pb/message.js
var HolePunch;
(function(HolePunch2) {
  let Type3;
  (function(Type4) {
    Type4["UNUSED"] = "UNUSED";
    Type4["CONNECT"] = "CONNECT";
    Type4["SYNC"] = "SYNC";
  })(Type3 = HolePunch2.Type || (HolePunch2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["UNUSED"] = 0] = "UNUSED";
    __TypeValues2[__TypeValues2["CONNECT"] = 100] = "CONNECT";
    __TypeValues2[__TypeValues2["SYNC"] = 300] = "SYNC";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = HolePunch2.Type || (HolePunch2.Type = {}));
  let _codec;
  HolePunch2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          HolePunch2.Type.codec().encode(obj.type, w2);
        }
        if (obj.observedAddresses != null) {
          for (const value of obj.observedAddresses) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          observedAddresses: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = HolePunch2.Type.codec().decode(reader);
              break;
            case 2:
              obj.observedAddresses.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HolePunch2.encode = (obj) => {
    return encodeMessage(obj, HolePunch2.codec());
  };
  HolePunch2.decode = (buf3) => {
    return decodeMessage(buf3, HolePunch2.codec());
  };
})(HolePunch || (HolePunch = {}));

// node_modules/@libp2p/dcutr/dist/src/utils.js
function isPublicAndDialable(ma, transportManager) {
  if (Circuit.matches(ma)) {
    return false;
  }
  const transport = transportManager.dialTransportForMultiaddr(ma);
  if (transport == null) {
    return false;
  }
  if (DNS2.matches(ma)) {
    return true;
  }
  if (!IP.matches(ma)) {
    return false;
  }
  return isPrivateIp(ma.toOptions().host) === false;
}

// node_modules/@libp2p/dcutr/dist/src/dcutr.js
var MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;
var DCUTR_DIAL_PRIORITY = 100;
var defaultValues2 = {
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27
  timeout: 5e3,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28
  retries: 3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1
};
var DefaultDCUtRService = class {
  started;
  timeout;
  retries;
  maxInboundStreams;
  maxOutboundStreams;
  peerStore;
  registrar;
  connectionManager;
  addressManager;
  transportManager;
  topologyId;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:dcutr");
    this.started = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.timeout = init.timeout ?? defaultValues2.timeout;
    this.retries = init.retries ?? defaultValues2.retries;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues2.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues2.maxOutboundStreams;
  }
  [Symbol.toStringTag] = "@libp2p/dcutr";
  [serviceDependencies] = [
    "@libp2p/identify"
  ];
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.topologyId = await this.registrar.register(multicodec, {
      notifyOnTransient: true,
      onConnect: (peerId2, connection) => {
        if (!connection.transient) {
          return;
        }
        if (connection.direction !== "inbound") {
          return;
        }
        this.upgradeInbound(connection).catch((err) => {
          this.log.error("error during outgoing DCUtR attempt", err);
        });
      }
    });
    await this.registrar.handle(multicodec, (data) => {
      void this.handleIncomingUpgrade(data.stream, data.connection).catch((err) => {
        this.log.error("error during incoming DCUtR attempt", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: true
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(multicodec);
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Perform the inbound connection upgrade as B
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async upgradeInbound(relayedConnection) {
    if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {
      return;
    }
    let stream;
    for (let i = 0; i < this.retries; i++) {
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      try {
        stream = await relayedConnection.newStream([multicodec], {
          signal: options2.signal,
          runOnTransientConnection: true
        });
        const pb = pbStream(stream, {
          maxDataLength: MAX_DCUTR_MESSAGE_SIZE
        }).pb(HolePunch);
        this.log("B sending connect to %p", relayedConnection.remotePeer);
        const connectTimer = Date.now();
        await pb.write({
          type: HolePunch.Type.CONNECT,
          observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
        }, options2);
        this.log("B receiving connect from %p", relayedConnection.remotePeer);
        const connect2 = await pb.read(options2);
        if (connect2.type !== HolePunch.Type.CONNECT) {
          this.log("A sent wrong message type");
          throw new CodeError("DCUtR message type was incorrect", ERR_INVALID_MESSAGE);
        }
        const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
        if (multiaddrs.length === 0) {
          this.log("A did not have any dialable multiaddrs");
          throw new CodeError("DCUtR connect message had no multiaddrs", ERR_INVALID_MESSAGE);
        }
        const rtt = Date.now() - connectTimer;
        this.log("A sending sync, rtt %dms", rtt);
        await pb.write({
          type: HolePunch.Type.SYNC,
          observedAddresses: []
        }, options2);
        this.log("A waiting for half RTT");
        await delay_default(rtt / 2);
        this.log("B dialing", multiaddrs);
        const conn = await this.connectionManager.openConnection(multiaddrs, {
          signal: options2.signal,
          priority: DCUTR_DIAL_PRIORITY
        });
        this.log("DCUtR to %p succeeded to address %a, closing relayed connection", relayedConnection.remotePeer, conn.remoteAddr);
        await relayedConnection.close(options2);
        break;
      } catch (err) {
        this.log.error("error while attempting DCUtR on attempt %d of %d", i + 1, this.retries, err);
        stream?.abort(err);
        if (i === this.retries) {
          throw err;
        }
      } finally {
        if (stream != null) {
          await stream.close(options2);
        }
      }
    }
  }
  /**
   * This is performed when A has dialed B via a relay but A also has a public
   * address that B can dial directly
   */
  async attemptUnilateralConnectionUpgrade(relayedConnection) {
    const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);
    const publicAddresses = peerInfo.addresses.map((address) => {
      const ma = address.multiaddr;
      if (ma.getPeerId() == null) {
        return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);
      }
      return ma;
    }).filter((ma) => {
      return isPublicAndDialable(ma, this.transportManager);
    });
    if (publicAddresses.length > 0) {
      const signal = AbortSignal.timeout(this.timeout);
      try {
        this.log("attempting unilateral connection upgrade to %a", publicAddresses);
        const connection = await this.connectionManager.openConnection(publicAddresses, {
          signal,
          force: true
        });
        if (connection.transient) {
          throw new Error("Could not open a new, non-transient, connection");
        }
        this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
        await relayedConnection.close({
          signal
        });
        return true;
      } catch (err) {
        this.log.error("unilateral connection upgrade to %p on addresses %a failed", relayedConnection.remotePeer, publicAddresses, err);
      }
    } else {
      this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", relayedConnection.remotePeer);
    }
    return false;
  }
  /**
   * Perform the connection upgrade as A
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async handleIncomingUpgrade(stream, relayedConnection) {
    const options2 = {
      signal: AbortSignal.timeout(this.timeout)
    };
    try {
      const pb = pbStream(stream, {
        maxDataLength: MAX_DCUTR_MESSAGE_SIZE
      }).pb(HolePunch);
      this.log("A receiving connect");
      const connect2 = await pb.read(options2);
      if (connect2.type !== HolePunch.Type.CONNECT) {
        this.log("B sent wrong message type");
        throw new CodeError("DCUtR message type was incorrect", ERR_INVALID_MESSAGE);
      }
      if (connect2.observedAddresses.length === 0) {
        this.log("B sent no multiaddrs");
        throw new CodeError("DCUtR connect message had no multiaddrs", ERR_INVALID_MESSAGE);
      }
      const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
      if (multiaddrs.length === 0) {
        this.log("B had no dialable multiaddrs");
        throw new CodeError("DCUtR connect message had no dialable multiaddrs", ERR_INVALID_MESSAGE);
      }
      this.log("A sending connect");
      await pb.write({
        type: HolePunch.Type.CONNECT,
        observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
      });
      this.log("A receiving sync");
      const sync = await pb.read(options2);
      if (sync.type !== HolePunch.Type.SYNC) {
        throw new CodeError("DCUtR message type was incorrect", ERR_INVALID_MESSAGE);
      }
      this.log("A dialing", multiaddrs);
      const connection = await this.connectionManager.openConnection(multiaddrs, {
        signal: options2.signal,
        priority: DCUTR_DIAL_PRIORITY,
        force: true
      });
      this.log("DCUtR to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
      await relayedConnection.close(options2);
    } catch (err) {
      this.log.error("incoming DCUtR from %p failed", relayedConnection.remotePeer, err);
      stream.abort(err);
    } finally {
      await stream.close(options2);
    }
  }
  /**
   * Takes the `addr` and converts it to a Multiaddr if possible
   */
  getDialableMultiaddrs(addrs) {
    const output3 = [];
    for (const addr of addrs) {
      if (addr == null || addr.length === 0) {
        continue;
      }
      try {
        const ma = multiaddr(addr);
        if (!isPublicAndDialable(ma, this.transportManager)) {
          continue;
        }
        output3.push(ma);
      } catch {
      }
    }
    return output3;
  }
};

// node_modules/@libp2p/dcutr/dist/src/index.js
var multicodec = "/libp2p/dcutr";
function dcutr(init = {}) {
  return (components) => new DefaultDCUtRService(components, init);
}

// node_modules/@libp2p/identify/node_modules/it-drain/dist/src/index.js
function isAsyncIterable21(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain4(source) {
  if (isAsyncIterable21(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default29 = drain4;

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports15 = {};
__export(base10_exports15, {
  base10: () => base1015
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bytes.js
var empty20 = new Uint8Array(0);
function equals45(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce20(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString30(str) {
  return new TextEncoder().encode(str);
}
function toString30(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/vendor/base-x.js
function base33(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src19 = base33;
var _brrp__multiformats_scope_baseX19 = src19;
var base_x_default20 = _brrp__multiformats_scope_baseX19;

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base.js
var Encoder20 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder21 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or22(this, decoder);
  }
};
var ComposedDecoder20 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or22(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or22(left, right) {
  return new ComposedDecoder20({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec20 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder20(name29, prefix, baseEncode);
    this.decoder = new Decoder21(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from35({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec20(name29, prefix, encode116, decode144);
}
function baseX19({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default20(alphabet27, name29);
  return from35({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce20(decode144(text))
  });
}
function decode88(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode69(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464820({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from35({
    prefix,
    name: name29,
    encode(input) {
      return encode69(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode88(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base10.js
var base1015 = baseX19({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports15 = {};
__export(base16_exports15, {
  base16: () => base1615,
  base16upper: () => base16upper15
});
var base1615 = rfc464820({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper15 = rfc464820({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports15 = {};
__export(base2_exports15, {
  base2: () => base215
});
var base215 = rfc464820({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports15 = {};
__export(base256emoji_exports15, {
  base256emoji: () => base256emoji15
});
var alphabet15 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars15 = alphabet15.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes15 = alphabet15.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode70(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars15[c];
    return p;
  }, "");
}
function decode89(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes15[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji15 = from35({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode70,
  decode: decode89
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports16 = {};
__export(base32_exports16, {
  base32: () => base3218,
  base32hex: () => base32hex18,
  base32hexpad: () => base32hexpad18,
  base32hexpadupper: () => base32hexpadupper18,
  base32hexupper: () => base32hexupper18,
  base32pad: () => base32pad18,
  base32padupper: () => base32padupper18,
  base32upper: () => base32upper18,
  base32z: () => base32z18
});
var base3218 = rfc464820({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper18 = rfc464820({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad18 = rfc464820({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper18 = rfc464820({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex18 = rfc464820({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper18 = rfc464820({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad18 = rfc464820({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper18 = rfc464820({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z18 = rfc464820({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports15 = {};
__export(base36_exports15, {
  base36: () => base3615,
  base36upper: () => base36upper15
});
var base3615 = baseX19({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper15 = baseX19({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports16 = {};
__export(base58_exports16, {
  base58btc: () => base58btc19,
  base58flickr: () => base58flickr19
});
var base58btc19 = baseX19({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr19 = baseX19({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports15 = {};
__export(base64_exports15, {
  base64: () => base6418,
  base64pad: () => base64pad18,
  base64url: () => base64url18,
  base64urlpad: () => base64urlpad18
});
var base6418 = rfc464820({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad18 = rfc464820({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url18 = rfc464820({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad18 = rfc464820({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports15 = {};
__export(base8_exports15, {
  base8: () => base815
});
var base815 = rfc464820({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports29 = {};
__export(identity_exports29, {
  identity: () => identity29
});
var identity29 = from35({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString30(buf3),
  decode: (str) => fromString30(str)
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder19 = new TextEncoder();
var textDecoder18 = new TextDecoder();

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports30 = {};
__export(identity_exports30, {
  identity: () => identity30
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/vendor/varint.js
var encode_117 = encode71;
var MSB18 = 128;
var REST18 = 127;
var MSBALL17 = ~REST18;
var INT17 = Math.pow(2, 31);
function encode71(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT17) {
    out[offset++] = num & 255 | MSB18;
    num /= 128;
  }
  while (num & MSBALL17) {
    out[offset++] = num & 255 | MSB18;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode71.bytes = offset - oldOffset + 1;
  return out;
}
var decode90 = read18;
var MSB$117 = 128;
var REST$117 = 127;
function read18(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read18.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$117) << shift : (b & REST$117) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$117);
  read18.bytes = counter - offset;
  return res;
}
var N118 = Math.pow(2, 7);
var N218 = Math.pow(2, 14);
var N318 = Math.pow(2, 21);
var N418 = Math.pow(2, 28);
var N518 = Math.pow(2, 35);
var N618 = Math.pow(2, 42);
var N718 = Math.pow(2, 49);
var N817 = Math.pow(2, 56);
var N917 = Math.pow(2, 63);
var length18 = function(value) {
  return value < N118 ? 1 : value < N218 ? 2 : value < N318 ? 3 : value < N418 ? 4 : value < N518 ? 5 : value < N618 ? 6 : value < N718 ? 7 : value < N817 ? 8 : value < N917 ? 9 : 10;
};
var varint17 = {
  encode: encode_117,
  decode: decode90,
  encodingLength: length18
};
var _brrp_varint17 = varint17;
var varint_default17 = _brrp_varint17;

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/varint.js
function decode91(data, offset = 0) {
  const code33 = varint_default17.decode(data, offset);
  return [code33, varint_default17.decode.bytes];
}
function encodeTo17(int, target, offset = 0) {
  varint_default17.encode(int, target, offset);
  return target;
}
function encodingLength18(int) {
  return varint_default17.encodingLength(int);
}

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/digest.js
function create19(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength18(code33);
  const digestOffset = sizeOffset + encodingLength18(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo17(code33, bytes3, 0);
  encodeTo17(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest17(code33, size, digest27, bytes3);
}
function decode92(multihash) {
  const bytes3 = coerce20(multihash);
  const [code33, sizeOffset] = decode91(bytes3);
  const [size, digestOffset] = decode91(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest17(code33, size, digest27, bytes3);
}
function equals46(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals45(a.bytes, data.bytes);
  }
}
var Digest17 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/identity.js
var code21 = 0;
var name15 = "identity";
var encode72 = coerce20;
function digest15(input) {
  return create19(code21, encode72(input));
}
var identity30 = { code: code21, name: name15, encode: encode72, digest: digest15 };

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports15 = {};
__export(sha2_browser_exports15, {
  sha256: () => sha25617,
  sha512: () => sha51217
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/hasher.js
function from36({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher16(name29, code33, encode116);
}
var Hasher16 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create19(this.code, result) : result.then((digest27) => create19(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha16(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25617 = from36({
  name: "sha2-256",
  code: 18,
  encode: sha16("SHA-256")
});
var sha51217 = from36({
  name: "sha2-512",
  code: 19,
  encode: sha16("SHA-512")
});

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/cid.js
function format17(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV017(bytes3, baseCache17(link), base45 ?? base58btc19.encoder);
    default:
      return toStringV117(bytes3, baseCache17(link), base45 ?? base3218.encoder);
  }
}
var cache18 = /* @__PURE__ */ new WeakMap();
function baseCache17(cid) {
  const baseCache28 = cache18.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache18.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID17 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE17) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE17) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create19(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals46(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format17(this, base45);
  }
  toJSON() {
    return { "/": format17(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID17(version3, code33, multihash.bytes));
    } else if (value[cidSymbol17] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode92(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE17) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE17}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID17(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE17, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce20(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest17(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode91(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE17;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes17(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache17(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes17(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc19;
      return [
        base58btc19.prefix,
        decoder.decode(`${base58btc19.prefix}${source}`)
      ];
    }
    case base58btc19.prefix: {
      const decoder = base45 ?? base58btc19;
      return [base58btc19.prefix, decoder.decode(source)];
    }
    case base3218.prefix: {
      const decoder = base45 ?? base3218;
      return [base3218.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV017(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc19.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV117(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE17 = 112;
var SHA_256_CODE17 = 18;
function encodeCID17(version3, code33, multihash) {
  const codeOffset = encodingLength18(version3);
  const hashOffset = codeOffset + encodingLength18(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo17(version3, bytes3, 0);
  encodeTo17(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol17 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/identify/node_modules/multiformats/dist/src/basics.js
var bases15 = { ...identity_exports29, ...base2_exports15, ...base8_exports15, ...base10_exports15, ...base16_exports15, ...base32_exports16, ...base36_exports15, ...base58_exports16, ...base64_exports15, ...base256emoji_exports15 };
var hashes15 = { ...sha2_browser_exports15, ...identity_exports30 };

// node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe18(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec16(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string16 = createCodec16("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii15 = createCodec16("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe18(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES15 = {
  utf8: string16,
  "utf-8": string16,
  hex: bases15.base16,
  latin1: ascii15,
  ascii: ascii15,
  binary: ascii15,
  ...bases15
};
var bases_default15 = BASES15;

// node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/from-string.js
function fromString31(string27, encoding = "utf8") {
  const base45 = bases_default15[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/to-string.js
function toString31(array, encoding = "utf8") {
  const base45 = bases_default15[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;

// node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.protocolVersion != null) {
          w2.uint32(42);
          w2.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w2.uint32(50);
          w2.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w2.uint32(10);
          w2.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w2.uint32(34);
          w2.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w2.uint32(26);
            w2.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w2.uint32(66);
          w2.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader.string();
              break;
            case 6:
              obj.agentVersion = reader.string();
              break;
            case 1:
              obj.publicKey = reader.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader.bytes());
              break;
            case 4:
              obj.observedAddr = reader.bytes();
              break;
            case 3:
              obj.protocols.push(reader.string());
              break;
            case 8:
              obj.signedPeerRecord = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf3) => {
    return decodeMessage(buf3, Identify3.codec());
  };
})(Identify || (Identify = {}));

// node_modules/wherearewe/src/index.js
var import_is_electron = __toESM(require_is_electron(), 1);
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + /* @__PURE__ */ (() => "_")() + "ENV"] === "test";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues3 = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnTransientConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
function getAgentVersion(nodeInfo, agentVersion) {
  if (agentVersion != null) {
    return agentVersion;
  }
  agentVersion = `${nodeInfo.name}/${nodeInfo.version}`;
  if (isNode || isElectronMain) {
    agentVersion += ` UserAgent=${globalThis.process.version}`;
  } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
    agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
  }
  return agentVersion;
}
async function consumeIdentifyMessage(peerStore, events2, log10, connection, message2) {
  log10("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new CodeError("message was null or undefined", "ERR_INVALID_MESSAGE");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf3) => ({
      isCertified: false,
      multiaddr: multiaddr(buf3)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    peer.publicKey = message2.publicKey;
    const peerId2 = await peerIdFromKeys(message2.publicKey);
    if (!peerId2.equals(connection.remotePeer)) {
      throw new CodeError("public key did not match remote PeerId", "ERR_INVALID_PUBLIC_KEY");
    }
  }
  let output3;
  if (message2.signedPeerRecord != null) {
    log10("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord2.DOMAIN);
    let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    if (!peerRecord.peerId.equals(envelope.peerId)) {
      throw new CodeError("signing key does not match PeerId in the PeerRecord", "ERR_INVALID_SIGNING_KEY");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new CodeError("signing key does not match remote PeerId", "ERR_INVALID_PEER_RECORD_KEY");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log10("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output3 = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log10("%p did not send a signed peer record", connection.remotePeer);
  }
  log10("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString31(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString31(message2.protocolVersion);
    }
    log10("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf3) => multiaddr(buf3)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output3,
    connection
  };
  events2.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  host;
  protocol;
  started;
  timeout;
  peerId;
  peerStore;
  registrar;
  addressManager;
  maxInboundStreams;
  maxOutboundStreams;
  maxMessageSize;
  maxObservedAddresses;
  events;
  runOnTransientConnection;
  log;
  constructor(components, init) {
    this.protocol = init.protocol;
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.events = components.events;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues3.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues3.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues3.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues3.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues3.runOnTransientConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
    };
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString31(this.host.agentVersion),
        ProtocolVersion: fromString31(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.protocol, (data) => {
      void this.handleProtocol(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// node_modules/@libp2p/identify/dist/src/identify-push.js
var IdentifyPush = class extends AbstractIdentify {
  connectionManager;
  concurrency;
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues3.concurrency;
    if (init.runOnSelfUpdate ?? defaultValues3.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        void this.push().catch((err) => {
          this.log.error(err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify-push"
  ];
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord2({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString31(peer.metadata.get("AgentVersion") ?? fromString31(this.host.agentVersion));
    const protocolVersion = toString31(peer.metadata.get("ProtocolVersion") ?? fromString31(this.host.protocolVersion));
    const self2 = this;
    async function* pushToConnections() {
      for (const connection of self2.connectionManager.getConnections()) {
        const peer2 = await self2.peerStore.get(connection.remotePeer);
        if (!peer2.protocols.includes(self2.protocol)) {
          continue;
        }
        yield async () => {
          let stream;
          const signal = AbortSignal.timeout(self2.timeout);
          setMaxListeners2(Infinity, signal);
          try {
            stream = await connection.newStream(self2.protocol, {
              signal,
              runOnTransientConnection: self2.runOnTransientConnection
            });
            const pb = pbStream(stream, {
              maxDataLength: self2.maxMessageSize
            }).pb(Identify);
            await pb.write({
              listenAddrs: listenAddresses.map((ma) => ma.bytes),
              signedPeerRecord: signedPeerRecord.marshal(),
              protocols: supportedProtocols,
              agentVersion,
              protocolVersion
            }, {
              signal
            });
            await stream.close({
              signal
            });
          } catch (err) {
            self2.log.error("could not push identify update to peer", err);
            stream?.abort(err);
          }
        };
      }
    }
    await src_default29(parallel(pushToConnections(), {
      concurrency: this.concurrency
    }));
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log("handled push from %p", connection.remotePeer);
  }
};

// node_modules/@libp2p/identify/dist/src/identify.js
var Identify2 = class extends AbstractIdentify {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    if (init.runOnConnectionOpen ?? defaultValues3.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify"
  ];
  async _identify(connection, options2 = {}) {
    let stream;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners2(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      return message2;
    } catch (err) {
      this.log.error("error while reading identify message", err);
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options2 = {}) {
    const message2 = await this._identify(connection, options2);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new CodeError("public key was missing from identify message", "ERR_MISSING_PUBLIC_KEY");
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw new CodeError("identified peer does not match the expected peer", "ERR_INVALID_PEER");
    }
    if (this.peerId.equals(id)) {
      throw new CodeError("identified peer is our own peer id?", "ERR_INVALID_PEER");
    }
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols);
    this.log("our observed address is %a", cleanObservedAddr);
    if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
      this.log("storing our observed address %a", cleanObservedAddr);
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners2(Infinity, signal);
    try {
      const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}

// node_modules/@libp2p/kad-dht/node_modules/it-drain/dist/src/index.js
function isAsyncIterable22(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain5(source) {
  if (isAsyncIterable22(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default30 = drain5;

// node_modules/@libp2p/kad-dht/node_modules/p-defer/index.js
function pDefer9() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@libp2p/kad-dht/dist/src/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var hour = 60 * minute2;
var MAX_RECORD_AGE = 36 * hour;
var PROTOCOL = "/ipfs/kad/1.0.0";
var RECORD_KEY_PREFIX = "/dht/record";
var PROVIDER_KEY_PREFIX = "/dht/provider";
var PROVIDERS_LRU_CACHE_SIZE = 256;
var PROVIDERS_VALIDITY = 24 * hour;
var PROVIDERS_CLEANUP_INTERVAL = hour;
var READ_MESSAGE_TIMEOUT = 10 * second2;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = 5 * minute2;
var QUERY_SELF_INITIAL_INTERVAL = second2;
var QUERY_SELF_TIMEOUT = 5 * second2;
var TABLE_REFRESH_INTERVAL = 5 * minute2;
var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second2;
var DEFAULT_QUERY_TIMEOUT = 180 * second2;

// node_modules/@libp2p/record/node_modules/uint8arrays/dist/src/alloc.js
function alloc10(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.key != null && obj.key.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.key);
        }
        if (obj.value != null && obj.value.byteLength > 0) {
          w2.uint32(18);
          w2.bytes(obj.value);
        }
        if (obj.timeReceived != null && obj.timeReceived !== "") {
          w2.uint32(42);
          w2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30, opts = {}) => {
        const obj = {
          key: alloc10(0),
          value: alloc10(0),
          timeReceived: ""
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf3, opts) => {
    return decodeMessage(buf3, Record3.codec(), opts);
  };
})(Record || (Record = {}));

// node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute3 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute3}:${seconds}.${nanoseconds}Z`;
}
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m2 = String(time).trim().match(rfc3339Matcher);
  if (m2 == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m2[1], 10);
  const month = parseInt(m2[2], 10) - 1;
  const date = parseInt(m2[3], 10);
  const hour2 = parseInt(m2[4], 10);
  const minute3 = parseInt(m2[5], 10);
  const second3 = parseInt(m2[6], 10);
  const millisecond = parseInt(m2[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute3, second3, millisecond));
}

// node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class _Libp2pRecord {
  key;
  value;
  timeReceived;
  constructor(key, value, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const recvtime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new _Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};

// node_modules/@libp2p/kad-dht/node_modules/it-peekable/dist/src/index.js
function peekable7(iterable) {
  const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol3]() {
      return this;
    }
  };
}
var src_default31 = peekable7;

// node_modules/@libp2p/kad-dht/node_modules/it-map/dist/src/index.js
function isAsyncIterable23(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map4(source, func2) {
  let index = 0;
  if (isAsyncIterable23(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val, index++);
      }
    }();
  }
  const peekable8 = src_default31(source);
  const { value, done } = peekable8.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = func2(value, index++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable8) {
        yield func2(val, index++);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable8) {
      yield fn(val, index++);
    }
  }();
}
var src_default32 = map4;

// node_modules/@libp2p/kad-dht/node_modules/it-pipe/dist/src/index.js
function pipe5(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex4(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable4(first4) || isAsyncIterable24(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex4(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex4(fns[i])) {
        fns[i] = duplexPipelineFn4(fns[i]);
      }
    }
  }
  return rawPipe4(...fns);
}
var rawPipe4 = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable24 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable4 = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex4 = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn4 = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable24(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable4(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/equals.js
function equals47(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/alloc.js
function alloc11(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe19(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.key != null) {
          w2.uint32(10);
          w2.bytes(obj.key);
        }
        if (obj.value != null) {
          w2.uint32(18);
          w2.bytes(obj.value);
        }
        if (obj.author != null) {
          w2.uint32(26);
          w2.bytes(obj.author);
        }
        if (obj.signature != null) {
          w2.uint32(34);
          w2.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          w2.uint32(42);
          w2.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 3: {
              obj.author = reader.bytes();
              break;
            }
            case 4: {
              obj.signature = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf3) => {
    return decodeMessage(buf3, Record3.codec());
  };
})(Record2 || (Record2 = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["PUT_VALUE"] = "PUT_VALUE";
  MessageType2["GET_VALUE"] = "GET_VALUE";
  MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
  MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
  MessageType2["FIND_NODE"] = "FIND_NODE";
  MessageType2["PING"] = "PING";
})(MessageType || (MessageType = {}));
var __MessageTypeValues;
(function(__MessageTypeValues2) {
  __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
  __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
})(__MessageTypeValues || (__MessageTypeValues = {}));
(function(MessageType2) {
  MessageType2.codec = () => {
    return enumeration(__MessageTypeValues);
  };
})(MessageType || (MessageType = {}));
var ConnectionType;
(function(ConnectionType2) {
  ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
  ConnectionType2["CONNECTED"] = "CONNECTED";
  ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
  ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
})(ConnectionType || (ConnectionType = {}));
var __ConnectionTypeValues;
(function(__ConnectionTypeValues2) {
  __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
(function(ConnectionType2) {
  ConnectionType2.codec = () => {
    return enumeration(__ConnectionTypeValues);
  };
})(ConnectionType || (ConnectionType = {}));
var PeerInfo;
(function(PeerInfo2) {
  let _codec;
  PeerInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.id);
        }
        if (obj.multiaddrs != null) {
          for (const value of obj.multiaddrs) {
            w2.uint32(18);
            w2.bytes(value);
          }
        }
        if (obj.connection != null) {
          w2.uint32(24);
          ConnectionType.codec().encode(obj.connection, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          id: alloc11(0),
          multiaddrs: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              obj.multiaddrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.connection = ConnectionType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo2.encode = (obj) => {
    return encodeMessage(obj, PeerInfo2.codec());
  };
  PeerInfo2.decode = (buf3) => {
    return decodeMessage(buf3, PeerInfo2.codec());
  };
})(PeerInfo || (PeerInfo = {}));
var Message2;
(function(Message5) {
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
          w2.uint32(8);
          MessageType.codec().encode(obj.type, w2);
        }
        if (obj.clusterLevel != null) {
          w2.uint32(80);
          w2.int32(obj.clusterLevel);
        }
        if (obj.key != null) {
          w2.uint32(18);
          w2.bytes(obj.key);
        }
        if (obj.record != null) {
          w2.uint32(26);
          w2.bytes(obj.record);
        }
        if (obj.closer != null) {
          for (const value of obj.closer) {
            w2.uint32(66);
            PeerInfo.codec().encode(value, w2);
          }
        }
        if (obj.providers != null) {
          for (const value of obj.providers) {
            w2.uint32(74);
            PeerInfo.codec().encode(value, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          type: MessageType.PUT_VALUE,
          closer: [],
          providers: []
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = MessageType.codec().decode(reader);
              break;
            }
            case 10: {
              obj.clusterLevel = reader.int32();
              break;
            }
            case 2: {
              obj.key = reader.bytes();
              break;
            }
            case 3: {
              obj.record = reader.bytes();
              break;
            }
            case 8: {
              obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32()));
              break;
            }
            case 9: {
              obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32()));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf3) => {
    return decodeMessage(buf3, Message5.codec());
  };
})(Message2 || (Message2 = {}));

// node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendQueryEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "SEND_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: fields.type
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:send-query", { detail: event }));
  return event;
}
function peerResponseEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer ?? [],
    providers: fields.providers ?? []
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:peer-response", { detail: event }));
  return event;
}
function finalPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:final-peer", { detail: event }));
  return event;
}
function queryErrorEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:query-error", { detail: event }));
  return event;
}
function providerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:provider", { detail: event }));
  return event;
}
function valueEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "VALUE",
    type: 5
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:value", { detail: event }));
  return event;
}
function dialPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "DIAL_PEER",
    type: 7
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
  return event;
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports16 = {};
__export(base10_exports16, {
  base10: () => base1016
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bytes.js
var empty21 = new Uint8Array(0);
function equals48(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce21(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString32(str) {
  return new TextEncoder().encode(str);
}
function toString32(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/vendor/base-x.js
function base34(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src20 = base34;
var _brrp__multiformats_scope_baseX20 = src20;
var base_x_default21 = _brrp__multiformats_scope_baseX20;

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base.js
var Encoder21 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder22 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or23(this, decoder);
  }
};
var ComposedDecoder21 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or23(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or23(left, right) {
  return new ComposedDecoder21({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec21 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder21(name29, prefix, baseEncode);
    this.decoder = new Decoder22(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from37({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec21(name29, prefix, encode116, decode144);
}
function baseX20({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default21(alphabet27, name29);
  return from37({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce21(decode144(text))
  });
}
function decode93(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode73(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464821({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from37({
    prefix,
    name: name29,
    encode(input) {
      return encode73(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode93(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base10.js
var base1016 = baseX20({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports16 = {};
__export(base16_exports16, {
  base16: () => base1616,
  base16upper: () => base16upper16
});
var base1616 = rfc464821({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper16 = rfc464821({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports16 = {};
__export(base2_exports16, {
  base2: () => base216
});
var base216 = rfc464821({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports16 = {};
__export(base256emoji_exports16, {
  base256emoji: () => base256emoji16
});
var alphabet16 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars16 = alphabet16.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes16 = alphabet16.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode74(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars16[c];
    return p;
  }, "");
}
function decode94(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes16[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji16 = from37({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode74,
  decode: decode94
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports17 = {};
__export(base32_exports17, {
  base32: () => base3219,
  base32hex: () => base32hex19,
  base32hexpad: () => base32hexpad19,
  base32hexpadupper: () => base32hexpadupper19,
  base32hexupper: () => base32hexupper19,
  base32pad: () => base32pad19,
  base32padupper: () => base32padupper19,
  base32upper: () => base32upper19,
  base32z: () => base32z19
});
var base3219 = rfc464821({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper19 = rfc464821({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad19 = rfc464821({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper19 = rfc464821({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex19 = rfc464821({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper19 = rfc464821({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad19 = rfc464821({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper19 = rfc464821({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z19 = rfc464821({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports16 = {};
__export(base36_exports16, {
  base36: () => base3616,
  base36upper: () => base36upper16
});
var base3616 = baseX20({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper16 = baseX20({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports17 = {};
__export(base58_exports17, {
  base58btc: () => base58btc20,
  base58flickr: () => base58flickr20
});
var base58btc20 = baseX20({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr20 = baseX20({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports16 = {};
__export(base64_exports16, {
  base64: () => base6419,
  base64pad: () => base64pad19,
  base64url: () => base64url19,
  base64urlpad: () => base64urlpad19
});
var base6419 = rfc464821({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad19 = rfc464821({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url19 = rfc464821({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad19 = rfc464821({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports16 = {};
__export(base8_exports16, {
  base8: () => base816
});
var base816 = rfc464821({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports31 = {};
__export(identity_exports31, {
  identity: () => identity31
});
var identity31 = from37({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString32(buf3),
  decode: (str) => fromString32(str)
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder20 = new TextEncoder();
var textDecoder19 = new TextDecoder();

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports32 = {};
__export(identity_exports32, {
  identity: () => identity32
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/vendor/varint.js
var encode_118 = encode75;
var MSB19 = 128;
var REST19 = 127;
var MSBALL18 = ~REST19;
var INT18 = Math.pow(2, 31);
function encode75(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT18) {
    out[offset++] = num & 255 | MSB19;
    num /= 128;
  }
  while (num & MSBALL18) {
    out[offset++] = num & 255 | MSB19;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode75.bytes = offset - oldOffset + 1;
  return out;
}
var decode95 = read19;
var MSB$118 = 128;
var REST$118 = 127;
function read19(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read19.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$118) << shift : (b & REST$118) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$118);
  read19.bytes = counter - offset;
  return res;
}
var N119 = Math.pow(2, 7);
var N219 = Math.pow(2, 14);
var N319 = Math.pow(2, 21);
var N419 = Math.pow(2, 28);
var N519 = Math.pow(2, 35);
var N619 = Math.pow(2, 42);
var N719 = Math.pow(2, 49);
var N818 = Math.pow(2, 56);
var N918 = Math.pow(2, 63);
var length19 = function(value) {
  return value < N119 ? 1 : value < N219 ? 2 : value < N319 ? 3 : value < N419 ? 4 : value < N519 ? 5 : value < N619 ? 6 : value < N719 ? 7 : value < N818 ? 8 : value < N918 ? 9 : 10;
};
var varint18 = {
  encode: encode_118,
  decode: decode95,
  encodingLength: length19
};
var _brrp_varint18 = varint18;
var varint_default18 = _brrp_varint18;

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/varint.js
function decode96(data, offset = 0) {
  const code33 = varint_default18.decode(data, offset);
  return [code33, varint_default18.decode.bytes];
}
function encodeTo18(int, target, offset = 0) {
  varint_default18.encode(int, target, offset);
  return target;
}
function encodingLength19(int) {
  return varint_default18.encodingLength(int);
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/digest.js
function create20(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength19(code33);
  const digestOffset = sizeOffset + encodingLength19(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo18(code33, bytes3, 0);
  encodeTo18(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest18(code33, size, digest27, bytes3);
}
function decode97(multihash) {
  const bytes3 = coerce21(multihash);
  const [code33, sizeOffset] = decode96(bytes3);
  const [size, digestOffset] = decode96(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest18(code33, size, digest27, bytes3);
}
function equals49(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals48(a.bytes, data.bytes);
  }
}
var Digest18 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/identity.js
var code22 = 0;
var name16 = "identity";
var encode76 = coerce21;
function digest16(input) {
  return create20(code22, encode76(input));
}
var identity32 = { code: code22, name: name16, encode: encode76, digest: digest16 };

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports16 = {};
__export(sha2_browser_exports16, {
  sha256: () => sha25618,
  sha512: () => sha51218
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/hasher.js
function from38({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher17(name29, code33, encode116);
}
var Hasher17 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create20(this.code, result) : result.then((digest27) => create20(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha17(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25618 = from38({
  name: "sha2-256",
  code: 18,
  encode: sha17("SHA-256")
});
var sha51218 = from38({
  name: "sha2-512",
  code: 19,
  encode: sha17("SHA-512")
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/cid.js
function format18(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV018(bytes3, baseCache18(link), base45 ?? base58btc20.encoder);
    default:
      return toStringV118(bytes3, baseCache18(link), base45 ?? base3219.encoder);
  }
}
var cache19 = /* @__PURE__ */ new WeakMap();
function baseCache18(cid) {
  const baseCache28 = cache19.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache19.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID18 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE18) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE18) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create20(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals49(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format18(this, base45);
  }
  toJSON() {
    return { "/": format18(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID18(version3, code33, multihash.bytes));
    } else if (value[cidSymbol18] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode97(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE18) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE18}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID18(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE18, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce21(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest18(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode96(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE18;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes18(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache18(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes18(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc20;
      return [
        base58btc20.prefix,
        decoder.decode(`${base58btc20.prefix}${source}`)
      ];
    }
    case base58btc20.prefix: {
      const decoder = base45 ?? base58btc20;
      return [base58btc20.prefix, decoder.decode(source)];
    }
    case base3219.prefix: {
      const decoder = base45 ?? base3219;
      return [base3219.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV018(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc20.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV118(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE18 = 112;
var SHA_256_CODE18 = 18;
function encodeCID18(version3, code33, multihash) {
  const codeOffset = encodingLength19(version3);
  const hashOffset = codeOffset + encodingLength19(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo18(version3, bytes3, 0);
  encodeTo18(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol18 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/basics.js
var bases16 = { ...identity_exports31, ...base2_exports16, ...base8_exports16, ...base10_exports16, ...base16_exports16, ...base32_exports17, ...base36_exports16, ...base58_exports17, ...base64_exports16, ...base256emoji_exports16 };
var hashes16 = { ...sha2_browser_exports16, ...identity_exports32 };

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec17(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string17 = createCodec17("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii16 = createCodec17("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe19(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES16 = {
  utf8: string17,
  "utf-8": string17,
  hex: bases16.base16,
  latin1: ascii16,
  ascii: ascii16,
  binary: ascii16,
  ...bases16
};
var bases_default16 = BASES16;

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/to-string.js
function toString33(array, encoding = "utf8") {
  const base45 = bases_default16[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw new CodeError(errMsg, "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString33(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw new CodeError(errMsg, "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    const errMsg = `No selector function configured for key type "${parts[1]}"`;
    throw new CodeError(errMsg, "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
var selectors = {
  pk: publickKey
};

// node_modules/@libp2p/kad-dht/dist/src/record/validators.js
async function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString33(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    const errMsg = `No validator available for key type "${parts[1]}"`;
    throw new CodeError(errMsg, "ERR_INVALID_RECORD_KEY_TYPE");
  }
  await validator(key, record.value);
}
var validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw new CodeError('"key" must be a Uint8Array', "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw new CodeError("invalid public key record", "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString33(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw new CodeError("key was not prefixed with /pk/", "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha25618.digest(publicKey);
  if (!equals47(keyhash, publicKeyHash.bytes)) {
    throw new CodeError("public key does not match passed in key", "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/from-string.js
function fromString33(string27, encoding = "utf8") {
  const base45 = bases_default16[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/kad-dht/node_modules/interface-datastore/dist/src/key.js
var pathSepS4 = "/";
var pathSepB4 = new TextEncoder().encode(pathSepS4);
var pathSep4 = pathSepB4[0];
var Key4 = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString33(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep4) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString33(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS4));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB4;
    }
    if (this._buf[0] !== pathSep4) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep4, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep4) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS4).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType3(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue3(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS4)) {
      p += pathSepS4;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS4);
    }
    return new _Key(list.slice(0, -1).join(pathSepS4));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS4) {
      return key;
    } else if (key.toString() === pathSepS4) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten3(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType3(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue3(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten3(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array6(buf3) {
  return buf3;
}

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/concat.js
function concat9(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe19(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array6(output3);
}

// node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString33("/pk/");
function removePrivateAddressesMapper(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type === 53 || type === 54 || type === 55) {
        if (addr === "localhost") {
          return false;
        }
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = isPrivateIp(addr);
      if (isPrivate2 == null) {
        return true;
      }
      return !isPrivate2;
    })
  };
}
async function convertBuffer(buf3) {
  const multihash = await sha25618.digest(buf3);
  return multihash.digest;
}
async function convertPeerId(peerId2) {
  return convertBuffer(peerId2.toBytes());
}
function bufferToRecordKey(buf3) {
  return new Key4(`${RECORD_KEY_PREFIX}/${toString33(buf3, "base32")}`, false);
}
function keyForPublicKey(peer) {
  return concat9([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
function isPublicKeyKey(key) {
  return toString33(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
function createPutRecord(key, value) {
  const timeReceived = /* @__PURE__ */ new Date();
  const rec = new Libp2pRecord(key, value, timeReceived);
  return rec.serialize();
}
function debounce(callback, wait = 100) {
  let timeout;
  return () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      callback();
    }, wait);
  };
}
var P2P_CIRCUIT_CODE = 290;
var DNS4_CODE = 54;
var DNS6_CODE = 55;
var DNSADDR_CODE = 56;
var IP4_CODE = 4;
var IP6_CODE = 41;
function multiaddrIsPublic(multiaddr2) {
  const tuples = multiaddr2.stringTuples();
  for (const tuple of tuples) {
    if (tuple[0] === P2P_CIRCUIT_CODE) {
      return false;
    }
  }
  if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {
    return true;
  }
  if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {
    const result = isPrivateIp(`${tuples[0][1]}`);
    const isPublic = result == null || !result;
    return isPublic;
  }
  return false;
}

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var ContentFetching = class {
  log;
  components;
  validators;
  selectors;
  peerRouting;
  queryManager;
  network;
  constructor(components, init) {
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.network = network;
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options2 = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = createPutRecord(key, best);
    for (const { value, from: from58 } of vals) {
      if (equals47(value, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from58)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray());
        } catch (err) {
          this.log.error("Failed error correcting self", err);
        }
        continue;
      }
      let sentCorrection = false;
      const request = {
        type: MessageType.PUT_VALUE,
        key,
        record: fixupRec
      };
      for await (const event of this.network.sendRequest(from58, request, options2)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals47(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from58, error: new CodeError("value not put correctly", "ERR_PUT_VALUE_INVALID") }, options2);
      }
      this.log.error("Failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options2 = {}) {
    this.log("put key %b value %b", key, value);
    const record = createPutRecord(key, value);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray());
    yield* pipe5(this.peerRouting.getClosestPeers(key, { signal: options2.signal }), (source) => src_default32(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = {
          type: MessageType.PUT_VALUE,
          key,
          record
        };
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options2)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals47(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: new CodeError("value not put correctly", "ERR_PUT_VALUE_INVALID") }, options2));
          }
        }
        return events2;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options2 = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options2)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i = 0;
    try {
      i = bestRecord(this.selectors, key, records);
    } catch (err) {
      if (err.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err;
      }
    }
    const best = records[i];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw new CodeError("best value was not found", "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options2);
    yield vals[i];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options2 = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId
      }, options2);
    } catch (err) {
      this.log("error getting local value for %b", key, err);
    }
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value }, options2);
        }
      }
    };
    yield* this.queryManager.run(key, getValueQuery, options2);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/message/utils.js
function toPbPeerInfo(peer, connection) {
  const output3 = {
    id: peer.id.toBytes(),
    multiaddrs: (peer.multiaddrs ?? []).map((m2) => m2.bytes),
    connection
  };
  return output3;
}
function fromPbPeerInfo(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.multiaddrs ?? []).map((a) => multiaddr(a))
  };
}

// node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var ContentRouting = class {
  log;
  components;
  network;
  peerRouting;
  queryManager;
  routingTable;
  providers;
  constructor(components, init) {
    const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options2 = {}) {
    this.log("provide %s", key);
    const target = key.multihash.bytes;
    await this.providers.addProvider(key, this.components.peerId);
    const msg = {
      type: MessageType.ADD_PROVIDER,
      key: target,
      providers: [
        toPbPeerInfo({
          id: this.components.peerId,
          multiaddrs
        })
      ]
    };
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options2)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err }, options2));
        }
        return events2;
      };
    };
    yield* pipe5(this.peerRouting.getClosestPeers(target, options2), (source) => src_default32(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options2) {
    const toFind = this.routingTable.kBucketSize;
    let found = 0;
    const target = key.multihash.bytes;
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId2 of provs.slice(0, toFind)) {
        try {
          const peer = await this.components.peerStore.get(peerId2);
          providers2.push({
            id: peerId2,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
          this.log("no peer store entry for %p", peerId2);
        }
      }
      yield peerResponseEvent({ from: this.components.peerId, messageType: MessageType.GET_PROVIDERS, providers: providers2 }, options2);
      yield providerEvent({ from: this.components.peerId, providers: providers2 }, options2);
      found += providers2.length;
      if (found >= toFind) {
        return;
      }
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request = {
        type: MessageType.GET_PROVIDERS,
        key: target
      };
      yield* self2.network.sendRequest(peer, request, {
        ...options2,
        signal
      });
    };
    const providers = new PeerSet(provs);
    for await (const event of this.queryManager.run(target, findProvidersQuery, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id)) {
            continue;
          }
          providers.add(peer.id);
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders }, options2);
          found += newProviders.length;
          if (found >= toFind) {
            return;
          }
        }
      }
    }
  }
};

// node_modules/@libp2p/utils/node_modules/any-signal/dist/src/index.js
function anySignal5(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  movingAverage;
  variance;
  deviation;
  forecast;
  timespan;
  previousTime;
  constructor(timespan) {
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(value, time = Date.now()) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};

// node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 2e3;
var AdaptiveTimeout = class {
  success;
  failure;
  next;
  metric;
  timeoutMultiplier;
  failureMultiplier;
  minTimeout;
  constructor(init = {}) {
    this.success = new MovingAverage(init.interval ?? 5e3);
    this.failure = new MovingAverage(init.interval ?? 5e3);
    this.next = new MovingAverage(init.interval ?? 5e3);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    if (init.metricName != null) {
      this.metric = init.metrics?.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options2 = {}) {
    const timeout = Math.max(Math.round(this.next.movingAverage * (options2.timeoutFactor ?? this.timeoutMultiplier)), this.minTimeout);
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal5([options2.signal, sendTimeout]);
    setMaxListeners2(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      this.metric?.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      this.metric?.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/network.js
var Network2 = class extends TypedEventEmitter {
  log;
  protocol;
  running;
  components;
  timeout;
  /**
   * Create a new network
   */
  constructor(components, init) {
    super();
    const { protocol } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:network`);
    this.running = false;
    this.protocol = protocol;
    this.timeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.logPrefix.replaceAll(":", "_")}_network_message_send_times_milliseconds`
    });
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and record RTT for latency measurements
   */
  async *sendRequest(to, msg, options2 = {}) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new CodeError2("Message type was missing", "ERR_INVALID_PARAMETERS");
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options2);
    yield sendQueryEvent({ to, type }, options2);
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      const response = await this._writeReadMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closer.map(fromPbPeerInfo),
        providers: response.providers.map(fromPbPeerInfo),
        record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record)
      }, options2);
    } catch (err) {
      stream?.abort(err);
      this.log.error("could not send %s to %p", msg.type, to, err);
      yield queryErrorEvent({ from: to, error: err }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options2 = {}) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new CodeError2("Message type was missing", "ERR_INVALID_PARAMETERS");
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options2);
    yield sendQueryEvent({ to, type }, options2);
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      await this._writeMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({ from: to, messageType: type }, options2);
    } catch (err) {
      stream?.abort(err);
      yield queryErrorEvent({ from: to, error: err }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
    await pb.unwrap().close(options2);
  }
  /**
   * Write a message and read its response.
   * If no response is received after the specified timeout
   * this will error out.
   */
  async _writeReadMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
    const message2 = await pb.read(Message2, options2);
    await pb.unwrap().close(options2);
    message2.closer.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    message2.providers.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    return message2;
  }
};

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/xor.js
function xor2(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe19(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return asUint8Array6(result);
}

// node_modules/@libp2p/kad-dht/node_modules/uint8arrays/dist/src/xor-compare.js
function xorCompare(a, b) {
  if (a.byteLength !== b.byteLength) {
    throw new Error("Inputs should have the same length");
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return 0;
}

// node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
var PeerDistanceList = class {
  /**
   * The DHT key from which distance is calculated
   */
  originDhtKey;
  /**
   * The maximum size of the list
   */
  capacity;
  peerDistances;
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peers in the list, in order of distance from the origin key
   */
  get peers() {
    return this.peerDistances.map((pd) => pd.peer);
  }
  /**
   * Add a peerId to the list.
   */
  async add(peer) {
    const dhtKey = await convertPeerId(peer.id);
    this.addWitKadId(peer, dhtKey);
  }
  /**
   * Add a peerId to the list.
   */
  addWitKadId(peer, kadId) {
    if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
      return;
    }
    const el = {
      peer,
      distance: xor2(this.originDhtKey, kadId)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => xorCompare(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async isCloser(peerId2) {
    if (this.length === 0) {
      return true;
    }
    const dhtKey = await convertPeerId(peerId2);
    const dhtKeyXor = xor2(dhtKey, this.originDhtKey);
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    return xorCompare(dhtKeyXor, furthestDistance) === -1;
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    return Promise.any(peerIds.map(async (peerId2) => this.isCloser(peerId2)));
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  log;
  routingTable;
  network;
  validators;
  queryManager;
  peerStore;
  peerId;
  constructor(components, init) {
    const { routingTable, network, validators: validators2, queryManager, logPrefix } = init;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators2;
    this.queryManager = queryManager;
    this.peerStore = components.peerStore;
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${logPrefix}:peer-routing`);
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.peerStore.get(p);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.peerStore.get(peer);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr)
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options2 = {}) {
    const msg = {
      type: MessageType.GET_VALUE,
      key
    };
    yield* this.network.sendRequest(peer, msg, options2);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options2 = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(keys_exports2.marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw new CodeError("public key does not match id", "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw new CodeError("public key missing", "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey }, options2);
      }
    }
    throw new CodeError(`Node not responding with its public key: ${peer.toString()}`, "ERR_INVALID_RECORD");
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    this.log("findPeer %p", id);
    if (options2.useCache !== false) {
      const pi = await this.findPeerLocal(id);
      if (pi != null) {
        this.log("found local");
        yield finalPeerEvent({
          from: this.peerId,
          peer: pi
        }, options2);
        return;
      }
    }
    let foundPeer = false;
    if (options2.useNetwork !== false) {
      const self2 = this;
      const findPeerQuery = async function* ({ peer, signal }) {
        const request = {
          type: MessageType.FIND_NODE,
          key: id.toBytes()
        };
        for await (const event of self2.network.sendRequest(peer, request, {
          ...options2,
          signal
        })) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            const match = event.closer.find((p) => p.id.equals(id));
            if (match != null) {
              yield finalPeerEvent({ from: event.from, peer: match }, options2);
            }
          }
        }
      };
      for await (const event of this.queryManager.run(id.toBytes(), findPeerQuery, options2)) {
        if (event.name === "FINAL_PEER") {
          foundPeer = true;
        }
        yield event;
      }
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.peerId, error: new CodeError("Not found", "ERR_NOT_FOUND") }, options2);
    }
  }
  /**
   * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from
   * a multihash or a peer ID
   */
  async *getClosestPeers(key, options2 = {}) {
    this.log("getClosestPeers to %b", key);
    const kadId = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(kadId);
    const self2 = this;
    const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => {
      await peers.add({ id: peer, multiaddrs: [] });
    }));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString33(key, "base32"), peer);
      const request = {
        type: MessageType.FIND_NODE,
        key
      };
      yield* self2.network.sendRequest(peer, request, {
        ...options2,
        signal
      });
    };
    for await (const event of this.queryManager.run(key, getCloserPeersQuery, options2)) {
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => {
          await peers.add(peerData);
        }));
      }
      yield event;
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.peerId,
        peer
      }, options2);
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options2 = {}) {
    for await (const event of this._getValueSingle(peer, key, options2)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: new CodeError(errMsg, "ERR_INVALID_RECORD") }, options2);
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw new CodeError("invalid record received", "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  /**
   * Get the nearest peers to the given query, but if closer
   * than self
   */
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output3 = [];
    for (const peerId2 of ids) {
      if (peerId2.equals(closerThan)) {
        continue;
      }
      try {
        const peer = await this.peerStore.get(peerId2);
        output3.push({
          id: peerId2,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        });
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    if (output3.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output3.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table", key, closerThan, this.routingTable.size);
    }
    return output3;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var import_hashlru2 = __toESM(require_hashlru(), 1);
var Providers = class {
  log;
  datastore;
  cache;
  cleanupInterval;
  provideValidity;
  syncQueue;
  started;
  cleaner;
  constructor(components, init = {}) {
    const { cacheSize, cleanupInterval, provideValidity } = init;
    this.log = components.logger.forComponent("libp2p:kad-dht:providers");
    this.datastore = components.datastore;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = (0, import_hashlru2.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new PQueue({ concurrency: 1 });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start the provider cleanup service
   */
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err) => {
        this.log.error(err);
      });
    }, this.cleanupInterval);
  }
  /**
   * Release any resources.
   */
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  /**
   * Check all providers if they are still valid, and if not delete them
   */
  async _cleanup() {
    await this.syncQueue.add(async () => {
      const start2 = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch = this.datastore.batch();
      const query = this.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId: peerId2 } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          this.log("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId2);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err) {
          this.log.error(err.message);
        }
      }
      if (deleted.size > 0) {
        this.log("deleting %d / %d entries", deleteCount, count);
        await batch.commit();
      } else {
        this.log("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId2 of peers) {
            provs.delete(peerId2);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      this.log("Cleanup successful (%dms)", Date.now() - start2);
    });
  }
  /**
   * Get the currently known provider peer ids for a given CID
   */
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.datastore, cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider) {
    await this.syncQueue.add(async () => {
      this.log("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      this.log("loaded %s provs", provs.size);
      const now = /* @__PURE__ */ new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.datastore, cid, provider, now);
    });
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid) {
    return this.syncQueue.add(async () => {
      this.log("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    }, {
      // no timeout is specified for this queue so it will not
      // throw, but this is required to get the right return
      // type since p-queue@7.3.4
      throwOnTimeout: true
    });
  }
};
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString33(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key4(dsKey);
  const buffer3 = encode(time.getTime());
  await store.put(key, buffer3);
}
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  if (parts.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts[3],
    peerId: parts[4]
  };
}
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId: peerId2 } = parseProviderKey(entry.key);
    providers.set(peerId2, readTime(entry.value));
  }
  return providers;
}
function readTime(buf3) {
  return new Date(decode(buf3));
}

// node_modules/@libp2p/kad-dht/node_modules/any-signal/dist/src/index.js
function anySignal6(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
async function* queryPath(options2) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, queryFuncTimeout, log: log10, peersSeen, connectionManager } = options2;
  const queue = new Queue({
    concurrency: alpha,
    sort: (a, b) => xorCompare(a.options.distance, b.options.distance)
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = xor2(peerKadId, kadId);
    queue.add(async () => {
      const signals = [signal];
      if (queryFuncTimeout != null) {
        signals.push(AbortSignal.timeout(queryFuncTimeout));
      }
      const compoundSignal = anySignal6(signals);
      setMaxListeners2(Infinity, compoundSignal);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log10("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log10("not querying ourselves");
                continue;
              }
              if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                log10("not querying undialable peer");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = xor2(closerPeerKadId, kadId);
              if (xorCompare(closerPeerXor, peerXor) !== -1) {
                log10("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log10("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.safeDispatchEvent("completed", {
            detail: event
          });
        }
      } catch (err) {
        if (!signal.aborted) {
          return queryErrorEvent({
            from: peer,
            error: err
          }, options2);
        }
      } finally {
        compoundSignal.clear();
      }
    }, {
      distance: peerXor
    }).catch((err) => {
      log10.error(err);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  try {
    for await (const event of queue.toGenerator({ signal })) {
      if (event != null) {
        yield event;
      }
    }
  } catch (err) {
    if (signal.aborted) {
      throw new CodeError("Query aborted", "ERR_QUERY_ABORTED");
    }
    throw err;
  }
}

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var QueryManager = class {
  disjointPaths;
  alpha;
  shutDownController;
  running;
  queries;
  logger;
  peerId;
  connectionManager;
  routingTable;
  initialQuerySelfHasRun;
  logPrefix;
  metrics;
  constructor(components, init) {
    const { disjointPaths = K, alpha = ALPHA, logPrefix } = init;
    this.logPrefix = logPrefix;
    this.disjointPaths = disjointPaths ?? K;
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.queries = 0;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.routingTable = init.routingTable;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    if (components.metrics != null) {
      this.metrics = {
        runningQueries: components.metrics.registerMetric(`${logPrefix.replaceAll(":", "_")}_running_queries`),
        queryTime: components.metrics.registerMetric(`${logPrefix.replaceAll(":", "_")}_query_time_seconds`)
      };
    }
    this.shutDownController = new AbortController();
    setMaxListeners2(Infinity, this.shutDownController.signal);
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    this.running = true;
    this.shutDownController = new AbortController();
    setMaxListeners2(Infinity, this.shutDownController.signal);
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    this.shutDownController.abort();
  }
  async *run(key, queryFunc, options2 = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    const stopQueryTimer = this.metrics?.queryTime.timer();
    if (options2.signal == null) {
      const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
      setMaxListeners2(Infinity, signal2);
      options2 = {
        ...options2,
        signal: signal2
      };
    }
    const queryEarlyExitController = new AbortController();
    const signal = anySignal6([
      this.shutDownController.signal,
      queryEarlyExitController.signal,
      options2.signal
    ]);
    setMaxListeners2(Infinity, signal, queryEarlyExitController.signal);
    const log10 = this.logger.forComponent(`${this.logPrefix}:query:` + toString33(key, "base58btc"));
    const startTime = Date.now();
    let queryFinished = false;
    try {
      if (options2.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
        log10("waiting for initial query-self query before continuing");
        await raceSignal(this.initialQuerySelfHasRun.promise, signal);
        this.initialQuerySelfHasRun = void 0;
      }
      log10("query:start");
      this.queries++;
      this.metrics?.runningQueries.update(this.queries);
      const id = await convertBuffer(key);
      const peers = this.routingTable.closestPeers(id);
      const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
      if (peers.length === 0) {
        log10.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.peerId,
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          queryFuncTimeout: options2.queryFuncTimeout,
          log: log10,
          peersSeen,
          onProgress: options2.onProgress,
          connectionManager: this.connectionManager
        });
      });
      for await (const event of src_default4(...paths)) {
        if (event.name === "QUERY_ERROR") {
          log10.error("query error", event.error);
        }
        if (event.name === "PEER_RESPONSE") {
          for (const peer of [...event.closer, ...event.providers]) {
            if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
              continue;
            }
            await this.routingTable.add(peer.id);
          }
        }
        yield event;
      }
      queryFinished = true;
    } catch (err) {
      if (!this.running && err.code === "ERR_QUERY_ABORTED") {
      } else {
        throw err;
      }
    } finally {
      if (!queryFinished) {
        log10("query exited early");
        queryEarlyExitController.abort();
      }
      signal.clear();
      this.queries--;
      this.metrics?.runningQueries.update(this.queries);
      if (stopQueryTimer != null) {
        stopQueryTimer();
      }
      log10("query:done in %dms", Date.now() - startTime);
    }
  }
};

// node_modules/it-length/dist/src/index.js
function isAsyncIterable25(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function length20(source) {
  if (isAsyncIterable25(source)) {
    return (async () => {
      let count = 0;
      for await (const _ of source) {
        count++;
      }
      return count;
    })();
  } else {
    let count = 0;
    for (const _ of source) {
      count++;
    }
    return count;
  }
}
var src_default33 = length20;

// node_modules/@libp2p/kad-dht/node_modules/it-take/dist/src/index.js
function isAsyncIterable26(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take3(source, limit) {
  if (isAsyncIterable26(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default34 = take3;

// node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options2) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options2 = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options2
    };
    if (!(options2.count >= 0 && (options2.count === Number.POSITIVE_INFINITY || Number.isInteger(options2.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    options2.signal?.throwIfAborted();
    const events2 = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value = options2.multiArgs ? arguments_ : arguments_[0];
      if (options2.filter && !options2.filter(value)) {
        return;
      }
      items.push(value);
      if (options2.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events2) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options2.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events2) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options2.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options2.signal) {
      options2.signal.addEventListener("abort", () => {
        rejectHandler(options2.signal.reason);
      }, { once: true });
    }
    if (options2.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options2.timeout === "number") {
    const timeout = pTimeout(returnValue, { milliseconds: options2.timeout });
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options2) {
  if (typeof options2 === "function") {
    options2 = { filter: options2 };
  }
  options2 = {
    ...options2,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options2);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var QuerySelf = class {
  log;
  peerId;
  peerRouting;
  routingTable;
  count;
  interval;
  initialInterval;
  queryTimeout;
  started;
  timeoutId;
  controller;
  initialQuerySelfHasRun;
  querySelfPromise;
  constructor(components, init) {
    const { peerRouting, logPrefix, count, interval, queryTimeout, routingTable } = init;
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${logPrefix}:query-self`);
    this.started = false;
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
  }
  isStarted() {
    return this.started;
  }
  start() {
    if (this.started) {
      return;
    }
    this.started = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.initialInterval);
  }
  stop() {
    this.started = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  async querySelf() {
    if (!this.started) {
      this.log("skip self-query because we are not started");
      return;
    }
    if (this.querySelfPromise != null) {
      this.log("joining existing self query");
      return this.querySelfPromise.promise;
    }
    this.querySelfPromise = pDefer9();
    if (this.started) {
      this.controller = new AbortController();
      const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
      const signal = anySignal6([this.controller.signal, timeoutSignal]);
      setMaxListeners2(Infinity, signal, this.controller.signal, timeoutSignal);
      try {
        if (this.routingTable.size === 0) {
          this.log("routing table was empty, waiting for some peers before running query");
          await pEvent(this.routingTable, "peer:add", {
            signal
          });
        }
        this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
        const start2 = Date.now();
        const found = await pipe5(this.peerRouting.getClosestPeers(this.peerId.toBytes(), {
          signal,
          isSelfQuery: true
        }), (source) => src_default34(source, this.count), async (source) => src_default33(source));
        this.log("self-query found %d peers in %dms", found, Date.now() - start2);
      } catch (err) {
        this.log.error("self-query error", err);
      } finally {
        signal.clear();
        if (this.initialQuerySelfHasRun != null) {
          this.initialQuerySelfHasRun.resolve();
          this.initialQuerySelfHasRun = void 0;
        }
      }
    }
    this.querySelfPromise.resolve();
    this.querySelfPromise = void 0;
    if (!this.started) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.interval);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
function arrayEquals2(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0, length30 = array1.length; i < length30; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function ensureInt8(name29, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name29 + " is not a Uint8Array");
  }
  if (val.byteLength !== 32) {
    throw new TypeError(name29 + " had incorrect length");
  }
}
function isLeafBucket(obj) {
  return Array.isArray(obj?.peers);
}
var KBucket = class extends TypedEventEmitter {
  root;
  localPeer;
  prefixLength;
  splitThreshold;
  kBucketSize;
  numberOfNodesToPing;
  constructor(options2) {
    super();
    this.localPeer = options2.localPeer;
    this.prefixLength = options2.prefixLength;
    this.kBucketSize = options2.kBucketSize ?? KBUCKET_SIZE;
    this.splitThreshold = options2.splitThreshold ?? this.kBucketSize;
    this.numberOfNodesToPing = options2.numberOfNodesToPing ?? 3;
    ensureInt8("options.localPeer.kadId", options2.localPeer.kadId);
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  /**
   * Adds a contact to the k-bucket.
   *
   * @param {Peer} peer - the contact object to add
   */
  add(peer) {
    ensureInt8("peer.kadId", peer?.kadId);
    const bucket = this._determineBucket(peer.kadId);
    if (this._indexOf(bucket, peer.kadId) > -1) {
      return;
    }
    if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
      this._split(bucket);
      this.add(peer);
      return;
    }
    if (bucket.peers.length < this.kBucketSize) {
      bucket.peers.push(peer);
      this.safeDispatchEvent("added", { detail: peer });
      return;
    }
    this.safeDispatchEvent("ping", {
      detail: {
        oldContacts: bucket.peers.slice(0, this.numberOfNodesToPing),
        newContact: peer
      }
    });
  }
  /**
   * Get 0-n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param {Uint8Array} id - Contact node id
   * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
   */
  *closest(id, n = this.kBucketSize) {
    const list = new PeerDistanceList(id, n);
    for (const peer of this.toIterable()) {
      list.addWitKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
    }
    yield* src_default32(list.peers, (info) => info.id);
  }
  /**
   * Counts the total number of contacts in the tree.
   *
   * @returns {number} The number of contacts held in the tree
   */
  count() {
    function countBucket(bucket) {
      if (isLeafBucket(bucket)) {
        return bucket.peers.length;
      }
      let count = 0;
      if (bucket.left != null) {
        count += countBucket(bucket.left);
      }
      if (bucket.right != null) {
        count += countBucket(bucket.right);
      }
      return count;
    }
    return countBucket(this.root);
  }
  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param {Uint8Array} kadId - The ID of the contact to fetch.
   * @returns {object | undefined} The contact if available, otherwise null
   */
  get(kadId) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    return bucket.peers[index];
  }
  /**
   * Removes contact with the provided id.
   *
   * @param {Uint8Array} kadId - The ID of the contact to remove
   */
  remove(kadId) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    if (index > -1) {
      const peer = bucket.peers.splice(index, 1)[0];
      this.safeDispatchEvent("removed", {
        detail: peer
      });
    }
  }
  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @returns {Iterable} All of the contacts in the tree, as an iterable
   */
  *toIterable() {
    function* iterate(bucket) {
      if (isLeafBucket(bucket)) {
        yield* bucket.peers;
        return;
      }
      yield* iterate(bucket.left);
      yield* iterate(bucket.right);
    }
    yield* iterate(this.root);
  }
  /**
   * Default distance function. Finds the XOR distance between firstId and
   * secondId.
   *
   * @param  {Uint8Array} firstId - Uint8Array containing first id.
   * @param  {Uint8Array} secondId - Uint8Array containing second id.
   * @returns {number} Integer The XOR distance between firstId and secondId.
   */
  distance(firstId, secondId) {
    return BigInt("0x" + toString33(xor2(firstId, secondId), "base16"));
  }
  /**
   * Determines whether the id at the bitIndex is 0 or 1
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param {Uint8Array} kadId - Id to compare localNodeId with
   * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineBucket(kadId) {
    const bitString = toString33(kadId, "base2");
    const prefix = bitString.substring(0, this.prefixLength);
    function findBucket(bucket, bitIndex = 0) {
      if (isLeafBucket(bucket)) {
        return bucket;
      }
      const bit = prefix[bitIndex];
      if (bit === "0") {
        return findBucket(bucket.left, bitIndex + 1);
      }
      return findBucket(bucket.right, bitIndex + 1);
    }
    return findBucket(this.root);
  }
  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param {object} bucket - internal object that has 2 leafs: left and right
   * @param {Uint8Array} kadId - KadId of peer
   * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
   */
  _indexOf(bucket, kadId) {
    return bucket.peers.findIndex((peer) => arrayEquals2(peer.kadId, kadId));
  }
  /**
   * Modify the bucket, turn it from a leaf bucket to an internal bucket
   *
   * @param {any} bucket - bucket for splitting
   */
  _split(bucket) {
    const depth = bucket.depth + 1;
    const left = {
      prefix: "0",
      depth,
      peers: []
    };
    const right = {
      prefix: "1",
      depth,
      peers: []
    };
    for (const peer of bucket.peers) {
      const bitString = toString33(peer.kadId, "base2");
      if (bitString[depth] === "0") {
        left.peers.push(peer);
      } else {
        right.peers.push(peer);
      }
    }
    delete bucket.peers;
    bucket.left = left;
    bucket.right = right;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var KBUCKET_SIZE = 20;
var PREFIX_LENGTH = 32;
var PING_TIMEOUT = 1e4;
var PING_CONCURRENCY = 10;
var RoutingTable = class extends TypedEventEmitter {
  kBucketSize;
  kb;
  pingQueue;
  log;
  components;
  prefixLength;
  splitThreshold;
  pingTimeout;
  pingConcurrency;
  running;
  protocol;
  tagName;
  tagValue;
  metrics;
  constructor(components, init) {
    super();
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = init.pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = init.pingConcurrency ?? PING_CONCURRENCY;
    this.running = false;
    this.protocol = init.protocol;
    this.tagName = init.tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = init.tagValue ?? KAD_CLOSE_TAG_VALUE;
    this.prefixLength = init.prefixLength ?? PREFIX_LENGTH;
    this.splitThreshold = init.splitThreshold ?? KBUCKET_SIZE;
    this.pingQueue = new PeerQueue({
      concurrency: this.pingConcurrency,
      metricName: `${init.logPrefix.replaceAll(":", "_")}_ping_queue`,
      metrics: this.components.metrics
    });
    this.pingQueue.addEventListener("error", (evt) => {
      this.log.error("error pinging peer", evt.detail);
    });
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_size`),
        routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_total`),
        routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_average_occupancy`),
        routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_max_depth`)
      };
    }
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    const kBuck = new KBucket({
      localPeer: {
        kadId: await convertPeerId(this.components.peerId),
        peerId: this.components.peerId
      },
      kBucketSize: this.kBucketSize,
      prefixLength: this.prefixLength,
      splitThreshold: this.splitThreshold,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.addEventListener("ping", (evt) => {
      this._onPing(evt).catch((err) => {
        this.log.error("could not process k-bucket ping event", err);
      });
    });
    let peerStorePeers = 0;
    for (const peer of await this.components.peerStore.all()) {
      if (peer.protocols.includes(this.protocol)) {
        const id = await convertPeerId(peer.id);
        this.kb.add({ kadId: id, peerId: peer.id });
        peerStorePeers++;
      }
    }
    this.log("added %d peer store peers to the routing table", peerStorePeers);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  /**
   * Keep track of our k-closest peers and tag them in the peer store as such
   * - this will lower the chances that connections to them get closed when
   * we reach connection limits
   */
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localPeer.kadId, KBUCKET_SIZE));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.peerStore.merge(peer, {
            tags: {
              [this.tagName]: {
                value: this.tagValue
              }
            }
          });
        }
        for (const peer of removedPeers) {
          await this.components.peerStore.merge(peer, {
            tags: {
              [this.tagName]: void 0
            }
          });
        }
      }).catch((err) => {
        this.log.error("Could not update peer tags", err);
      });
      kClosest = newClosest;
    });
    kBuck.addEventListener("added", (evt) => {
      updatePeerTags();
      this.safeDispatchEvent("peer:add", { detail: evt.detail.peerId });
    });
    kBuck.addEventListener("removed", (evt) => {
      updatePeerTags();
      this.safeDispatchEvent("peer:remove", { detail: evt.detail.peerId });
    });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  async _onPing(evt) {
    if (!this.running) {
      return;
    }
    const { oldContacts, newContact } = evt.detail;
    const results = await Promise.all(oldContacts.map(async (oldContact) => {
      const pingJob = this.pingQueue.find(oldContact.peerId);
      if (pingJob != null) {
        return pingJob.join();
      }
      return this.pingQueue.add(async () => {
        let stream;
        try {
          const options2 = {
            signal: AbortSignal.timeout(this.pingTimeout)
          };
          this.log("pinging old contact %p", oldContact.peerId);
          const connection = await this.components.connectionManager.openConnection(oldContact.peerId, options2);
          stream = await connection.newStream(this.protocol, options2);
          const pb = pbStream(stream);
          await pb.write({
            type: MessageType.PING
          }, Message2, options2);
          const response = await pb.read(Message2, options2);
          await pb.unwrap().close();
          if (response.type !== MessageType.PING) {
            throw new CodeError(`Incorrect message type received, expected PING got ${response.type}`, "ERR_BAD_PING_RESPONSE");
          }
          return true;
        } catch (err) {
          if (this.running && this.kb != null) {
            this.log.error("could not ping peer %p", oldContact.peerId, err);
            this.log("evicting old contact after ping failed %p", oldContact.peerId);
            this.kb.remove(oldContact.kadId);
          }
          stream?.abort(err);
          return false;
        } finally {
          this.metrics?.routingTableSize.update(this.size);
        }
      }, {
        peerId: oldContact.peerId
      });
    }));
    const responded = results.filter((res) => res).length;
    if (this.running && responded < oldContacts.length && this.kb != null) {
      this.log("adding new contact %p", newContact.peerId);
      this.kb.add(newContact);
    }
  }
  // -- Public Interface
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer) {
    const key = await convertPeerId(peer);
    return this.kb?.get(key)?.peerId;
  }
  /**
   * Retrieve the closest peers to the given kadId
   */
  closestPeer(kadId) {
    const res = this.closestPeers(kadId, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given kadId
   */
  closestPeers(kadId, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    return [...this.kb.closest(kadId, count)];
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peerId2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const kadId = await convertPeerId(peerId2);
    this.kb.add({ kadId, peerId: peerId2 });
    this.log("added %p with kad id %b", peerId2, kadId);
    this.updateMetrics();
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.updateMetrics();
  }
  updateMetrics() {
    if (this.metrics == null || this.kb == null) {
      return;
    }
    let size = 0;
    let buckets = 0;
    let maxDepth = 0;
    function count(bucket) {
      if (isLeafBucket(bucket)) {
        if (bucket.depth > maxDepth) {
          maxDepth = bucket.depth;
        }
        buckets++;
        size += bucket.peers.length;
        return;
      }
      count(bucket.left);
      count(bucket.right);
    }
    count(this.kb.root);
    this.metrics.routingTableSize.update(size);
    this.metrics.routingTableKadBucketTotal.update(buckets);
    this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
    this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  log;
  peerRouting;
  routingTable;
  refreshInterval;
  refreshQueryTimeout;
  commonPrefixLengthRefreshedAt;
  refreshTimeoutId;
  constructor(components, init) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async afterStart() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err) {
              this.log.error(err);
            }
          }
        }
      } catch (err) {
        this.log.error(err);
      }
    })).catch((err) => {
      this.log.error(err);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err) => {
      this.log.error(err);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId2 = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId2, this.routingTable.size);
    const signal = AbortSignal.timeout(this.refreshQueryTimeout);
    setMaxListeners2(Infinity, signal);
    const peers = await src_default33(this.peerRouting.getClosestPeers(peerId2.toBytes(), {
      signal
    }));
    this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId2);
    this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId2, this.routingTable.size);
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i = 0; i <= maxCommonPrefix; i++) {
      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? /* @__PURE__ */ new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes2(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha25618.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length30 of this._prefixLengths()) {
      if (length30 > prefixLength) {
        prefixLength = length30;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length30 of this._prefixLengths()) {
      if (length30 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { kadId } of this.routingTable.kb.toIterable()) {
      const distance = xor2(this.routingTable.kb.localPeer.kadId, kadId);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var AddProviderHandler = class {
  providers;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
    this.providers = init.providers;
  }
  async handle(peerId2, msg) {
    this.log("start");
    if (msg.key == null || msg.key.length === 0) {
      throw new CodeError("Missing key", "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID18.decode(msg.key);
    } catch (err) {
      throw new CodeError("Invalid CID", "ERR_INVALID_CID");
    }
    if (msg.providers == null || msg.providers.length === 0) {
      this.log.error("no providers found in message");
    }
    await Promise.all(msg.providers.map(async (pi) => {
      if (!peerId2.equals(pi.id)) {
        this.log("invalid provider peer %p from %p", pi.id, peerId2);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        this.log("no valid addresses for provider %p. Ignore", peerId2);
        return;
      }
      this.log("received provider %p for %s (addrs %s)", peerId2, cid, pi.multiaddrs.map((m2) => multiaddr(m2).toString()));
      await this.providers.addProvider(cid, peerIdFromBytes(pi.id));
    }));
    return void 0;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var FindNodeHandler = class {
  peerRouting;
  peerInfoMapper;
  peerId;
  addressManager;
  log;
  constructor(components, init) {
    const { peerRouting, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
    this.peerId = components.peerId;
    this.addressManager = components.addressManager;
    this.peerRouting = peerRouting;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId2, msg) {
    this.log("incoming request from %p for peers closer to %b", peerId2, msg.key);
    if (msg.key == null) {
      throw new CodeError("Invalid FIND_NODE message received - key was missing", "ERR_INVALID_MESSAGE");
    }
    const closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId2);
    if (equals47(this.peerId.toBytes(), msg.key)) {
      closer.push({
        id: this.peerId,
        multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
    }
    const response = {
      type: MessageType.FIND_NODE,
      clusterLevel: msg.clusterLevel,
      closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
        id: peerInfo.id.toBytes(),
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: []
    };
    if (response.closer.length === 0) {
      this.log("could not find any peers closer to %b than %p", msg.key, peerId2);
    }
    return response;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var GetProvidersHandler = class {
  peerRouting;
  providers;
  peerStore;
  peerInfoMapper;
  log;
  constructor(components, init) {
    const { peerRouting, providers, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
    this.peerStore = components.peerStore;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  async handle(peerId2, msg) {
    if (msg.key == null) {
      throw new CodeError("Invalid GET_PROVIDERS message received - key was missing", "ERR_INVALID_MESSAGE");
    }
    let cid;
    try {
      cid = CID18.decode(msg.key);
    } catch (err) {
      throw new CodeError("Invalid CID", "ERR_INVALID_CID");
    }
    this.log("%p asking for providers for %s", peerId2, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId2)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = {
      type: MessageType.GET_PROVIDERS,
      key: msg.key,
      clusterLevel: msg.clusterLevel,
      closer: closerPeers.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
        id: peerInfo.id.toBytes(),
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: providerPeers.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
        id: peerInfo.id.toBytes(),
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }))
    };
    this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
    return response;
  }
  async _getAddresses(peerId2) {
    return [];
  }
  async _getPeers(peerIds) {
    const output3 = [];
    for (const peerId2 of peerIds) {
      try {
        const peer = await this.peerStore.get(peerId2);
        const peerAfterFilter = this.peerInfoMapper({
          id: peerId2,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        });
        if (peerAfterFilter.multiaddrs.length > 0) {
          output3.push(peerAfterFilter);
        }
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
    return output3;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var GetValueHandler = class {
  peerStore;
  datastore;
  peerRouting;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
    this.peerStore = components.peerStore;
    this.datastore = components.datastore;
    this.peerRouting = init.peerRouting;
  }
  async handle(peerId2, msg) {
    const key = msg.key;
    this.log("%p asked for key %b", peerId2, key);
    if (key == null || key.length === 0) {
      throw new CodeError("Invalid key", "ERR_INVALID_KEY");
    }
    const response = {
      type: MessageType.GET_VALUE,
      key,
      clusterLevel: msg.clusterLevel,
      closer: [],
      providers: []
    };
    if (isPublicKeyKey(key)) {
      this.log("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const peer = await this.peerStore.get(idFromKey);
        if (peer.id.publicKey == null) {
          throw new CodeError("No public key found in key book", "ERR_NOT_FOUND");
        }
        pubKey = peer.id.publicKey;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (pubKey != null) {
        this.log("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(key, peerId2)
    ]);
    if (record != null) {
      this.log("had record for %b in local datastore", key);
      response.record = record.serialize();
    }
    if (closer.length > 0) {
      this.log("had %s closer peers in routing table", closer.length);
      response.closer = closer.map((peerInfo) => ({
        id: peerInfo.id.toBytes(),
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }));
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record if it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   */
  async _checkLocalDatastore(key) {
    this.log("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.datastore.get(dsKey);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw new CodeError("Invalid record", "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var PingHandler = class {
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
  }
  async handle(peerId2, msg) {
    this.log("ping from %p", peerId2);
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var PutValueHandler = class {
  components;
  validators;
  log;
  constructor(components, init) {
    const { validators: validators2 } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
    this.validators = validators2;
  }
  async handle(peerId2, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId2, key);
    if (msg.record == null) {
      const errMsg = `Empty record from: ${peerId2.toString()}`;
      this.log.error(errMsg);
      throw new CodeError(errMsg, "ERR_EMPTY_RECORD");
    }
    try {
      const deserializedRecord = Libp2pRecord.deserialize(msg.record);
      await verifyRecord(this.validators, deserializedRecord);
      deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
      const recordKey = bufferToRecordKey(deserializedRecord.key);
      await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err) {
      this.log("did not put record for key %b into datastore %o", key, err);
    }
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC = class {
  handlers;
  routingTable;
  log;
  constructor(components, init) {
    const { providers, peerRouting, validators: validators2, logPrefix, peerInfoMapper } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc`);
    this.routingTable = init.routingTable;
    this.handlers = {
      [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, { peerRouting, logPrefix }),
      [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, { validators: validators2, logPrefix }),
      [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, { peerRouting, logPrefix, peerInfoMapper }),
      [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, { providers, logPrefix }),
      [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, { peerRouting, providers, logPrefix, peerInfoMapper }),
      [MessageType.PING.toString()]: new PingHandler(components, { logPrefix })
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId2, msg) {
    try {
      await this.routingTable.add(peerId2);
    } catch (err) {
      this.log.error("Failed to update the kbucket store", err);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return handler.handle(peerId2, msg);
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId2 = connection.remotePeer;
      try {
        await this.routingTable.add(peerId2);
      } catch (err) {
        this.log.error(err);
      }
      const self2 = this;
      await pipe5(stream, (source) => decode2(source), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message2.decode(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId2);
          const res = await self2.handleMessage(peerId2, desMessage);
          if (res != null) {
            yield Message2.encode(res);
          }
        }
      }, (source) => encode2(source), stream);
    }).catch((err) => {
      this.log.error(err);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends TypedEventEmitter {
  log;
  components;
  protocol;
  running;
  registrarId;
  constructor(components, init) {
    super();
    const { protocol, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
    this.running = false;
    this.protocol = protocol;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.registrarId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId2) => {
        this.log("observed peer %p with protocol %s", peerId2, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId2
        }));
      }
    });
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DHTContentRouting = class {
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid, options2 = {}) {
    await src_default30(this.dht.provide(cid, options2));
  }
  async *findProviders(cid, options2 = {}) {
    for await (const event of this.dht.findProviders(cid, options2)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value, options2) {
    await src_default30(this.dht.put(key, value, options2));
  }
  async get(key, options2) {
    for await (const event of this.dht.get(key, options2)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
};
var DHTPeerRouting = class {
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId2, options2 = {}) {
    for await (const event of this.dht.findPeer(peerId2, options2)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options2 = {}) {
    for await (const event of this.dht.getClosestPeers(key, options2)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var KadDHT = class extends TypedEventEmitter {
  protocol;
  routingTable;
  providers;
  network;
  peerRouting;
  components;
  log;
  running;
  kBucketSize;
  clientMode;
  validators;
  selectors;
  queryManager;
  contentFetching;
  contentRouting;
  routingTableRefresh;
  rpc;
  topologyListener;
  querySelf;
  maxInboundStreams;
  maxOutboundStreams;
  dhtContentRouting;
  dhtPeerRouting;
  peerInfoMapper;
  /**
   * Create a new KadDHT
   */
  constructor(components, init = {}) {
    super();
    const { kBucketSize, clientMode, validators: validators2, selectors: selectors2, querySelfInterval, protocol, logPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams, providers: providersInit } = init;
    const loggingPrefix = logPrefix ?? "libp2p:kad-dht";
    this.running = false;
    this.components = components;
    this.log = components.logger.forComponent(loggingPrefix);
    this.protocol = protocol ?? PROTOCOL;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
    this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
    this.routingTable = new RoutingTable(components, {
      kBucketSize,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol,
      logPrefix: loggingPrefix
    });
    this.providers = new Providers(components, providersInit ?? {});
    this.validators = {
      ...validators,
      ...validators2
    };
    this.selectors = {
      ...selectors,
      ...selectors2
    };
    this.network = new Network2(components, {
      protocol: this.protocol,
      logPrefix: loggingPrefix
    });
    const initialQuerySelfHasRun = pDefer9();
    if (init.allowQueryWithZeroPeers === true) {
      initialQuerySelfHasRun.resolve();
    }
    this.queryManager = new QueryManager(components, {
      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      logPrefix: loggingPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      logPrefix: loggingPrefix
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      network: this.network,
      logPrefix: loggingPrefix
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      logPrefix: loggingPrefix
    });
    this.routingTableRefresh = new RoutingTableRefresh(components, {
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      logPrefix: loggingPrefix
    });
    this.rpc = new RPC(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      logPrefix: loggingPrefix,
      peerInfoMapper: this.peerInfoMapper
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      logPrefix: loggingPrefix
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      initialInterval: init.initialQuerySelfInterval,
      logPrefix: loggingPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err) => {
        this.log.error("could not add %p to routing table", peerData.id, err);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId2 = evt.detail;
      Promise.resolve().then(async () => {
        const peer = await this.components.peerStore.get(peerId2);
        const peerData = {
          id: peerId2,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        };
        await this.onPeerConnect(peerData);
      }).catch((err) => {
        this.log.error("could not add %p to routing table", peerId2, err);
      });
    });
    this.dhtPeerRouting = new DHTPeerRouting(this);
    this.dhtContentRouting = new DHTContentRouting(this);
    if (init.clientMode == null) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.log("received update of self-peer info");
        void Promise.resolve().then(async () => {
          const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => multiaddrIsPublic(multiaddr2));
          const mode = this.getMode();
          if (hasPublicAddress && mode === "client") {
            await this.setMode("server");
          } else if (mode === "server" && !hasPublicAddress) {
            await this.setMode("client");
          }
        }).catch((err) => {
          this.log.error("error setting dht server mode", err);
        });
      });
    }
  }
  [Symbol.toStringTag] = "@libp2p/kad-dht";
  [serviceCapabilities] = [
    "@libp2p/content-routing",
    "@libp2p/peer-routing",
    "@libp2p/peer-discovery"
  ];
  [serviceDependencies] = [
    "@libp2p/identify"
  ];
  get [contentRoutingSymbol]() {
    return this.dhtContentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.dhtPeerRouting;
  }
  get [peerDiscoverySymbol]() {
    return this;
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected", peerData.id);
    peerData = this.peerInfoMapper(peerData);
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err) {
      this.log.error("could not add %p to routing table", peerData.id, err);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode) {
    await this.components.registrar.unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await start(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.topologyListener, this.routingTableRefresh);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    await stop(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options2 = {}) {
    yield* this.contentFetching.put(key, value, options2);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options2 = {}) {
    yield* this.contentFetching.get(key, options2);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options2 = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options2);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options2 = {}) {
    yield* this.contentRouting.findProviders(key, options2);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    yield* this.peerRouting.findPeer(id, options2);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options2 = {}) {
    yield* this.peerRouting.getClosestPeers(key, options2);
  }
  async refreshRoutingTable() {
    this.routingTableRefresh.refreshTable(true);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/index.js
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
  EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
})(EventTypes || (EventTypes = {}));
function kadDHT(init = {}) {
  return (components) => new KadDHT(components, init);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports17 = {};
__export(base10_exports17, {
  base10: () => base1017
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bytes.js
var empty22 = new Uint8Array(0);
function equals50(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce22(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString34(str) {
  return new TextEncoder().encode(str);
}
function toString34(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/vendor/base-x.js
function base35(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src21 = base35;
var _brrp__multiformats_scope_baseX21 = src21;
var base_x_default22 = _brrp__multiformats_scope_baseX21;

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base.js
var Encoder22 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder23 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or24(this, decoder);
  }
};
var ComposedDecoder22 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or24(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or24(left, right) {
  return new ComposedDecoder22({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec22 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder22(name29, prefix, baseEncode);
    this.decoder = new Decoder23(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from39({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec22(name29, prefix, encode116, decode144);
}
function baseX21({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default22(alphabet27, name29);
  return from39({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce22(decode144(text))
  });
}
function decode98(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode77(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464822({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from39({
    prefix,
    name: name29,
    encode(input) {
      return encode77(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode98(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base10.js
var base1017 = baseX21({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports17 = {};
__export(base16_exports17, {
  base16: () => base1617,
  base16upper: () => base16upper17
});
var base1617 = rfc464822({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper17 = rfc464822({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports17 = {};
__export(base2_exports17, {
  base2: () => base217
});
var base217 = rfc464822({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports17 = {};
__export(base256emoji_exports17, {
  base256emoji: () => base256emoji17
});
var alphabet17 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars17 = alphabet17.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes17 = alphabet17.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode78(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars17[c];
    return p;
  }, "");
}
function decode99(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes17[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji17 = from39({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode78,
  decode: decode99
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports18 = {};
__export(base32_exports18, {
  base32: () => base3220,
  base32hex: () => base32hex20,
  base32hexpad: () => base32hexpad20,
  base32hexpadupper: () => base32hexpadupper20,
  base32hexupper: () => base32hexupper20,
  base32pad: () => base32pad20,
  base32padupper: () => base32padupper20,
  base32upper: () => base32upper20,
  base32z: () => base32z20
});
var base3220 = rfc464822({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper20 = rfc464822({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad20 = rfc464822({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper20 = rfc464822({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex20 = rfc464822({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper20 = rfc464822({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad20 = rfc464822({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper20 = rfc464822({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z20 = rfc464822({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports17 = {};
__export(base36_exports17, {
  base36: () => base3617,
  base36upper: () => base36upper17
});
var base3617 = baseX21({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper17 = baseX21({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports18 = {};
__export(base58_exports18, {
  base58btc: () => base58btc21,
  base58flickr: () => base58flickr21
});
var base58btc21 = baseX21({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr21 = baseX21({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports17 = {};
__export(base64_exports17, {
  base64: () => base6420,
  base64pad: () => base64pad20,
  base64url: () => base64url20,
  base64urlpad: () => base64urlpad20
});
var base6420 = rfc464822({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad20 = rfc464822({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url20 = rfc464822({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad20 = rfc464822({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports17 = {};
__export(base8_exports17, {
  base8: () => base817
});
var base817 = rfc464822({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports33 = {};
__export(identity_exports33, {
  identity: () => identity33
});
var identity33 = from39({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString34(buf3),
  decode: (str) => fromString34(str)
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder21 = new TextEncoder();
var textDecoder20 = new TextDecoder();

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports34 = {};
__export(identity_exports34, {
  identity: () => identity34
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/vendor/varint.js
var encode_119 = encode79;
var MSB20 = 128;
var REST20 = 127;
var MSBALL19 = ~REST20;
var INT19 = Math.pow(2, 31);
function encode79(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT19) {
    out[offset++] = num & 255 | MSB20;
    num /= 128;
  }
  while (num & MSBALL19) {
    out[offset++] = num & 255 | MSB20;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode79.bytes = offset - oldOffset + 1;
  return out;
}
var decode100 = read20;
var MSB$119 = 128;
var REST$119 = 127;
function read20(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read20.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$119) << shift : (b & REST$119) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$119);
  read20.bytes = counter - offset;
  return res;
}
var N120 = Math.pow(2, 7);
var N220 = Math.pow(2, 14);
var N320 = Math.pow(2, 21);
var N420 = Math.pow(2, 28);
var N520 = Math.pow(2, 35);
var N620 = Math.pow(2, 42);
var N720 = Math.pow(2, 49);
var N819 = Math.pow(2, 56);
var N919 = Math.pow(2, 63);
var length21 = function(value) {
  return value < N120 ? 1 : value < N220 ? 2 : value < N320 ? 3 : value < N420 ? 4 : value < N520 ? 5 : value < N620 ? 6 : value < N720 ? 7 : value < N819 ? 8 : value < N919 ? 9 : 10;
};
var varint19 = {
  encode: encode_119,
  decode: decode100,
  encodingLength: length21
};
var _brrp_varint19 = varint19;
var varint_default19 = _brrp_varint19;

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/varint.js
function decode101(data, offset = 0) {
  const code33 = varint_default19.decode(data, offset);
  return [code33, varint_default19.decode.bytes];
}
function encodeTo19(int, target, offset = 0) {
  varint_default19.encode(int, target, offset);
  return target;
}
function encodingLength20(int) {
  return varint_default19.encodingLength(int);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/digest.js
function create21(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength20(code33);
  const digestOffset = sizeOffset + encodingLength20(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo19(code33, bytes3, 0);
  encodeTo19(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest19(code33, size, digest27, bytes3);
}
function decode102(multihash) {
  const bytes3 = coerce22(multihash);
  const [code33, sizeOffset] = decode101(bytes3);
  const [size, digestOffset] = decode101(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest19(code33, size, digest27, bytes3);
}
function equals51(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals50(a.bytes, data.bytes);
  }
}
var Digest19 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/identity.js
var code23 = 0;
var name17 = "identity";
var encode80 = coerce22;
function digest17(input) {
  return create21(code23, encode80(input));
}
var identity34 = { code: code23, name: name17, encode: encode80, digest: digest17 };

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports17 = {};
__export(sha2_browser_exports17, {
  sha256: () => sha25619,
  sha512: () => sha51219
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/hasher.js
function from40({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher18(name29, code33, encode116);
}
var Hasher18 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create21(this.code, result) : result.then((digest27) => create21(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha18(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25619 = from40({
  name: "sha2-256",
  code: 18,
  encode: sha18("SHA-256")
});
var sha51219 = from40({
  name: "sha2-512",
  code: 19,
  encode: sha18("SHA-512")
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/cid.js
function format19(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV019(bytes3, baseCache19(link), base45 ?? base58btc21.encoder);
    default:
      return toStringV119(bytes3, baseCache19(link), base45 ?? base3220.encoder);
  }
}
var cache21 = /* @__PURE__ */ new WeakMap();
function baseCache19(cid) {
  const baseCache28 = cache21.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache21.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID19 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE19) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE19) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create21(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals51(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format19(this, base45);
  }
  toJSON() {
    return { "/": format19(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID19(version3, code33, multihash.bytes));
    } else if (value[cidSymbol19] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode102(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE19) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE19}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID19(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE19, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce22(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest19(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode101(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE19;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes19(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache19(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes19(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc21;
      return [
        base58btc21.prefix,
        decoder.decode(`${base58btc21.prefix}${source}`)
      ];
    }
    case base58btc21.prefix: {
      const decoder = base45 ?? base58btc21;
      return [base58btc21.prefix, decoder.decode(source)];
    }
    case base3220.prefix: {
      const decoder = base45 ?? base3220;
      return [base3220.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV019(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc21.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV119(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE19 = 112;
var SHA_256_CODE19 = 18;
function encodeCID19(version3, code33, multihash) {
  const codeOffset = encodingLength20(version3);
  const hashOffset = codeOffset + encodingLength20(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo19(version3, bytes3, 0);
  encodeTo19(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol19 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/basics.js
var bases17 = { ...identity_exports33, ...base2_exports17, ...base8_exports17, ...base10_exports17, ...base16_exports17, ...base32_exports18, ...base36_exports17, ...base58_exports18, ...base64_exports17, ...base256emoji_exports17 };
var hashes17 = { ...sha2_browser_exports17, ...identity_exports34 };

// node_modules/@libp2p/keychain/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe20(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/keychain/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec18(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string18 = createCodec18("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii17 = createCodec18("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe20(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES17 = {
  utf8: string18,
  "utf-8": string18,
  hex: bases17.base16,
  latin1: ascii17,
  ascii: ascii17,
  binary: ascii17,
  ...bases17
};
var bases_default17 = BASES17;

// node_modules/@libp2p/keychain/node_modules/uint8arrays/dist/src/from-string.js
function fromString35(string27, encoding = "utf8") {
  const base45 = bases_default17[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/keychain/node_modules/uint8arrays/dist/src/to-string.js
function toString35(array, encoding = "utf8") {
  const base45 = bases_default17[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/keychain/node_modules/interface-datastore/dist/src/key.js
var pathSepS5 = "/";
var pathSepB5 = new TextEncoder().encode(pathSepS5);
var pathSep5 = pathSepB5[0];
var Key5 = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString35(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep5) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString35(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS5));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB5;
    }
    if (this._buf[0] !== pathSep5) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep5, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep5) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS5).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType4(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue4(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS5)) {
      p += pathSepS5;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS5);
    }
    return new _Key(list.slice(0, -1).join(pathSepS5));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS5) {
      return key;
    } else if (key.toString() === pathSepS5) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten4(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType4(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue4(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten4(arr) {
  return [].concat(...arr);
}

// node_modules/merge-options/index.mjs
var import_index26 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index26.default;

// node_modules/@libp2p/keychain/dist/src/keychain.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/@libp2p/keychain/dist/src/errors.js
var codes3;
(function(codes7) {
  codes7["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes7["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes7["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes7["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes7["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes7["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes7["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes7["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes7["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes7["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes7["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes7["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes7["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes7["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes7["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
})(codes3 || (codes3 = {}));

// node_modules/@libp2p/keychain/dist/src/keychain.js
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions3 = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name29) {
  if (name29 == null) {
    return false;
  }
  if (typeof name29 !== "string") {
    return false;
  }
  return name29 === (0, import_sanitize_filename.default)(name29.trim()) && name29.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay2 = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay2));
}
function DsName(name29) {
  return new Key5(keyPrefix + name29);
}
function DsInfoName(name29) {
  return new Key5(infoPrefix + name29);
}
var DefaultKeychain = class {
  components;
  init;
  log;
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:keychain");
    this.init = merge_options_default(defaultOptions3, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf22(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek });
  }
  [Symbol.toStringTag] = "@libp2p/keychain";
  [serviceCapabilities] = [
    "@libp2p/keychain"
  ];
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options2 = Object.assign({}, defaultOptions3);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options2.dek.salt = toString35(randomBytes2(saltLength), "base64");
    return options2;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions3;
  }
  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
   */
  async createKey(name29, type, size = 2048) {
    if (!validateKeyName(name29) || name29 === "self") {
      await randomDelay();
      throw new CodeError("Invalid key name", codes3.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw new CodeError("Invalid key type", codes3.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name29);
    const exists3 = await this.components.datastore.has(dsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError("Key name already exists", codes3.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw new CodeError("Invalid RSA key size", codes3.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair4(type, size);
      const kid = await keypair.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes3.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name29,
        id: kid
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString35(pem));
      batch.put(DsInfoName(name29), fromString35(JSON.stringify(keyInfo)));
      await batch.commit();
    } catch (err) {
      await randomDelay();
      throw err;
    }
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString35(value.value)));
    }
    return info;
  }
  /**
   * Find a key by it's id
   */
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      const key = keys.find((k) => k.id === id);
      if (key == null) {
        throw new CodeError(`Key with id '${id}' does not exist.`, codes3.ERR_KEY_NOT_FOUND);
      }
      return key;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @returns {Promise<KeyInfo>}
   */
  async findKeyByName(name29) {
    if (!validateKeyName(name29)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name29);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString35(res));
    } catch (err) {
      await randomDelay();
      this.log.error(err);
      throw new CodeError(`Key '${name29}' does not exist.`, codes3.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @returns {Promise<KeyInfo>}
   */
  async removeKey(name29) {
    if (!validateKeyName(name29) || name29 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name29);
    const keyInfo = await this.findKeyByName(name29);
    const batch = this.components.datastore.batch();
    batch.delete(dsname);
    batch.delete(DsInfoName(name29));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid old key name '${oldName}'`, codes3.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid new key name '${newName}'`, codes3.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists3 = await this.components.datastore.has(newDsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError(`Key '${newName}' already exists`, codes3.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString35(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDsname, pem);
      batch.put(newInfoName, fromString35(JSON.stringify(keyInfo)));
      batch.delete(oldDsname);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   */
  async exportKey(name29, password) {
    if (!validateKeyName(name29)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw new CodeError("Password is required", codes3.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name29);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString35(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes3.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      const keyString = await privateKey.export(password);
      return keyString;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PeerId
   */
  async exportPeerId(name29) {
    const password = "temporary-password";
    const pem = await this.exportKey(name29, password);
    const privateKey = await importKey(pem, password);
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  }
  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @returns {Promise<KeyInfo>}
   */
  async importKey(name29, pem, password) {
    if (!validateKeyName(name29) || name29 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw new CodeError("PEM encoded key is required", codes3.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name29);
    const exists3 = await this.components.datastore.has(dsname);
    if (exists3) {
      await randomDelay();
      throw new CodeError(`Key '${name29}' already exists`, codes3.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err) {
      await randomDelay();
      throw new CodeError("Cannot read the key, most likely the password is wrong", codes3.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes3.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name29,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(dsname, fromString35(pem));
    batch.put(DsInfoName(name29), fromString35(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Import a peer key
   */
  async importPeer(name29, peer) {
    try {
      if (!validateKeyName(name29)) {
        throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw new CodeError("PeerId is required", codes3.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw new CodeError("PeerId.privKey is required", codes3.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey3(peer.privateKey);
      const dsname = DsName(name29);
      const exists3 = await this.components.datastore.has(dsname);
      if (exists3) {
        await randomDelay();
        throw new CodeError(`Key '${name29}' already exists`, codes3.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes3.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name29,
        id: peer.toString()
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString35(pem));
      batch.put(DsInfoName(name29), fromString35(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Gets the private key as PEM encoded PKCS #8 string
   */
  async getPrivateKey(name29) {
    if (!validateKeyName(name29)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name29}'`, codes3.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name29);
      const res = await this.components.datastore.get(dsname);
      return toString35(res);
    } catch (err) {
      await randomDelay();
      this.log.error(err);
      throw new CodeError(`Key '${name29}' does not exist.`, codes3.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid old pass type '${typeof oldPass}'`, codes3.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid new pass type '${typeof newPass}'`, codes3.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw new CodeError(`Invalid pass length ${newPass.length}`, codes3.ERR_INVALID_PASS_LENGTH);
    }
    this.log("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw new CodeError("dek missing", codes3.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf22(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString35(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString35(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString35(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    this.log("keychain reconstructed");
  }
};

// node_modules/@libp2p/keychain/dist/src/index.js
function keychain(init = {}) {
  return (components) => {
    return new DefaultKeychain(components, init);
  };
}

// node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  memoryStorage;
  points;
  duration;
  blockDuration;
  execEvenly;
  execEvenlyMinDelayMs;
  keyPrefix;
  constructor(opts = {}) {
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.execEvenly = opts.execEvenly ?? false;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  async consume(key, pointsToConsume = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new CodeError("Rate limit exceeded", "ERR_RATE_LIMIT_EXCEEDED", res);
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delayMs < this.execEvenlyMinDelayMs) {
        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      await delay_default(delayMs);
    }
    return res;
  }
  penalty(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options2) {
    if (options2?.customDuration != null && options2.customDuration >= 0) {
      return options2.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  storage;
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value, durationSec);
    }
    return this.set(key, value, durationSec);
  }
  set(key, value, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// node_modules/@libp2p/mplex/node_modules/it-pipe/dist/src/index.js
function pipe6(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex5(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable5(first4) || isAsyncIterable27(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex5(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex5(fns[i])) {
        fns[i] = duplexPipelineFn5(fns[i]);
      }
    }
  }
  return rawPipe5(...fns);
}
var rawPipe5 = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable27 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable5 = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex5 = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn5 = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable27(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable5(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe21(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports18 = {};
__export(base10_exports18, {
  base10: () => base1018
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bytes.js
var empty23 = new Uint8Array(0);
function equals52(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce23(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString36(str) {
  return new TextEncoder().encode(str);
}
function toString36(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/vendor/base-x.js
function base37(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src22 = base37;
var _brrp__multiformats_scope_baseX22 = src22;
var base_x_default23 = _brrp__multiformats_scope_baseX22;

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base.js
var Encoder23 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder24 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or25(this, decoder);
  }
};
var ComposedDecoder23 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or25(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or25(left, right) {
  return new ComposedDecoder23({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec23 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder23(name29, prefix, baseEncode);
    this.decoder = new Decoder24(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from41({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec23(name29, prefix, encode116, decode144);
}
function baseX22({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default23(alphabet27, name29);
  return from41({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce23(decode144(text))
  });
}
function decode103(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode81(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464823({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from41({
    prefix,
    name: name29,
    encode(input) {
      return encode81(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode103(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base10.js
var base1018 = baseX22({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports18 = {};
__export(base16_exports18, {
  base16: () => base1618,
  base16upper: () => base16upper18
});
var base1618 = rfc464823({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper18 = rfc464823({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports18 = {};
__export(base2_exports18, {
  base2: () => base218
});
var base218 = rfc464823({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports18 = {};
__export(base256emoji_exports18, {
  base256emoji: () => base256emoji18
});
var alphabet18 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars18 = alphabet18.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes18 = alphabet18.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode82(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars18[c];
    return p;
  }, "");
}
function decode104(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes18[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji18 = from41({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode82,
  decode: decode104
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports19 = {};
__export(base32_exports19, {
  base32: () => base3221,
  base32hex: () => base32hex21,
  base32hexpad: () => base32hexpad21,
  base32hexpadupper: () => base32hexpadupper21,
  base32hexupper: () => base32hexupper21,
  base32pad: () => base32pad21,
  base32padupper: () => base32padupper21,
  base32upper: () => base32upper21,
  base32z: () => base32z21
});
var base3221 = rfc464823({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper21 = rfc464823({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad21 = rfc464823({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper21 = rfc464823({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex21 = rfc464823({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper21 = rfc464823({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad21 = rfc464823({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper21 = rfc464823({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z21 = rfc464823({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports18 = {};
__export(base36_exports18, {
  base36: () => base3618,
  base36upper: () => base36upper18
});
var base3618 = baseX22({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper18 = baseX22({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports19 = {};
__export(base58_exports19, {
  base58btc: () => base58btc22,
  base58flickr: () => base58flickr22
});
var base58btc22 = baseX22({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr22 = baseX22({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports18 = {};
__export(base64_exports18, {
  base64: () => base6421,
  base64pad: () => base64pad21,
  base64url: () => base64url21,
  base64urlpad: () => base64urlpad21
});
var base6421 = rfc464823({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad21 = rfc464823({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url21 = rfc464823({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad21 = rfc464823({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports18 = {};
__export(base8_exports18, {
  base8: () => base818
});
var base818 = rfc464823({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports35 = {};
__export(identity_exports35, {
  identity: () => identity35
});
var identity35 = from41({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString36(buf3),
  decode: (str) => fromString36(str)
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder22 = new TextEncoder();
var textDecoder21 = new TextDecoder();

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports36 = {};
__export(identity_exports36, {
  identity: () => identity36
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/vendor/varint.js
var encode_120 = encode83;
var MSB21 = 128;
var REST21 = 127;
var MSBALL20 = ~REST21;
var INT20 = Math.pow(2, 31);
function encode83(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT20) {
    out[offset++] = num & 255 | MSB21;
    num /= 128;
  }
  while (num & MSBALL20) {
    out[offset++] = num & 255 | MSB21;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode83.bytes = offset - oldOffset + 1;
  return out;
}
var decode105 = read21;
var MSB$120 = 128;
var REST$120 = 127;
function read21(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read21.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$120) << shift : (b & REST$120) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$120);
  read21.bytes = counter - offset;
  return res;
}
var N121 = Math.pow(2, 7);
var N221 = Math.pow(2, 14);
var N321 = Math.pow(2, 21);
var N421 = Math.pow(2, 28);
var N521 = Math.pow(2, 35);
var N621 = Math.pow(2, 42);
var N721 = Math.pow(2, 49);
var N820 = Math.pow(2, 56);
var N920 = Math.pow(2, 63);
var length22 = function(value) {
  return value < N121 ? 1 : value < N221 ? 2 : value < N321 ? 3 : value < N421 ? 4 : value < N521 ? 5 : value < N621 ? 6 : value < N721 ? 7 : value < N820 ? 8 : value < N920 ? 9 : 10;
};
var varint20 = {
  encode: encode_120,
  decode: decode105,
  encodingLength: length22
};
var _brrp_varint20 = varint20;
var varint_default20 = _brrp_varint20;

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/varint.js
function decode106(data, offset = 0) {
  const code33 = varint_default20.decode(data, offset);
  return [code33, varint_default20.decode.bytes];
}
function encodeTo20(int, target, offset = 0) {
  varint_default20.encode(int, target, offset);
  return target;
}
function encodingLength21(int) {
  return varint_default20.encodingLength(int);
}

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/digest.js
function create22(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength21(code33);
  const digestOffset = sizeOffset + encodingLength21(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo20(code33, bytes3, 0);
  encodeTo20(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest20(code33, size, digest27, bytes3);
}
function decode107(multihash) {
  const bytes3 = coerce23(multihash);
  const [code33, sizeOffset] = decode106(bytes3);
  const [size, digestOffset] = decode106(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest20(code33, size, digest27, bytes3);
}
function equals53(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals52(a.bytes, data.bytes);
  }
}
var Digest20 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/identity.js
var code24 = 0;
var name18 = "identity";
var encode84 = coerce23;
function digest18(input) {
  return create22(code24, encode84(input));
}
var identity36 = { code: code24, name: name18, encode: encode84, digest: digest18 };

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports18 = {};
__export(sha2_browser_exports18, {
  sha256: () => sha25620,
  sha512: () => sha51220
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/hasher.js
function from42({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher19(name29, code33, encode116);
}
var Hasher19 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create22(this.code, result) : result.then((digest27) => create22(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha19(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25620 = from42({
  name: "sha2-256",
  code: 18,
  encode: sha19("SHA-256")
});
var sha51220 = from42({
  name: "sha2-512",
  code: 19,
  encode: sha19("SHA-512")
});

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/cid.js
function format20(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV020(bytes3, baseCache20(link), base45 ?? base58btc22.encoder);
    default:
      return toStringV120(bytes3, baseCache20(link), base45 ?? base3221.encoder);
  }
}
var cache22 = /* @__PURE__ */ new WeakMap();
function baseCache20(cid) {
  const baseCache28 = cache22.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache22.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID20 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE20) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE20) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create22(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals53(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format20(this, base45);
  }
  toJSON() {
    return { "/": format20(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID20(version3, code33, multihash.bytes));
    } else if (value[cidSymbol20] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode107(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE20) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE20}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID20(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE20, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce23(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest20(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode106(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE20;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes20(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache20(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes20(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc22;
      return [
        base58btc22.prefix,
        decoder.decode(`${base58btc22.prefix}${source}`)
      ];
    }
    case base58btc22.prefix: {
      const decoder = base45 ?? base58btc22;
      return [base58btc22.prefix, decoder.decode(source)];
    }
    case base3221.prefix: {
      const decoder = base45 ?? base3221;
      return [base3221.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV020(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc22.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV120(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE20 = 112;
var SHA_256_CODE20 = 18;
function encodeCID20(version3, code33, multihash) {
  const codeOffset = encodingLength21(version3);
  const hashOffset = codeOffset + encodingLength21(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo20(version3, bytes3, 0);
  encodeTo20(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol20 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/basics.js
var bases18 = { ...identity_exports35, ...base2_exports18, ...base8_exports18, ...base10_exports18, ...base16_exports18, ...base32_exports19, ...base36_exports18, ...base58_exports19, ...base64_exports18, ...base256emoji_exports18 };
var hashes18 = { ...sha2_browser_exports18, ...identity_exports36 };

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec19(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string19 = createCodec19("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii18 = createCodec19("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe21(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES18 = {
  utf8: string19,
  "utf-8": string19,
  hex: bases18.base16,
  latin1: ascii18,
  ascii: ascii18,
  binary: ascii18,
  ...bases18
};
var bases_default18 = BASES18;

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/from-string.js
function fromString37(string27, encoding = "utf8") {
  const base45 = bases_default18[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/to-string.js
function toString37(array, encoding = "utf8") {
  const base45 = bases_default18[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder25 = class {
  _buffer;
  _headerInfo;
  _maxMessageSize;
  _maxUnprocessedMessageQueueSize;
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.code === "ERR_MSG_TOO_BIG") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length30, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length30) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length30);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length30);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h2, offset } = readVarInt(data);
    const { value: length30, offset: end } = readVarInt(data, offset);
    const type = h2 & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length30 > this._maxMessageSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
    return { id: h2 >> 3, type, offset: offset + end, length: length30 };
  }
};
var MSB22 = 128;
var REST22 = 127;
function readVarInt(buf3, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf3.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3.get(counter++);
    res += shift < 28 ? (b & REST22) << shift : (b & REST22) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB22);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder24 = class {
  _pool;
  _poolOffset;
  constructor() {
    this._pool = allocUnsafe21(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool2 = this._pool;
    let offset = this._poolOffset;
    encode(msg.id << 3 | msg.type, pool2, offset);
    offset += encodingLength(msg.id << 3 | msg.type);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      encode(msg.data.length, pool2, offset);
      offset += encodingLength(msg.data.length);
    } else {
      encode(0, pool2, offset);
      offset += encodingLength(0);
    }
    const header = pool2.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe21(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder24();
async function* encode85(source) {
  for await (const message2 of source) {
    const list = new Uint8ArrayList();
    encoder.write(message2, list);
    yield list;
  }
}

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  name;
  streamId;
  send;
  types;
  maxDataSize;
  constructor(init) {
    super(init);
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
    this.maxDataSize = init.maxDataSize;
  }
  async sendNewStream() {
    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString37(this.name)) });
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxDataSize);
      await this.send({
        id: this.streamId,
        type: this.types.MESSAGE,
        data: data.sublist(0, toSend)
      });
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this.send({ id: this.streamId, type: this.types.RESET });
  }
  async sendCloseWrite() {
    await this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  async sendCloseRead() {
  }
};
function createStream(options2) {
  const { id, name: name29, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options2;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name29 ?? id}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send,
    log: options2.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)
  });
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
var CLOSE_TIMEOUT2 = 500;
function printMessage(msg) {
  const output3 = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output3.data = toString37(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output3.data = toString37(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output3;
}
var MplexStreamMuxer = class {
  protocol = "/mplex/6.7.0";
  sink;
  source;
  log;
  _streamId;
  _streams;
  _init;
  _source;
  closeController;
  rateLimiter;
  closeTimeout;
  logger;
  constructor(components, init) {
    init = init ?? {};
    this.log = components.logger.forComponent("libp2p:mplex");
    this.logger = components.logger;
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT2;
    this.sink = this._createSink();
    this._source = pushable({
      objectMode: true,
      onEnd: () => {
        for (const stream of this._streams.initiators.values()) {
          stream.destroy();
        }
        for (const stream of this._streams.receivers.values()) {
          stream.destroy();
        }
      }
    });
    this.source = pipe6(this._source, (source) => encode85(source));
    this.closeController = new AbortController();
    this.rateLimiter = new RateLimiter({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name29) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name29 = name29 == null ? id.toString() : name29.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name29, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  async close(options2) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const signal = options2?.signal ?? AbortSignal.timeout(this.closeTimeout);
    try {
      await Promise.all(this.streams.map(async (s2) => s2.close({
        signal
      })));
      this._source.end();
      await this._source.onEmpty({
        signal
      });
      this.closeController.abort();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err) {
    if (this.closeController.signal.aborted) {
      return;
    }
    this.streams.forEach((s2) => {
      s2.abort(err);
    });
    this.closeController.abort(err);
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options2) {
    const { id, name: name29 } = options2;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name29, type: "receiver", registry });
  }
  _newStream(options2) {
    const { id, name: name29, type, registry } = options2;
    this.log("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new CodeError("Too many outbound streams open", "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = async (msg) => {
      if (this.log.enabled) {
        this.log.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      this.log("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name29, send, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      const abortListener = () => {
        closeSource(source, this.log);
      };
      this.closeController.signal.addEventListener("abort", abortListener);
      try {
        const decoder = new Decoder25(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        this.log("error in sink", err);
        this._source.end(err);
      } finally {
        this.closeController.signal.removeEventListener("abort", abortListener);
      }
    };
    return sink;
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (this.log.enabled) {
      this.log.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        this.log("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString37(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      this.log("missing stream %s for message type %s", id, MessageTypeNames[type]);
      try {
        await this.rateLimiter.consume("missing-stream", 1);
      } catch {
        this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
        this.abort(new Error("Too many messages for missing streams"));
        return;
      }
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    try {
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          if (stream.sourceReadableLength() > maxBufferSize) {
            this._source.push({
              id: message2.id,
              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
            });
            throw new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers", "ERR_STREAM_INPUT_BUFFER_FULL");
          }
          stream.sourcePush(message2.data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.remoteCloseWrite();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          this.log("unknown message type %s", type);
      }
    } catch (err) {
      this.log.error("error while processing message", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  protocol = "/mplex/6.7.0";
  _init;
  components;
  constructor(components, init = {}) {
    this.components = components;
    this._init = init;
  }
  [Symbol.toStringTag] = "@libp2p/mplex";
  [serviceCapabilities] = [
    "@libp2p/stream-multiplexing"
  ];
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return (components) => new Mplex(components, init);
}

// node_modules/@libp2p/ping/node_modules/it-first/dist/src/index.js
function isAsyncIterable28(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function first3(source) {
  if (isAsyncIterable28(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
var src_default35 = first3;

// node_modules/@libp2p/ping/node_modules/it-pipe/dist/src/index.js
function pipe7(first4, ...rest) {
  if (first4 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex6(first4)) {
    const duplex = first4;
    first4 = () => duplex.source;
  } else if (isIterable6(first4) || isAsyncIterable29(first4)) {
    const source = first4;
    first4 = () => source;
  }
  const fns = [first4, ...rest];
  if (fns.length > 1) {
    if (isDuplex6(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex6(fns[i])) {
        fns[i] = duplexPipelineFn6(fns[i]);
      }
    }
  }
  return rawPipe6(...fns);
}
var rawPipe6 = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable29 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable6 = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex6 = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn6 = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable29(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable6(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default4(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@libp2p/ping/node_modules/uint8arrays/dist/src/equals.js
function equals55(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/ping/dist/src/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";
var PROTOCOL_PREFIX2 = "ipfs";
var TIMEOUT2 = 1e4;
var MAX_INBOUND_STREAMS2 = 2;
var MAX_OUTBOUND_STREAMS2 = 1;
var ERR_WRONG_PING_ACK = "ERR_WRONG_PING_ACK";

// node_modules/@libp2p/ping/dist/src/ping.js
var PingService = class {
  protocol;
  components;
  started;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  runOnTransientConnection;
  log;
  constructor(components, init = {}) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:ping");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.timeout = init.timeout ?? TIMEOUT2;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS2;
    this.runOnTransientConnection = init.runOnTransientConnection ?? true;
    this.handleMessage = this.handleMessage.bind(this);
  }
  [Symbol.toStringTag] = "@libp2p/ping";
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    this.log("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start2 = Date.now();
    const signal = AbortSignal.timeout(this.timeout);
    signal.addEventListener("abort", () => {
      stream?.abort(new CodeError("ping timeout", ERR_TIMEOUT));
    });
    void pipe7(stream, async function* (source) {
      let received = 0;
      for await (const buf3 of source) {
        received += buf3.byteLength;
        if (received > PING_LENGTH) {
          stream?.abort(new CodeError("Too much data received", ERR_INVALID_MESSAGE));
          return;
        }
        yield buf3;
      }
    }, stream).catch((err) => {
      this.log.error("incoming ping from %p failed with error", data.connection.remotePeer, err);
      stream?.abort(err);
    }).finally(() => {
      const ms2 = Date.now() - start2;
      this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms2);
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options2 = {}) {
    this.log("pinging %p", peer);
    const start2 = Date.now();
    const data = randomBytes2(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options2);
    let stream;
    let onAbort = () => {
    };
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnTransientConnection: this.runOnTransientConnection
      });
      onAbort = () => {
        stream?.abort(new CodeError("ping timeout", ERR_TIMEOUT));
      };
      options2.signal?.addEventListener("abort", onAbort, { once: true });
      const result = await pipe7([data], stream, async (source) => src_default35(source));
      const ms2 = Date.now() - start2;
      if (result == null) {
        throw new CodeError(`Did not receive a ping ack after ${ms2}ms`, ERR_WRONG_PING_ACK);
      }
      if (!equals55(data, result.subarray())) {
        throw new CodeError(`Received wrong ping ack after ${ms2}ms`, ERR_WRONG_PING_ACK);
      }
      this.log("ping %p complete in %dms", connection.remotePeer, ms2);
      return ms2;
    } catch (err) {
      this.log.error("error while pinging %p", connection.remotePeer, err);
      stream?.abort(err);
      throw err;
    } finally {
      options2.signal?.removeEventListener("abort", onAbort);
      if (stream != null) {
        await stream.close();
      }
    }
  }
};

// node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new PingService(components, init);
}

// node_modules/@libp2p/webrtc/dist/src/error.js
var codes4;
(function(codes7) {
  codes7["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes7["ERR_DATA_CHANNEL"] = "ERR_DATA_CHANNEL";
  codes7["ERR_CONNECTION_CLOSED"] = "ERR_CONNECTION_CLOSED";
  codes7["ERR_HASH_NOT_SUPPORTED"] = "ERR_HASH_NOT_SUPPORTED";
  codes7["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes7["ERR_INVALID_FINGERPRINT"] = "ERR_INVALID_FINGERPRINT";
  codes7["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes7["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes7["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes7["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
})(codes4 || (codes4 = {}));
var WebRTCTransportError = class extends CodeError {
  constructor(msg, code33) {
    super(`WebRTC transport error: ${msg}`, code33 ?? "");
    this.name = "WebRTCTransportError";
  }
};
var DataChannelError = class extends WebRTCTransportError {
  constructor(streamLabel, msg) {
    super(`[stream: ${streamLabel}] data channel error: ${msg}`, codes4.ERR_DATA_CHANNEL);
    this.name = "WebRTC/DataChannelError";
  }
};
function dataChannelError(streamLabel, msg) {
  return new DataChannelError(streamLabel, msg);
}
var InappropriateMultiaddrError = class extends WebRTCTransportError {
  constructor(msg) {
    super(`There was a problem with the Multiaddr which was passed in: ${msg}`, codes4.ERR_INVALID_MULTIADDR);
    this.name = "WebRTC/InappropriateMultiaddrError";
  }
};
function inappropriateMultiaddr(msg) {
  return new InappropriateMultiaddrError(msg);
}
var InvalidArgumentError = class extends WebRTCTransportError {
  constructor(msg) {
    super(`There was a problem with a provided argument: ${msg}`, codes4.ERR_INVALID_PARAMETERS);
    this.name = "WebRTC/InvalidArgumentError";
  }
};
function invalidArgument(msg) {
  return new InvalidArgumentError(msg);
}
var InvalidFingerprintError = class extends WebRTCTransportError {
  constructor(fingerprint, source) {
    super(`Invalid fingerprint "${fingerprint}" within ${source}`, codes4.ERR_INVALID_FINGERPRINT);
    this.name = "WebRTC/InvalidFingerprintError";
  }
};
function invalidFingerprint(fingerprint, source) {
  return new InvalidFingerprintError(fingerprint, source);
}
var UnimplementedError = class extends WebRTCTransportError {
  constructor(methodName) {
    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`, codes4.ERR_NOT_IMPLEMENTED);
    this.name = "WebRTC/UnimplementedError";
  }
};
function unimplemented(methodName) {
  return new UnimplementedError(methodName);
}
var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
  constructor(algo) {
    super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `, codes4.ERR_HASH_NOT_SUPPORTED);
    this.name = "WebRTC/UnsupportedHashAlgorithmError";
  }
};
function unsupportedHashAlgorithmCode(code33) {
  return new UnsupportedHashAlgorithmError(code33);
}

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from58, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from58.length, ar; i < l; i++) {
    if (ar || !(i in from58)) {
      if (!ar) ar = Array.prototype.slice.call(from58, 0, i);
      ar[i] = from58[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from58));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name29, version3, os) {
      this.name = name29;
      this.version = version3;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version3) {
      this.version = version3;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name29, version3, os, bot) {
      this.name = name29;
      this.version = version3;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name29 = matchedRule[0], match = matchedRule[1];
  if (name29 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name29, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name29, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output3 = [];
  for (var ii = 0; ii < count; ii++) {
    output3.push("0");
  }
  return output3;
}

// node_modules/@libp2p/webrtc/node_modules/p-defer/index.js
function pDefer10() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@libp2p/webrtc/dist/src/constants.js
var DEFAULT_ICE_SERVERS = [
  "stun:stun.l.google.com:19302",
  "stun:global.stun.twilio.com:3478",
  "stun:stun.cloudflare.com:3478",
  "stun:stun.services.mozilla.com:3478"
];

// node_modules/@libp2p/webrtc/dist/src/util.js
var browser = detect();
var isFirefox = browser != null && browser.name === "firefox";
var nopSource = async function* nop() {
};
var nopSink = async (_) => {
};
var DATA_CHANNEL_DRAIN_TIMEOUT = 30 * 1e3;
function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options2) {
  if (channel.readyState !== "open") {
    return;
  }
  void Promise.resolve().then(async () => {
    if (channel.bufferedAmount > 0) {
      options2.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
      const deferred = pDefer10();
      let drained = false;
      channel.bufferedAmountLowThreshold = 0;
      const closeListener = () => {
        if (!drained) {
          options2.log("%s drain channel closed before drain", direction);
          deferred.resolve();
        }
      };
      channel.addEventListener("close", closeListener, {
        once: true
      });
      channel.addEventListener("bufferedamountlow", () => {
        drained = true;
        channel.removeEventListener("close", closeListener);
        deferred.resolve();
      });
      await pTimeout(deferred.promise, {
        milliseconds: drainTimeout
      });
    }
  }).then(async () => {
    if (channel.readyState === "open") {
      channel.close();
    }
  }).catch((err) => {
    options2.log.error("error closing outbound stream", err);
  });
}
async function getRtcConfiguration(config) {
  config = config ?? {};
  if (typeof config === "function") {
    config = await config();
  }
  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
    urls: [
      url
    ]
  }));
  return config;
}

// node_modules/@libp2p/webrtc/dist/src/maconn.js
var WebRTCMultiaddrConnection = class {
  log;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  /**
   * The multiaddr address used to communicate with the remote peer
   */
  remoteAddr;
  /**
   * Holds the lifecycle times of the connection
   */
  timeline;
  /**
   * Optional metrics counter group for this connection
   */
  metrics;
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:webrtc:maconn");
    this.remoteAddr = init.remoteAddr;
    this.timeline = init.timeline;
    this.peerConnection = init.peerConnection;
    const initialState = this.peerConnection.connectionState;
    this.peerConnection.onconnectionstatechange = () => {
      this.log.trace("peer connection state change", this.peerConnection.connectionState, "initial state", initialState);
      if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") {
        this.timeline.close = Date.now();
      }
    };
  }
  async close(options2) {
    this.log.trace("closing connection");
    this.peerConnection.close();
    this.timeline.close = Date.now();
    this.metrics?.increment({ close: true });
  }
  abort(err) {
    this.log.error("closing connection due to error", err);
    this.peerConnection.close();
    this.timeline.close = Date.now();
    this.metrics?.increment({ abort: true });
  }
};

// node_modules/@libp2p/webrtc/dist/src/pb/message.js
var Message3;
(function(Message5) {
  let Flag2;
  (function(Flag3) {
    Flag3["FIN"] = "FIN";
    Flag3["STOP_SENDING"] = "STOP_SENDING";
    Flag3["RESET"] = "RESET";
    Flag3["FIN_ACK"] = "FIN_ACK";
  })(Flag2 = Message5.Flag || (Message5.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
    __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag3) {
    Flag3.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Flag2 = Message5.Flag || (Message5.Flag = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.flag != null) {
          w2.uint32(8);
          Message5.Flag.codec().encode(obj.flag, w2);
        }
        if (obj.message != null) {
          w2.uint32(18);
          w2.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.flag = Message5.Flag.codec().decode(reader);
              break;
            case 2:
              obj.message = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf3) => {
    return decodeMessage(buf3, Message5.codec());
  };
})(Message3 || (Message3 = {}));

// node_modules/@libp2p/webrtc/dist/src/stream.js
var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
var BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1e3;
var PROTOBUF_OVERHEAD = 7;
var VARINT_LENGTH = 2;
var MAX_MESSAGE_SIZE = 256 * 1024;
var FIN_ACK_TIMEOUT = 5e3;
var OPEN_TIMEOUT = 5e3;
var WebRTCStream = class extends AbstractStream {
  /**
   * The data channel used to send and receive data
   */
  channel;
  /**
   * push data from the underlying datachannel to the length prefix decoder
   * and then the protobuf decoder.
   */
  incomingData;
  maxBufferedAmount;
  bufferedAmountLowEventTimeout;
  /**
   * The maximum size of a message in bytes
   */
  maxMessageSize;
  /**
   * When this promise is resolved, the remote has sent us a FIN flag
   */
  receiveFinAck;
  finAckTimeout;
  openTimeout;
  constructor(init) {
    const originalOnEnd = init.onEnd;
    init.onEnd = (err) => {
      this.log.trace("readable and writeable ends closed", this.status);
      void Promise.resolve(async () => {
        if (this.timeline.abort != null || this.timeline.reset !== null) {
          return;
        }
        try {
          await pTimeout(this.receiveFinAck.promise, {
            milliseconds: this.finAckTimeout
          });
        } catch (err2) {
          this.log.error("error receiving FIN_ACK", err2);
        }
      }).then(() => {
        this.incomingData.end();
        originalOnEnd?.(err);
      }).catch((err2) => {
        this.log.error("error ending stream", err2);
      });
    };
    super(init);
    this.channel = init.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
    this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
    this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD - VARINT_LENGTH;
    this.receiveFinAck = pDefer10();
    this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
    this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT;
    switch (this.channel.readyState) {
      case "open":
        this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
        break;
      case "closed":
      case "closing":
        if (this.timeline.close === void 0 || this.timeline.close === 0) {
          this.timeline.close = Date.now();
        }
        break;
      case "connecting":
        break;
      default:
        this.log.error("unknown datachannel state %s", this.channel.readyState);
        throw new CodeError("Unknown datachannel state", "ERR_INVALID_STATE");
    }
    this.channel.onopen = (_evt) => {
      this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
    };
    this.channel.onclose = (_evt) => {
      this.receiveFinAck.resolve();
      void this.close().catch((err) => {
        this.log.error("error closing stream after channel closed", err);
      });
    };
    this.channel.onerror = (evt) => {
      const err = evt.error;
      this.abort(err);
    };
    this.channel.onmessage = async (event) => {
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    const self2 = this;
    Promise.resolve().then(async () => {
      for await (const buf3 of decode2(this.incomingData)) {
        const message2 = self2.processIncomingProtobuf(buf3);
        if (message2 != null) {
          self2.sourcePush(new Uint8ArrayList(message2));
        }
      }
    }).catch((err) => {
      this.log.error("error processing incoming data channel messages", err);
    });
  }
  sendNewStream() {
  }
  async _sendMessage(data, checkBuffer = true) {
    if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {
      try {
        this.log('channel buffer is %d, wait for "bufferedamountlow" event', this.channel.bufferedAmount);
        await pEvent(this.channel, "bufferedamountlow", { timeout: this.bufferedAmountLowEventTimeout });
      } catch (err) {
        if (err instanceof TimeoutError) {
          throw new CodeError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`, "ERR_BUFFER_CLEAR_TIMEOUT");
        }
        throw err;
      }
    }
    if (this.channel.readyState === "closed" || this.channel.readyState === "closing") {
      throw new CodeError(`Invalid datachannel state - ${this.channel.readyState}`, "ERR_INVALID_STATE");
    }
    if (this.channel.readyState !== "open") {
      this.log('channel state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
      await pEvent(this.channel, "open", { timeout: this.openTimeout });
      this.log('channel state is now "%s", sending data', this.channel.readyState);
    }
    this.channel.send(data.subarray());
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxMessageSize);
      const buf3 = data.subarray(0, toSend);
      const msgbuf = Message3.encode({ message: buf3 });
      const sendbuf = encode2.single(msgbuf);
      await this._sendMessage(sendbuf);
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this._sendFlag(Message3.Flag.RESET);
  }
  async sendCloseWrite(options2) {
    const sent = await this._sendFlag(Message3.Flag.FIN);
    if (sent) {
      this.log.trace("awaiting FIN_ACK");
      try {
        await raceSignal(this.receiveFinAck.promise, options2?.signal, {
          errorMessage: "sending close-write was aborted before FIN_ACK was received",
          errorCode: "ERR_FIN_ACK_NOT_RECEIVED"
        });
      } catch (err) {
        this.log.error("failed to await FIN_ACK", err);
      }
    } else {
      this.log.trace("sending FIN failed, not awaiting FIN_ACK");
    }
    this.receiveFinAck.resolve();
  }
  async sendCloseRead() {
    await this._sendFlag(Message3.Flag.STOP_SENDING);
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer3) {
    const message2 = Message3.decode(buffer3);
    if (message2.flag !== void 0) {
      this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
      if (message2.flag === Message3.Flag.FIN) {
        this.remoteCloseWrite();
        this.log.trace("sending FIN_ACK");
        void this._sendFlag(Message3.Flag.FIN_ACK).catch((err) => {
          this.log.error("error sending FIN_ACK immediately", err);
        });
      }
      if (message2.flag === Message3.Flag.RESET) {
        this.reset();
      }
      if (message2.flag === Message3.Flag.STOP_SENDING) {
        this.remoteCloseRead();
      }
      if (message2.flag === Message3.Flag.FIN_ACK) {
        this.log.trace("received FIN_ACK");
        this.receiveFinAck.resolve();
      }
    }
    if (this.readStatus === "ready") {
      return message2.message;
    }
  }
  async _sendFlag(flag) {
    if (this.channel.readyState !== "open") {
      this.log.trace('not sending flag %s because channel is "%s" and not "open"', this.channel.readyState, flag.toString());
      return false;
    }
    this.log.trace("sending flag %s", flag.toString());
    const msgbuf = Message3.encode({ flag });
    const prefixedBuf = encode2.single(msgbuf);
    try {
      await this._sendMessage(prefixedBuf, false);
      return true;
    } catch (err) {
      this.log.error("could not send flag %s", flag.toString(), err);
    }
    return false;
  }
};
function createStream2(options2) {
  const { channel, direction } = options2;
  return new WebRTCStream({
    id: direction === "inbound" ? `i${channel.id}` : `r${channel.id}`,
    log: options2.logger.forComponent(`libp2p:webrtc:stream:${direction}:${channel.id}`),
    ...options2
  });
}

// node_modules/@libp2p/webrtc/dist/src/muxer.js
var PROTOCOL2 = "/webrtc";
var DataChannelMuxerFactory = class {
  protocol;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  bufferedStreams = [];
  metrics;
  dataChannelOptions;
  components;
  log;
  constructor(components, init) {
    this.components = components;
    this.peerConnection = init.peerConnection;
    this.metrics = init.metrics;
    this.protocol = init.protocol ?? PROTOCOL2;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.log = components.logger.forComponent("libp2p:webrtc:datachannelmuxerfactory");
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
      if (channel.label === "init") {
        this.log.trace("closing early init channel");
        channel.close();
        return;
      }
      const bufferedStream = {};
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: (err) => {
          bufferedStream.onEnd(err);
        },
        logger: components.logger,
        ...this.dataChannelOptions
      });
      bufferedStream.stream = stream;
      bufferedStream.channel = channel;
      bufferedStream.onEnd = () => {
        this.bufferedStreams = this.bufferedStreams.filter((s2) => s2.stream.id !== stream.id);
      };
      this.bufferedStreams.push(bufferedStream);
    };
  }
  createStreamMuxer(init) {
    return new DataChannelMuxer(this.components, {
      ...init,
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      streams: this.bufferedStreams,
      protocol: this.protocol
    });
  }
};
var DataChannelMuxer = class {
  init;
  /**
   * Array of streams in the data channel
   */
  streams;
  protocol;
  log;
  peerConnection;
  dataChannelOptions;
  metrics;
  logger;
  constructor(components, init) {
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc:muxer");
    this.logger = components.logger;
    this.streams = init.streams.map((s2) => s2.stream);
    this.peerConnection = init.peerConnection;
    this.protocol = init.protocol ?? PROTOCOL2;
    this.metrics = init.metrics;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.log.trace("incoming datachannel with channel id %d", channel.id);
      if (channel.label === "init") {
        this.log.trace("closing init channel");
        channel.close();
        return;
      }
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: () => {
          this.log("incoming channel %s ended with state %s", channel.id, channel.readyState);
          this.#onStreamEnd(stream, channel);
        },
        logger: this.logger,
        ...this.dataChannelOptions
      });
      this.streams.push(stream);
      this.metrics?.increment({ incoming_stream: true });
      init?.onIncomingStream?.(stream);
    };
    if (this.init.streams.length > 0) {
      queueMicrotask(() => {
        this.init.streams.forEach((bufferedStream) => {
          bufferedStream.onEnd = () => {
            this.log("incoming early channel %s ended with state %s", bufferedStream.channel.id, bufferedStream.channel.readyState);
            this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel);
          };
          this.metrics?.increment({ incoming_stream: true });
          this.init?.onIncomingStream?.(bufferedStream.stream);
        });
      });
    }
  }
  #onStreamEnd(stream, channel) {
    this.log.trace("stream %s %s %s onEnd", stream.direction, stream.id, stream.protocol);
    drainAndClose(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
      log: this.log
    });
    this.streams = this.streams.filter((s2) => s2.id !== stream.id);
    this.metrics?.increment({ stream_end: true });
    this.init?.onStreamEnd?.(stream);
  }
  /**
   * Gracefully close all tracked streams and stop the muxer
   */
  async close(options2) {
    try {
      await Promise.all(this.streams.map(async (stream) => stream.close(options2)));
    } catch (err) {
      this.abort(err);
    }
  }
  /**
   * Abort all tracked streams and stop the muxer
   */
  abort(err) {
    for (const stream of this.streams) {
      stream.abort(err);
    }
  }
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  newStream() {
    const channel = this.peerConnection.createDataChannel("");
    this.log.trace("opened outgoing datachannel with channel id %s", channel.id);
    const stream = createStream2({
      channel,
      direction: "outbound",
      onEnd: () => {
        this.log("outgoing channel %s ended with state %s", channel.id, channel.readyState);
        this.#onStreamEnd(stream, channel);
      },
      logger: this.logger,
      ...this.dataChannelOptions
    });
    this.streams.push(stream);
    this.metrics?.increment({ outgoing_stream: true });
    return stream;
  }
};

// node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
var RTCPeerConnection = globalThis.RTCPeerConnection;
var RTCSessionDescription = globalThis.RTCSessionDescription;
var RTCIceCandidate = globalThis.RTCIceCandidate;

// node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
var Message4;
(function(Message5) {
  let Type3;
  (function(Type4) {
    Type4["SDP_OFFER"] = "SDP_OFFER";
    Type4["SDP_ANSWER"] = "SDP_ANSWER";
    Type4["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Type3 = Message5.Type || (Message5.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type4) {
    Type4.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type3 = Message5.Type || (Message5.Type = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.type != null) {
          w2.uint32(8);
          Message5.Type.codec().encode(obj.type, w2);
        }
        if (obj.data != null) {
          w2.uint32(18);
          w2.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {};
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message5.Type.codec().decode(reader);
              break;
            case 2:
              obj.data = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf3) => {
    return decodeMessage(buf3, Message5.codec());
  };
})(Message4 || (Message4 = {}));

// node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
var readCandidatesUntilConnected = async (pc, stream, options2) => {
  try {
    const connectedPromise = pDefer10();
    resolveOnConnected(pc, connectedPromise);
    while (true) {
      const message2 = await Promise.race([
        connectedPromise.promise,
        stream.read({
          signal: options2.signal
        }).catch(() => {
        })
      ]);
      if (message2 == null) {
        options2.signal?.throwIfAborted();
        break;
      }
      if (message2.type !== Message4.Type.ICE_CANDIDATE) {
        throw new CodeError("ICE candidate message expected", "ERR_NOT_ICE_CANDIDATE");
      }
      const candidateInit = JSON.parse(message2.data ?? "null");
      if (candidateInit === "" || candidateInit === null) {
        options2.onProgress?.(new CustomProgressEvent("webrtc:end-of-ice-candidates"));
        options2.log.trace("end-of-candidates received");
        continue;
      }
      const candidate = new RTCIceCandidate(candidateInit);
      options2.log.trace("%s received new ICE candidate %o", options2.direction, candidateInit);
      try {
        options2.onProgress?.(new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
        await pc.addIceCandidate(candidate);
      } catch (err) {
        options2.log.error("%s bad candidate received", options2.direction, candidateInit, err);
      }
    }
  } catch (err) {
    options2.log.error("%s error parsing ICE candidate", options2.direction, err);
    if (options2.signal?.aborted === true) {
      throw err;
    }
  }
};
function getConnectionState(pc) {
  return isFirefox ? pc.iceConnectionState : pc.connectionState;
}
function resolveOnConnected(pc, promise) {
  pc[isFirefox ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_) => {
    switch (getConnectionState(pc)) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new CodeError("RTCPeerConnection was closed", "ERR_CONNECTION_CLOSED_BEFORE_CONNECTED"));
        break;
      default:
        break;
    }
  };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log10, logger: logger2, onProgress }) {
  const { baseAddr } = splitAddr(ma);
  metrics?.dialerEvents.increment({ open: true });
  log10.trace("dialing base address: %a", baseAddr);
  const relayPeer = baseAddr.getPeerId();
  if (relayPeer == null) {
    throw new CodeError("Relay peer was missing", "ERR_INVALID_ADDRESS");
  }
  const connections = connectionManager.getConnections(peerIdFromString(relayPeer));
  let connection;
  let shouldCloseConnection = false;
  if (connections.length === 0) {
    onProgress?.(new CustomProgressEvent("webrtc:dial-relay"));
    connection = await transportManager.dial(baseAddr, {
      signal,
      onProgress
    });
    shouldCloseConnection = true;
  } else {
    onProgress?.(new CustomProgressEvent("webrtc:reuse-relay-connection"));
    connection = connections[0];
  }
  try {
    onProgress?.(new CustomProgressEvent("webrtc:open-signaling-stream"));
    const stream = await connection.newStream(SIGNALING_PROTO_ID, {
      signal,
      runOnTransientConnection: true
    });
    const messageStream = pbStream(stream).pb(Message4);
    const peerConnection = new RTCPeerConnection(rtcConfiguration);
    const muxerFactory = new DataChannelMuxerFactory({
      logger: logger2
    }, {
      peerConnection,
      dataChannelOptions: dataChannel
    });
    try {
      const channel = peerConnection.createDataChannel("init");
      peerConnection.onicecandidate = ({ candidate }) => {
        const data = JSON.stringify(candidate?.toJSON() ?? null);
        log10.trace("initiator sending ICE candidate %o", candidate);
        void messageStream.write({
          type: Message4.Type.ICE_CANDIDATE,
          data
        }, {
          signal
        }).catch((err) => {
          log10.error("error sending ICE candidate", err);
        });
      };
      peerConnection.onicecandidateerror = (event) => {
        log10.error("initiator ICE candidate error", event);
      };
      const offerSdp = await peerConnection.createOffer().catch((err) => {
        log10.error("could not execute createOffer", err);
        throw new CodeError("Failed to set createOffer", "ERR_SDP_HANDSHAKE_FAILED");
      });
      log10.trace("initiator send SDP offer %s", offerSdp.sdp);
      onProgress?.(new CustomProgressEvent("webrtc:send-sdp-offer"));
      await messageStream.write({ type: Message4.Type.SDP_OFFER, data: offerSdp.sdp }, {
        signal
      });
      await peerConnection.setLocalDescription(offerSdp).catch((err) => {
        log10.error("could not execute setLocalDescription", err);
        throw new CodeError("Failed to set localDescription", "ERR_SDP_HANDSHAKE_FAILED");
      });
      onProgress?.(new CustomProgressEvent("webrtc:read-sdp-answer"));
      const answerMessage = await messageStream.read({
        signal
      });
      if (answerMessage.type !== Message4.Type.SDP_ANSWER) {
        throw new CodeError("Remote should send an SDP answer", "ERR_SDP_HANDSHAKE_FAILED");
      }
      log10.trace("initiator receive SDP answer %s", answerMessage.data);
      const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
      await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
        log10.error("could not execute setRemoteDescription", err);
        throw new CodeError("Failed to set remoteDescription", "ERR_SDP_HANDSHAKE_FAILED");
      });
      log10.trace("initiator read candidates until connected");
      onProgress?.(new CustomProgressEvent("webrtc:read-ice-candidates"));
      await readCandidatesUntilConnected(peerConnection, messageStream, {
        direction: "initiator",
        signal,
        log: log10,
        onProgress
      });
      log10.trace("initiator connected, closing init channel");
      channel.close();
      onProgress?.(new CustomProgressEvent("webrtc:close-signaling-stream"));
      log10.trace("closing signaling channel");
      await stream.close({
        signal
      });
      log10.trace("initiator connected to remote address %s", ma);
      return {
        remoteAddress: ma,
        peerConnection,
        muxerFactory
      };
    } catch (err) {
      log10.error("outgoing signaling error", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    } finally {
      peerConnection.onicecandidate = null;
      peerConnection.onicecandidateerror = null;
    }
  } finally {
    if (shouldCloseConnection) {
      try {
        await connection.close({
          signal
        });
      } catch (err) {
        connection.abort(err);
      }
    }
  }
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
var WebRTCPeerListener = class extends TypedEventEmitter {
  peerId;
  transportManager;
  shutdownController;
  constructor(components, init) {
    super();
    this.peerId = components.peerId;
    this.transportManager = components.transportManager;
    this.shutdownController = init.shutdownController;
  }
  async listen() {
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l) => l !== this).map((l) => l.getAddrs().filter((ma) => Circuit2.matches(ma)).map((ma) => {
      return ma.encapsulate(`/webrtc/p2p/${this.peerId}`);
    })).flat();
  }
  async close() {
    this.shutdownController.abort();
    this.safeDispatchEvent("close", {});
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
async function handleIncomingStream({ peerConnection, stream, signal, connection, log: log10 }) {
  log10.trace("new inbound signaling stream");
  const messageStream = pbStream(stream).pb(Message4);
  try {
    peerConnection.onicecandidate = ({ candidate }) => {
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log10.trace("recipient sending ICE candidate %s", data);
      messageStream.write({
        type: Message4.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log10.error("error sending ICE candidate", err);
      });
    };
    const pbOffer = await messageStream.read({
      signal
    });
    if (pbOffer.type !== Message4.Type.SDP_OFFER) {
      throw new CodeError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `, "ERR_SDP_HANDSHAKE_FAILED");
    }
    log10.trace("recipient receive SDP offer %s", pbOffer.data);
    const offer = new RTCSessionDescription({
      type: "offer",
      sdp: pbOffer.data
    });
    await peerConnection.setRemoteDescription(offer).catch((err) => {
      log10.error("could not execute setRemoteDescription", err);
      throw new CodeError("Failed to set remoteDescription", "ERR_SDP_HANDSHAKE_FAILED");
    });
    const answer = await peerConnection.createAnswer().catch((err) => {
      log10.error("could not execute createAnswer", err);
      throw new CodeError("Failed to create answer", "ERR_SDP_HANDSHAKE_FAILED");
    });
    log10.trace("recipient send SDP answer %s", answer.sdp);
    await messageStream.write({ type: Message4.Type.SDP_ANSWER, data: answer.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(answer).catch((err) => {
      log10.error("could not execute setLocalDescription", err);
      throw new CodeError("Failed to set localDescription", "ERR_SDP_HANDSHAKE_FAILED");
    });
    log10.trace("recipient read candidates until connected");
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "recipient",
      signal,
      log: log10
    });
  } catch (err) {
    if (peerConnection.connectionState !== "connected") {
      log10.error("error while handling signaling stream from peer %a", connection.remoteAddr, err);
      peerConnection.close();
      throw err;
    } else {
      log10("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
  }
  const remoteAddress = multiaddr(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`);
  log10.trace("recipient connected to remote address %s", remoteAddress);
  return { remoteAddress };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
var WEBRTC_TRANSPORT = "/webrtc";
var CIRCUIT_RELAY_TRANSPORT = "/p2p-circuit";
var SIGNALING_PROTO_ID = "/webrtc-signaling/0.0.1";
var INBOUND_CONNECTION_TIMEOUT = 30 * 1e3;
var WebRTCTransport = class {
  components;
  init;
  log;
  _started = false;
  metrics;
  shutdownController;
  constructor(components, init = {}) {
    this.components = components;
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc");
    this.shutdownController = new AbortController();
    setMaxListeners2(Infinity, this.shutdownController.signal);
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dialer events by type"
        }),
        listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
          label: "event",
          help: "Total count of WebRTC listener events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/webrtc";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  [serviceDependencies] = [
    "@libp2p/identify",
    "@libp2p/circuit-relay-v2-transport"
  ];
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTO_ID, (data) => {
      this._onProtocol(data).catch((err) => {
        this.log.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
      });
    }, {
      runOnTransientConnection: true
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTO_ID);
    this._started = false;
  }
  createListener(options2) {
    return new WebRTCPeerListener(this.components, {
      shutdownController: this.shutdownController
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTC.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options2) {
    this.log.trace("dialing address: %a", ma);
    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
      dataChannel: this.init.dataChannel,
      multiaddr: ma,
      dataChannelOptions: this.init.dataChannel,
      signal: options2.signal,
      connectionManager: this.components.connectionManager,
      transportManager: this.components.transportManager,
      log: this.log,
      logger: this.components.logger,
      onProgress: options2.onProgress
    });
    const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
      peerConnection,
      timeline: { open: Date.now() },
      remoteAddr: remoteAddress,
      metrics: this.metrics?.dialerEvents
    });
    const connection = await options2.upgrader.upgradeOutbound(webRTCConn, {
      skipProtection: true,
      skipEncryption: true,
      muxerFactory,
      onProgress: options2.onProgress
    });
    this._closeOnShutdown(peerConnection, webRTCConn);
    return connection;
  }
  async _onProtocol({ connection, stream }) {
    const signal = AbortSignal.timeout(this.init.inboundConnectionTimeout ?? INBOUND_CONNECTION_TIMEOUT);
    const peerConnection = new RTCPeerConnection(await getRtcConfiguration(this.init.rtcConfiguration));
    const muxerFactory = new DataChannelMuxerFactory(this.components, {
      peerConnection,
      dataChannelOptions: this.init.dataChannel
    });
    try {
      const { remoteAddress } = await handleIncomingStream({
        peerConnection,
        connection,
        stream,
        signal,
        log: this.log
      });
      await stream.close({
        signal
      });
      const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        timeline: { open: (/* @__PURE__ */ new Date()).getTime() },
        remoteAddr: remoteAddress,
        metrics: this.metrics?.listenerEvents
      });
      await this.components.upgrader.upgradeInbound(webRTCConn, {
        skipEncryption: true,
        skipProtection: true,
        muxerFactory
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
    } catch (err) {
      this.log.error("incoming signaling error", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    }
  }
  _closeOnShutdown(pc, webRTCConn) {
    const shutDownListener = () => {
      webRTCConn.close().catch((err) => {
        this.log.error("could not close WebRTCMultiaddrConnection", err);
      });
    };
    this.shutdownController.signal.addEventListener("abort", shutDownListener);
    pc.addEventListener("close", () => {
      this.shutdownController.signal.removeEventListener("abort", shutDownListener);
    });
  }
};
function splitAddr(ma) {
  const addrs = ma.toString().split(WEBRTC_TRANSPORT + "/");
  if (addrs.length !== 2) {
    throw new CodeError("webrtc protocol was not present in multiaddr", codes4.ERR_INVALID_MULTIADDR);
  }
  if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {
    throw new CodeError("p2p-circuit protocol was not present in multiaddr", codes4.ERR_INVALID_MULTIADDR);
  }
  let remoteAddr = multiaddr(addrs[0]);
  const destination = multiaddr("/" + addrs[1]);
  const destinationIdString = destination.getPeerId();
  if (destinationIdString == null) {
    throw new CodeError("destination peer id was missing", codes4.ERR_INVALID_MULTIADDR);
  }
  const lastProtoInRemote = remoteAddr.protos().pop();
  if (lastProtoInRemote === void 0) {
    throw new CodeError("invalid multiaddr", codes4.ERR_INVALID_MULTIADDR);
  }
  if (lastProtoInRemote.name !== "p2p") {
    remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
  }
  return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/digest.js
var digest_exports21 = {};
__export(digest_exports21, {
  Digest: () => Digest21,
  create: () => create23,
  decode: () => decode110,
  equals: () => equals57
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bytes.js
var empty24 = new Uint8Array(0);
function equals56(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce24(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString38(str) {
  return new TextEncoder().encode(str);
}
function toString38(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/vendor/varint.js
var encode_121 = encode86;
var MSB23 = 128;
var REST23 = 127;
var MSBALL21 = ~REST23;
var INT21 = Math.pow(2, 31);
function encode86(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT21) {
    out[offset++] = num & 255 | MSB23;
    num /= 128;
  }
  while (num & MSBALL21) {
    out[offset++] = num & 255 | MSB23;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode86.bytes = offset - oldOffset + 1;
  return out;
}
var decode108 = read22;
var MSB$121 = 128;
var REST$121 = 127;
function read22(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read22.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$121) << shift : (b & REST$121) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$121);
  read22.bytes = counter - offset;
  return res;
}
var N122 = Math.pow(2, 7);
var N222 = Math.pow(2, 14);
var N322 = Math.pow(2, 21);
var N422 = Math.pow(2, 28);
var N522 = Math.pow(2, 35);
var N622 = Math.pow(2, 42);
var N722 = Math.pow(2, 49);
var N821 = Math.pow(2, 56);
var N921 = Math.pow(2, 63);
var length23 = function(value) {
  return value < N122 ? 1 : value < N222 ? 2 : value < N322 ? 3 : value < N422 ? 4 : value < N522 ? 5 : value < N622 ? 6 : value < N722 ? 7 : value < N821 ? 8 : value < N921 ? 9 : 10;
};
var varint21 = {
  encode: encode_121,
  decode: decode108,
  encodingLength: length23
};
var _brrp_varint21 = varint21;
var varint_default21 = _brrp_varint21;

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/varint.js
function decode109(data, offset = 0) {
  const code33 = varint_default21.decode(data, offset);
  return [code33, varint_default21.decode.bytes];
}
function encodeTo21(int, target, offset = 0) {
  varint_default21.encode(int, target, offset);
  return target;
}
function encodingLength22(int) {
  return varint_default21.encodingLength(int);
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/digest.js
function create23(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength22(code33);
  const digestOffset = sizeOffset + encodingLength22(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo21(code33, bytes3, 0);
  encodeTo21(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest21(code33, size, digest27, bytes3);
}
function decode110(multihash) {
  const bytes3 = coerce24(multihash);
  const [code33, sizeOffset] = decode109(bytes3);
  const [size, digestOffset] = decode109(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest21(code33, size, digest27, bytes3);
}
function equals57(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals56(a.bytes, data.bytes);
  }
}
var Digest21 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe22(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array8(buf3) {
  return buf3;
}

// node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/concat.js
function concat11(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe22(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array8(output3);
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports19 = {};
__export(base10_exports19, {
  base10: () => base1019
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/vendor/base-x.js
function base38(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src23 = base38;
var _brrp__multiformats_scope_baseX23 = src23;
var base_x_default24 = _brrp__multiformats_scope_baseX23;

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base.js
var Encoder25 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder26 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or26(this, decoder);
  }
};
var ComposedDecoder24 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or26(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or26(left, right) {
  return new ComposedDecoder24({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec24 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder25(name29, prefix, baseEncode);
    this.decoder = new Decoder26(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from43({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec24(name29, prefix, encode116, decode144);
}
function baseX23({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default24(alphabet27, name29);
  return from43({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce24(decode144(text))
  });
}
function decode111(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode87(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464824({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from43({
    prefix,
    name: name29,
    encode(input) {
      return encode87(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode111(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base10.js
var base1019 = baseX23({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports19 = {};
__export(base16_exports19, {
  base16: () => base1619,
  base16upper: () => base16upper19
});
var base1619 = rfc464824({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper19 = rfc464824({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports19 = {};
__export(base2_exports19, {
  base2: () => base219
});
var base219 = rfc464824({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports19 = {};
__export(base256emoji_exports19, {
  base256emoji: () => base256emoji19
});
var alphabet19 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars19 = alphabet19.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes19 = alphabet19.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode88(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars19[c];
    return p;
  }, "");
}
function decode112(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes19[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji19 = from43({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode88,
  decode: decode112
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports20 = {};
__export(base32_exports20, {
  base32: () => base3222,
  base32hex: () => base32hex22,
  base32hexpad: () => base32hexpad22,
  base32hexpadupper: () => base32hexpadupper22,
  base32hexupper: () => base32hexupper22,
  base32pad: () => base32pad22,
  base32padupper: () => base32padupper22,
  base32upper: () => base32upper22,
  base32z: () => base32z22
});
var base3222 = rfc464824({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper22 = rfc464824({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad22 = rfc464824({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper22 = rfc464824({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex22 = rfc464824({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper22 = rfc464824({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad22 = rfc464824({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper22 = rfc464824({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z22 = rfc464824({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports19 = {};
__export(base36_exports19, {
  base36: () => base3619,
  base36upper: () => base36upper19
});
var base3619 = baseX23({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper19 = baseX23({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports20 = {};
__export(base58_exports20, {
  base58btc: () => base58btc23,
  base58flickr: () => base58flickr23
});
var base58btc23 = baseX23({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr23 = baseX23({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports19 = {};
__export(base64_exports19, {
  base64: () => base6422,
  base64pad: () => base64pad22,
  base64url: () => base64url22,
  base64urlpad: () => base64urlpad22
});
var base6422 = rfc464824({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad22 = rfc464824({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url22 = rfc464824({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad22 = rfc464824({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports19 = {};
__export(base8_exports19, {
  base8: () => base819
});
var base819 = rfc464824({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports37 = {};
__export(identity_exports37, {
  identity: () => identity37
});
var identity37 = from43({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString38(buf3),
  decode: (str) => fromString38(str)
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder23 = new TextEncoder();
var textDecoder22 = new TextDecoder();

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports38 = {};
__export(identity_exports38, {
  identity: () => identity38
});
var code25 = 0;
var name19 = "identity";
var encode89 = coerce24;
function digest19(input) {
  return create23(code25, encode89(input));
}
var identity38 = { code: code25, name: name19, encode: encode89, digest: digest19 };

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports19 = {};
__export(sha2_browser_exports19, {
  sha256: () => sha25621,
  sha512: () => sha51221
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/hasher.js
function from44({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher20(name29, code33, encode116);
}
var Hasher20 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create23(this.code, result) : result.then((digest27) => create23(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha20(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25621 = from44({
  name: "sha2-256",
  code: 18,
  encode: sha20("SHA-256")
});
var sha51221 = from44({
  name: "sha2-512",
  code: 19,
  encode: sha20("SHA-512")
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/cid.js
function format21(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV021(bytes3, baseCache21(link), base45 ?? base58btc23.encoder);
    default:
      return toStringV121(bytes3, baseCache21(link), base45 ?? base3222.encoder);
  }
}
var cache23 = /* @__PURE__ */ new WeakMap();
function baseCache21(cid) {
  const baseCache28 = cache23.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache23.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID21 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE21) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE21) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create23(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals57(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format21(this, base45);
  }
  toJSON() {
    return { "/": format21(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID21(version3, code33, multihash.bytes));
    } else if (value[cidSymbol21] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode110(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE21) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE21}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID21(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE21, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce24(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest21(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode109(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE21;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes21(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache21(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes21(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc23;
      return [
        base58btc23.prefix,
        decoder.decode(`${base58btc23.prefix}${source}`)
      ];
    }
    case base58btc23.prefix: {
      const decoder = base45 ?? base58btc23;
      return [base58btc23.prefix, decoder.decode(source)];
    }
    case base3222.prefix: {
      const decoder = base45 ?? base3222;
      return [base3222.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV021(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc23.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV121(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE21 = 112;
var SHA_256_CODE21 = 18;
function encodeCID21(version3, code33, multihash) {
  const codeOffset = encodingLength22(version3);
  const hashOffset = codeOffset + encodingLength22(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo21(version3, bytes3, 0);
  encodeTo21(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol21 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/basics.js
var bases19 = { ...identity_exports37, ...base2_exports19, ...base8_exports19, ...base10_exports19, ...base16_exports19, ...base32_exports20, ...base36_exports19, ...base58_exports20, ...base64_exports19, ...base256emoji_exports19 };
var hashes19 = { ...sha2_browser_exports19, ...identity_exports38 };

// node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec20(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string20 = createCodec20("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii19 = createCodec20("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe22(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES19 = {
  utf8: string20,
  "utf-8": string20,
  hex: bases19.base16,
  latin1: ascii19,
  ascii: ascii19,
  binary: ascii19,
  ...bases19
};
var bases_default19 = BASES19;

// node_modules/@libp2p/webrtc/node_modules/uint8arrays/dist/src/from-string.js
function fromString39(string27, encoding = "utf8") {
  const base45 = bases_default19[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/sdp.js
var mbdecoder = Object.values(bases19).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
function getLocalFingerprint(pc, options2) {
  const localCert = pc.getConfiguration().certificates?.at(0);
  if (localCert?.getFingerprints == null) {
    options2.log.trace("fetching fingerprint from local SDP");
    const localDescription = pc.localDescription;
    if (localDescription == null) {
      return void 0;
    }
    return getFingerprintFromSdp(localDescription.sdp);
  }
  options2.log.trace("fetching fingerprint from local certificate");
  if (localCert.getFingerprints().length === 0) {
    return void 0;
  }
  const fingerprint = localCert.getFingerprints()[0].value;
  if (fingerprint == null) {
    throw invalidFingerprint("", "no fingerprint on local certificate");
  }
  return fingerprint;
}
var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
  const searchResult = sdp.match(fingerprintRegex);
  return searchResult?.groups?.fingerprint;
}
function ipv(ma) {
  for (const proto of ma.protoNames()) {
    if (proto.startsWith("ip")) {
      return proto.toUpperCase();
    }
  }
  return "IP6";
}
function certhash2(ma) {
  const tups = ma.stringTuples();
  const certhash3 = tups.filter((tup) => tup[0] === CERTHASH_CODE).map((tup) => tup[1])[0];
  if (certhash3 === void 0 || certhash3 === "") {
    throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
  }
  return certhash3;
}
function decodeCerthash(certhash3) {
  return digest_exports21.decode(mbdecoder.decode(certhash3));
}
function ma2Fingerprint(ma) {
  const mhdecoded = decodeCerthash(certhash2(ma));
  const prefix = toSupportedHashFunction(mhdecoded.code);
  const fingerprint = mhdecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  const sdp = fingerprint.match(/.{1,2}/g);
  if (sdp == null) {
    throw invalidFingerprint(fingerprint, ma.toString());
  }
  return [`${prefix} ${sdp.join(":").toUpperCase()}`, fingerprint];
}
function toSupportedHashFunction(code33) {
  switch (code33) {
    case 17:
      return "SHA-1";
    case 18:
      return "SHA-256";
    case 19:
      return "SHA-512";
    default:
      throw unsupportedHashAlgorithmCode(code33);
  }
}
function ma2sdp(ma, ufrag) {
  const { host, port } = ma.toOptions();
  const ipVersion = ipv(ma);
  const [CERTFP] = ma2Fingerprint(ma);
  return `v=0
o=- 0 0 IN ${ipVersion} ${host}
s=-
c=IN ${ipVersion} ${host}
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${CERTFP}
a=sctp-port:5000
a=max-message-size:16384
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\r
`;
}
function fromMultiAddr(ma, ufrag) {
  return {
    type: "answer",
    sdp: ma2sdp(ma, ufrag)
  };
}
function munge(desc, ufrag) {
  if (desc.sdp === void 0) {
    throw invalidArgument("Can't munge a missing SDP");
  }
  desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + "\n").replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + "\n");
  return desc;
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/util.js
var charset = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var genUfrag = (len) => [...Array(len)].map(() => charset.at(Math.floor(Math.random() * charset.length))).join("");

// node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
var HANDSHAKE_TIMEOUT_MS = 1e4;
var WEBRTC_CODE = getProtocol("webrtc-direct").code;
var CERTHASH_CODE = getProtocol("certhash").code;
var WebRTCDirectTransport = class {
  log;
  metrics;
  components;
  init;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:webrtc-direct");
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC-direct dial events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/webrtc-direct";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  /**
   * Dial a given multiaddr
   */
  async dial(ma, options2) {
    const rawConn = await this._connect(ma, options2);
    this.log("dialing address: %a", ma);
    return rawConn;
  }
  /**
   * Create transport listeners no supported by browsers
   */
  createListener(options2) {
    throw unimplemented("WebRTCTransport.createListener");
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTCDirect.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /**
   * Connect to a peer using a multiaddr
   */
  async _connect(ma, options2) {
    const controller = new AbortController();
    const signal = controller.signal;
    const remotePeerString = ma.getPeerId();
    if (remotePeerString === null) {
      throw inappropriateMultiaddr("we need to have the remote's PeerId");
    }
    const theirPeerId = peerIdFromString(remotePeerString);
    const remoteCerthash = decodeCerthash(certhash2(ma));
    const certificate = await RTCPeerConnection.generateCertificate({
      name: "ECDSA",
      namedCurve: "P-256",
      hash: toSupportedHashFunction(remoteCerthash.code)
    });
    const peerConnection = new RTCPeerConnection({
      ...await getRtcConfiguration(this.init.rtcConfiguration),
      certificates: [certificate]
    });
    try {
      const dataChannelOpenPromise = new Promise((resolve, reject) => {
        const handshakeDataChannel2 = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
        const handshakeTimeout = setTimeout(() => {
          const error = `Data channel was never opened: state: ${handshakeDataChannel2.readyState}`;
          this.log.error(error);
          this.metrics?.dialerEvents.increment({ open_error: true });
          reject(dataChannelError("data", error));
        }, HANDSHAKE_TIMEOUT_MS);
        handshakeDataChannel2.onopen = (_) => {
          clearTimeout(handshakeTimeout);
          resolve(handshakeDataChannel2);
        };
        handshakeDataChannel2.onerror = (event) => {
          clearTimeout(handshakeTimeout);
          const errorTarget = event.target?.toString() ?? "not specified";
          const error = `Error opening a data channel for handshaking: ${errorTarget}`;
          this.log.error(error);
          this.metrics?.dialerEvents.increment({ unknown_error: true });
          reject(dataChannelError("data", error));
        };
      });
      const ufrag = "libp2p+webrtc+v1/" + genUfrag(32);
      const offerSdp = await peerConnection.createOffer();
      const mungedOfferSdp = munge(offerSdp, ufrag);
      await peerConnection.setLocalDescription(mungedOfferSdp);
      const answerSdp = fromMultiAddr(ma, ufrag);
      await peerConnection.setRemoteDescription(answerSdp);
      const handshakeDataChannel = await dataChannelOpenPromise;
      const myPeerId = this.components.peerId;
      const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma);
      const connectionEncrypter = noise({ prologueBytes: fingerprintsPrologue })(this.components);
      const wrappedChannel = createStream2({
        channel: handshakeDataChannel,
        direction: "inbound",
        logger: this.components.logger,
        ...this.init.dataChannel ?? {}
      });
      const wrappedDuplex = {
        ...wrappedChannel,
        sink: wrappedChannel.sink.bind(wrappedChannel),
        source: async function* () {
          for await (const list of wrappedChannel.source) {
            for (const buf3 of list) {
              yield buf3;
            }
          }
        }()
      };
      const maConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        remoteAddr: ma,
        timeline: {
          open: Date.now()
        },
        metrics: this.metrics?.dialerEvents
      });
      const eventListeningName = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
      peerConnection.addEventListener(eventListeningName, () => {
        switch (peerConnection.connectionState) {
          case "failed":
          case "disconnected":
          case "closed":
            maConn.close().catch((err) => {
              this.log.error("error closing connection", err);
            }).finally(() => {
              controller.abort();
            });
            break;
          default:
            break;
        }
      }, { signal });
      this.metrics?.dialerEvents.increment({ peer_connection: true });
      const muxerFactory = new DataChannelMuxerFactory(this.components, {
        peerConnection,
        metrics: this.metrics?.dialerEvents,
        dataChannelOptions: this.init.dataChannel
      });
      await connectionEncrypter.secureInbound(myPeerId, wrappedDuplex, theirPeerId);
      return await options2.upgrader.upgradeOutbound(maConn, { skipProtection: true, skipEncryption: true, muxerFactory });
    } catch (err) {
      peerConnection.close();
      throw err;
    }
  }
  /**
   * Generate a noise prologue from the peer connection's certificate.
   * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint
   */
  generateNoisePrologue(pc, hashCode, ma) {
    if (pc.getConfiguration().certificates?.length === 0) {
      throw invalidArgument("no local certificate");
    }
    const localFingerprint = getLocalFingerprint(pc, {
      log: this.log
    });
    if (localFingerprint == null) {
      throw invalidArgument("no local fingerprint found");
    }
    const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
    const localFpArray = fromString39(localFpString, "hex");
    const local = create23(hashCode, localFpArray);
    const remote = mbdecoder.decode(certhash2(ma));
    const prefix = fromString39("libp2p-webrtc-noise:");
    return concat11([prefix, local.bytes, remote]);
  }
};

// node_modules/@libp2p/webrtc/dist/src/index.js
function webRTCDirect(init) {
  return (components) => new WebRTCDirectTransport(components, init);
}
function webRTC(init) {
  return (components) => new WebRTCTransport(components, init);
}

// node_modules/it-ws/dist/src/ready.js
var ready_default = async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options2) => {
  options2 = options2 ?? {};
  options2.closeOnEnd = options2.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options2.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports20 = {};
__export(base10_exports20, {
  base10: () => base1020
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bytes.js
var empty25 = new Uint8Array(0);
function equals58(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce25(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString40(str) {
  return new TextEncoder().encode(str);
}
function toString39(b) {
  return new TextDecoder().decode(b);
}

// node_modules/it-ws/node_modules/multiformats/dist/src/vendor/base-x.js
function base39(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src24 = base39;
var _brrp__multiformats_scope_baseX24 = src24;
var base_x_default25 = _brrp__multiformats_scope_baseX24;

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base.js
var Encoder26 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder27 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or27(this, decoder);
  }
};
var ComposedDecoder25 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or27(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or27(left, right) {
  return new ComposedDecoder25({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec25 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder26(name29, prefix, baseEncode);
    this.decoder = new Decoder27(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from45({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec25(name29, prefix, encode116, decode144);
}
function baseX24({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default25(alphabet27, name29);
  return from45({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce25(decode144(text))
  });
}
function decode113(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode90(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464825({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from45({
    prefix,
    name: name29,
    encode(input) {
      return encode90(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode113(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
var base1020 = baseX24({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports20 = {};
__export(base16_exports20, {
  base16: () => base1620,
  base16upper: () => base16upper20
});
var base1620 = rfc464825({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper20 = rfc464825({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports20 = {};
__export(base2_exports20, {
  base2: () => base220
});
var base220 = rfc464825({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports20 = {};
__export(base256emoji_exports20, {
  base256emoji: () => base256emoji20
});
var alphabet20 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars20 = alphabet20.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes20 = alphabet20.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode91(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars20[c];
    return p;
  }, "");
}
function decode114(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes20[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji20 = from45({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode91,
  decode: decode114
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports21 = {};
__export(base32_exports21, {
  base32: () => base3223,
  base32hex: () => base32hex23,
  base32hexpad: () => base32hexpad23,
  base32hexpadupper: () => base32hexpadupper23,
  base32hexupper: () => base32hexupper23,
  base32pad: () => base32pad23,
  base32padupper: () => base32padupper23,
  base32upper: () => base32upper23,
  base32z: () => base32z23
});
var base3223 = rfc464825({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper23 = rfc464825({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad23 = rfc464825({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper23 = rfc464825({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex23 = rfc464825({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper23 = rfc464825({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad23 = rfc464825({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper23 = rfc464825({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z23 = rfc464825({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports20 = {};
__export(base36_exports20, {
  base36: () => base3620,
  base36upper: () => base36upper20
});
var base3620 = baseX24({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper20 = baseX24({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports21 = {};
__export(base58_exports21, {
  base58btc: () => base58btc24,
  base58flickr: () => base58flickr24
});
var base58btc24 = baseX24({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr24 = baseX24({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports20 = {};
__export(base64_exports20, {
  base64: () => base6423,
  base64pad: () => base64pad23,
  base64url: () => base64url23,
  base64urlpad: () => base64urlpad23
});
var base6423 = rfc464825({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad23 = rfc464825({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url23 = rfc464825({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad23 = rfc464825({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports20 = {};
__export(base8_exports20, {
  base8: () => base820
});
var base820 = rfc464825({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/it-ws/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports39 = {};
__export(identity_exports39, {
  identity: () => identity39
});
var identity39 = from45({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString39(buf3),
  decode: (str) => fromString40(str)
});

// node_modules/it-ws/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder24 = new TextEncoder();
var textDecoder23 = new TextDecoder();

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports40 = {};
__export(identity_exports40, {
  identity: () => identity40
});

// node_modules/it-ws/node_modules/multiformats/dist/src/vendor/varint.js
var encode_122 = encode92;
var MSB24 = 128;
var REST24 = 127;
var MSBALL22 = ~REST24;
var INT22 = Math.pow(2, 31);
function encode92(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT22) {
    out[offset++] = num & 255 | MSB24;
    num /= 128;
  }
  while (num & MSBALL22) {
    out[offset++] = num & 255 | MSB24;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode92.bytes = offset - oldOffset + 1;
  return out;
}
var decode115 = read23;
var MSB$122 = 128;
var REST$122 = 127;
function read23(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read23.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$122) << shift : (b & REST$122) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$122);
  read23.bytes = counter - offset;
  return res;
}
var N123 = Math.pow(2, 7);
var N223 = Math.pow(2, 14);
var N323 = Math.pow(2, 21);
var N423 = Math.pow(2, 28);
var N523 = Math.pow(2, 35);
var N623 = Math.pow(2, 42);
var N723 = Math.pow(2, 49);
var N822 = Math.pow(2, 56);
var N922 = Math.pow(2, 63);
var length24 = function(value) {
  return value < N123 ? 1 : value < N223 ? 2 : value < N323 ? 3 : value < N423 ? 4 : value < N523 ? 5 : value < N623 ? 6 : value < N723 ? 7 : value < N822 ? 8 : value < N922 ? 9 : 10;
};
var varint22 = {
  encode: encode_122,
  decode: decode115,
  encodingLength: length24
};
var _brrp_varint22 = varint22;
var varint_default22 = _brrp_varint22;

// node_modules/it-ws/node_modules/multiformats/dist/src/varint.js
function decode116(data, offset = 0) {
  const code33 = varint_default22.decode(data, offset);
  return [code33, varint_default22.decode.bytes];
}
function encodeTo22(int, target, offset = 0) {
  varint_default22.encode(int, target, offset);
  return target;
}
function encodingLength23(int) {
  return varint_default22.encodingLength(int);
}

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/digest.js
function create24(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength23(code33);
  const digestOffset = sizeOffset + encodingLength23(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo22(code33, bytes3, 0);
  encodeTo22(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest22(code33, size, digest27, bytes3);
}
function decode117(multihash) {
  const bytes3 = coerce25(multihash);
  const [code33, sizeOffset] = decode116(bytes3);
  const [size, digestOffset] = decode116(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest22(code33, size, digest27, bytes3);
}
function equals59(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals58(a.bytes, data.bytes);
  }
}
var Digest22 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
var code26 = 0;
var name20 = "identity";
var encode93 = coerce25;
function digest20(input) {
  return create24(code26, encode93(input));
}
var identity40 = { code: code26, name: name20, encode: encode93, digest: digest20 };

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports20 = {};
__export(sha2_browser_exports20, {
  sha256: () => sha25622,
  sha512: () => sha51222
});

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/hasher.js
function from46({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher21(name29, code33, encode116);
}
var Hasher21 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create24(this.code, result) : result.then((digest27) => create24(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha21(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25622 = from46({
  name: "sha2-256",
  code: 18,
  encode: sha21("SHA-256")
});
var sha51222 = from46({
  name: "sha2-512",
  code: 19,
  encode: sha21("SHA-512")
});

// node_modules/it-ws/node_modules/multiformats/dist/src/cid.js
function format22(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV022(bytes3, baseCache22(link), base45 ?? base58btc24.encoder);
    default:
      return toStringV122(bytes3, baseCache22(link), base45 ?? base3223.encoder);
  }
}
var cache24 = /* @__PURE__ */ new WeakMap();
function baseCache22(cid) {
  const baseCache28 = cache24.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache24.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID22 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE22) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE22) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create24(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals59(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format22(this, base45);
  }
  toJSON() {
    return { "/": format22(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID22(version3, code33, multihash.bytes));
    } else if (value[cidSymbol22] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode117(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE22) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE22}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID22(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE22, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce25(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest22(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode116(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE22;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes22(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache22(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes22(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc24;
      return [
        base58btc24.prefix,
        decoder.decode(`${base58btc24.prefix}${source}`)
      ];
    }
    case base58btc24.prefix: {
      const decoder = base45 ?? base58btc24;
      return [base58btc24.prefix, decoder.decode(source)];
    }
    case base3223.prefix: {
      const decoder = base45 ?? base3223;
      return [base3223.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV022(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc24.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV122(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE22 = 112;
var SHA_256_CODE22 = 18;
function encodeCID22(version3, code33, multihash) {
  const codeOffset = encodingLength23(version3);
  const hashOffset = codeOffset + encodingLength23(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo22(version3, bytes3, 0);
  encodeTo22(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol22 = Symbol.for("@ipld/js-cid/CID");

// node_modules/it-ws/node_modules/multiformats/dist/src/basics.js
var bases20 = { ...identity_exports39, ...base2_exports20, ...base8_exports20, ...base10_exports20, ...base16_exports20, ...base32_exports21, ...base36_exports20, ...base58_exports21, ...base64_exports20, ...base256emoji_exports20 };
var hashes20 = { ...sha2_browser_exports20, ...identity_exports40 };

// node_modules/it-ws/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe23(size = 0) {
  return new Uint8Array(size);
}

// node_modules/it-ws/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec21(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string21 = createCodec21("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii20 = createCodec21("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe23(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES20 = {
  utf8: string21,
  "utf-8": string21,
  hex: bases20.base16,
  latin1: ascii20,
  ascii: ascii20,
  binary: ascii20,
  ...bases20
};
var bases_default20 = BASES20;

// node_modules/it-ws/node_modules/uint8arrays/dist/src/from-string.js
function fromString41(string27, encoding = "utf8") {
  const base45 = bases_default20[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/it-ws/dist/src/source.js
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = (cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      };
      const onOpen = () => {
        cleanUp(resolve);
      };
      const onError = (event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      };
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  };
  const source = async function* () {
    const messages2 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString41(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => {
        fail(event.error ?? new Error("Socket error"));
      };
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options2) => {
  options2 = options2 ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options2.remoteAddress;
  let remotePort = options2.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options2),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var map5 = { "http:": "ws:", "https:": "wss:" };
var defaultProtocol = "ws:";
var ws_url_default = (url, location) => {
  if (url.startsWith("//")) {
    url = `${location?.protocol ?? defaultProtocol}${url}`;
  }
  if (url.startsWith("/") && location != null) {
    const proto = location.protocol ?? defaultProtocol;
    const host = location.host;
    const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : "";
    url = `${proto}//${host}${port}${url}`;
  }
  const wsUrl = new URL(url);
  for (const [httpProto, wsProto] of Object.entries(map5)) {
    if (wsUrl.protocol === httpProto) {
      wsUrl.protocol = wsProto;
    }
  }
  return wsUrl;
};

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location = typeof window === "undefined" ? void 0 : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location);
  const socket = new web_socket_browser_default(url.toString(), opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/@libp2p/websockets/node_modules/p-defer/index.js
function pDefer11() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@libp2p/websockets/dist/src/constants.js
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT3 = 500;

// node_modules/@libp2p/websockets/dist/src/filters.js
function all2(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets2.matches(testMa) || WebSocketsSecure2.matches(testMa);
  });
}
function wss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure2.matches(testMa);
  });
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener2() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
function socketToMaConn(stream, remoteAddr, options2) {
  const log10 = options2.logger.forComponent("libp2p:websockets:maconn");
  const metrics = options2.metrics;
  const metricPrefix = options2.metricPrefix ?? "";
  const maConn = {
    log: log10,
    async sink(source) {
      try {
        await stream.sink(async function* () {
          for await (const buf3 of source) {
            if (buf3 instanceof Uint8Array) {
              yield buf3;
            } else {
              yield buf3.subarray();
            }
          }
        }());
      } catch (err) {
        if (err.type !== "aborted") {
          log10.error(err);
        }
      }
    },
    source: stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close(options3 = {}) {
      const start2 = Date.now();
      if (options3.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT3);
        options3 = {
          ...options3,
          signal
        };
      }
      const listener = () => {
        const { host, port } = maConn.remoteAddr.toOptions();
        log10("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start2);
        this.abort(new CodeError("Socket close timeout", "ERR_SOCKET_CLOSE_TIMEOUT"));
      };
      options3.signal?.addEventListener("abort", listener);
      try {
        await stream.close();
      } catch (err) {
        log10.error("error closing WebSocket gracefully", err);
        this.abort(err);
      } finally {
        options3.signal?.removeEventListener("abort", listener);
        maConn.timeline.close = Date.now();
      }
    },
    abort(err) {
      const { host, port } = maConn.remoteAddr.toOptions();
      log10("timeout closing stream to %s:%s due to error", host, port, err);
      stream.destroy();
      maConn.timeline.close = Date.now();
      metrics?.increment({ [`${metricPrefix}error`]: true });
    }
  };
  stream.socket.addEventListener("close", () => {
    metrics?.increment({ [`${metricPrefix}close`]: true });
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/index.js
var WebSockets3 = class {
  log;
  init;
  logger;
  metrics;
  components;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/websockets";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  async dial(ma, options2) {
    this.log("dialing %s", ma);
    options2 = options2 ?? {};
    const socket = await this._connect(ma, options2);
    const maConn = socketToMaConn(socket, ma, {
      logger: this.logger,
      metrics: this.metrics?.dialerEvents
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options2.upgrader.upgradeOutbound(maConn, options2);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options2) {
    options2?.signal?.throwIfAborted();
    const cOpts = ma.toOptions();
    this.log("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer11();
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    rawSocket.socket.addEventListener("error", () => {
      const err = new CodeError(`Could not connect to ${ma.toString()}`, "ERR_CONNECTION_FAILED");
      this.log.error("connection error:", err);
      this.metrics?.dialerEvents.increment({ error: true });
      errorPromise.reject(err);
    });
    try {
      options2.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
      await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options2.signal);
    } catch (err) {
      if (options2.signal?.aborted === true) {
        this.metrics?.dialerEvents.increment({ abort: true });
      }
      rawSocket.close().catch((err2) => {
        this.log.error("error closing raw socket", err2);
      });
      throw err;
    }
    this.log("connected %s", ma);
    this.metrics?.dialerEvents.increment({ connect: true });
    return rawSocket;
  }
  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options2) {
    return createListener2({
      logger: this.logger,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options2
    });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser || isWebWorker) {
      return wss(multiaddrs);
    }
    return all2(multiaddrs);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets3(components, init);
  };
}

// node_modules/@libp2p/webtransport/dist/src/listener.browser.js
function createListener3(options2) {
  throw new Error("Not implemented");
}

// node_modules/@libp2p/webtransport/dist/src/stream.js
var WebTransportStream = class extends AbstractStream {
  writer;
  reader;
  constructor(init) {
    super(init);
    this.writer = init.bidiStream.writable.getWriter();
    this.reader = init.bidiStream.readable.getReader();
    Promise.resolve().then(async () => {
      while (true) {
        const result = await this.reader.read();
        if (result.done) {
          init.log("remote closed write");
          return;
        }
        if (result.value != null) {
          this.sourcePush(new Uint8ArrayList(result.value));
        }
      }
    }).catch((err) => {
      init.log.error("error reading from stream", err);
      this.abort(err);
    }).finally(() => {
      this.remoteCloseWrite();
    });
    void this.writer.closed.then(() => {
      init.log("writer closed");
    }).catch((err) => {
      init.log("writer close promise rejected", err);
    }).finally(() => {
      this.remoteCloseRead();
    });
  }
  sendNewStream(options2) {
  }
  async sendData(buf3, options2) {
    for await (const chunk of buf3) {
      this.log("sendData waiting for writer to be ready");
      await raceSignal(this.writer.ready, options2?.signal);
      this.writer.write(chunk).catch((err) => {
        this.log.error("error sending stream data", err);
      });
    }
  }
  async sendReset(options2) {
    this.log("sendReset aborting writer");
    await raceSignal(this.writer.abort(), options2?.signal);
    this.log("sendReset aborted writer");
  }
  async sendCloseWrite(options2) {
    this.log("sendCloseWrite closing writer");
    await raceSignal(this.writer.close(), options2?.signal);
    this.log("sendCloseWrite closed writer");
  }
  async sendCloseRead(options2) {
    this.log("sendCloseRead cancelling reader");
    await raceSignal(this.reader.cancel(), options2?.signal);
    this.log("sendCloseRead cancelled reader");
  }
};
async function webtransportBiDiStreamToStream(bidiStream, streamId, direction, activeStreams, onStreamEnd, logger2) {
  const log10 = logger2.forComponent(`libp2p:webtransport:stream:${direction}:${streamId}`);
  const stream = new WebTransportStream({
    bidiStream,
    id: streamId,
    direction,
    log: log10,
    onEnd: () => {
      const index = activeStreams.findIndex((s2) => s2 === stream);
      if (index !== -1) {
        activeStreams.splice(index, 1);
      }
      onStreamEnd?.(stream);
    }
  });
  return stream;
}

// node_modules/@libp2p/webtransport/dist/src/utils/inert-duplex.js
function inertDuplex() {
  return {
    source: {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            return new Promise(() => {
            });
          }
        };
      }
    },
    sink: async (source) => {
      return new Promise(() => {
      });
    }
  };
}

// node_modules/@libp2p/webtransport/dist/src/muxer.js
function webtransportMuxer(wt, reader, logger2, config) {
  let streamIDCounter = 0;
  const log10 = logger2.forComponent("libp2p:webtransport:muxer");
  return {
    protocol: "webtransport",
    createStreamMuxer: (init) => {
      if (typeof init === "function") {
        init = { onIncomingStream: init };
      }
      const activeStreams = [];
      Promise.resolve().then(async () => {
        while (true) {
          const { done, value: wtStream } = await reader.read();
          if (done) {
            break;
          }
          if (activeStreams.length >= config.maxInboundStreams) {
            log10(`too many inbound streams open - ${activeStreams.length}/${config.maxInboundStreams}, closing new incoming stream`);
            wtStream.writable.close().catch((err) => {
              log10.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
            });
            wtStream.readable.cancel().catch((err) => {
              log10.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
            });
          } else {
            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), "inbound", activeStreams, init?.onStreamEnd, logger2);
            activeStreams.push(stream);
            init?.onIncomingStream?.(stream);
          }
        }
      }).catch((err) => {
        log10.error("could not create a new stream", err);
      });
      const muxer = {
        protocol: "webtransport",
        streams: activeStreams,
        newStream: async (name29) => {
          log10("new outgoing stream", name29);
          const wtStream = await wt.createBidirectionalStream();
          const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? "outbound", activeStreams, init?.onStreamEnd, logger2);
          activeStreams.push(stream);
          return stream;
        },
        /**
         * Close all tracked streams and stop the muxer
         */
        close: async () => {
          log10("closing webtransport muxer gracefully");
          try {
            wt.close();
          } catch (err) {
            muxer.abort(err);
          }
        },
        /**
         * Abort all tracked streams and stop the muxer
         */
        abort: (err) => {
          log10("closing webtransport muxer with err:", err);
          try {
            wt.close();
          } catch (err2) {
            log10.error("webtransport session threw error during close", err2);
          }
        },
        // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.
        ...inertDuplex()
      };
      return muxer;
    }
  };
}

// node_modules/@libp2p/webtransport/node_modules/uint8arrays/dist/src/equals.js
function equals60(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/webtransport/dist/src/utils/is-subset.js
function isSubset(set, maybeSubset) {
  const intersection = maybeSubset.filter((byteArray) => {
    return Boolean(set.find((otherByteArray) => equals60(byteArray, otherByteArray)));
  });
  return intersection.length === maybeSubset.length;
}

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports21 = {};
__export(base10_exports21, {
  base10: () => base1021
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bytes.js
var empty26 = new Uint8Array(0);
function equals61(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce26(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString42(str) {
  return new TextEncoder().encode(str);
}
function toString40(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/vendor/base-x.js
function base40(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src25 = base40;
var _brrp__multiformats_scope_baseX25 = src25;
var base_x_default26 = _brrp__multiformats_scope_baseX25;

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base.js
var Encoder27 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder28 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or28(this, decoder);
  }
};
var ComposedDecoder26 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or28(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or28(left, right) {
  return new ComposedDecoder26({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec26 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder27(name29, prefix, baseEncode);
    this.decoder = new Decoder28(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from47({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec26(name29, prefix, encode116, decode144);
}
function baseX25({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default26(alphabet27, name29);
  return from47({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce26(decode144(text))
  });
}
function decode118(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode94(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464826({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from47({
    prefix,
    name: name29,
    encode(input) {
      return encode94(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode118(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base10.js
var base1021 = baseX25({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports21 = {};
__export(base16_exports21, {
  base16: () => base1621,
  base16upper: () => base16upper21
});
var base1621 = rfc464826({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper21 = rfc464826({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports21 = {};
__export(base2_exports21, {
  base2: () => base221
});
var base221 = rfc464826({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports21 = {};
__export(base256emoji_exports21, {
  base256emoji: () => base256emoji21
});
var alphabet21 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars21 = alphabet21.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes21 = alphabet21.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode95(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars21[c];
    return p;
  }, "");
}
function decode119(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes21[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji21 = from47({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode95,
  decode: decode119
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports22 = {};
__export(base32_exports22, {
  base32: () => base3224,
  base32hex: () => base32hex24,
  base32hexpad: () => base32hexpad24,
  base32hexpadupper: () => base32hexpadupper24,
  base32hexupper: () => base32hexupper24,
  base32pad: () => base32pad24,
  base32padupper: () => base32padupper24,
  base32upper: () => base32upper24,
  base32z: () => base32z24
});
var base3224 = rfc464826({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper24 = rfc464826({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad24 = rfc464826({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper24 = rfc464826({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex24 = rfc464826({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper24 = rfc464826({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad24 = rfc464826({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper24 = rfc464826({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z24 = rfc464826({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports21 = {};
__export(base36_exports21, {
  base36: () => base3621,
  base36upper: () => base36upper21
});
var base3621 = baseX25({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper21 = baseX25({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports22 = {};
__export(base58_exports22, {
  base58btc: () => base58btc25,
  base58flickr: () => base58flickr25
});
var base58btc25 = baseX25({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr25 = baseX25({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports21 = {};
__export(base64_exports21, {
  base64: () => base6424,
  base64pad: () => base64pad24,
  base64url: () => base64url24,
  base64urlpad: () => base64urlpad24
});
var base6424 = rfc464826({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad24 = rfc464826({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url24 = rfc464826({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad24 = rfc464826({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports21 = {};
__export(base8_exports21, {
  base8: () => base821
});
var base821 = rfc464826({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports41 = {};
__export(identity_exports41, {
  identity: () => identity41
});
var identity41 = from47({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString40(buf3),
  decode: (str) => fromString42(str)
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder25 = new TextEncoder();
var textDecoder24 = new TextDecoder();

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports42 = {};
__export(identity_exports42, {
  identity: () => identity42
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/digest.js
var digest_exports23 = {};
__export(digest_exports23, {
  Digest: () => Digest23,
  create: () => create25,
  decode: () => decode122,
  equals: () => equals62
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/vendor/varint.js
var encode_123 = encode96;
var MSB25 = 128;
var REST25 = 127;
var MSBALL23 = ~REST25;
var INT23 = Math.pow(2, 31);
function encode96(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT23) {
    out[offset++] = num & 255 | MSB25;
    num /= 128;
  }
  while (num & MSBALL23) {
    out[offset++] = num & 255 | MSB25;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode96.bytes = offset - oldOffset + 1;
  return out;
}
var decode120 = read24;
var MSB$123 = 128;
var REST$123 = 127;
function read24(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read24.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$123) << shift : (b & REST$123) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$123);
  read24.bytes = counter - offset;
  return res;
}
var N124 = Math.pow(2, 7);
var N224 = Math.pow(2, 14);
var N324 = Math.pow(2, 21);
var N424 = Math.pow(2, 28);
var N524 = Math.pow(2, 35);
var N624 = Math.pow(2, 42);
var N724 = Math.pow(2, 49);
var N823 = Math.pow(2, 56);
var N923 = Math.pow(2, 63);
var length25 = function(value) {
  return value < N124 ? 1 : value < N224 ? 2 : value < N324 ? 3 : value < N424 ? 4 : value < N524 ? 5 : value < N624 ? 6 : value < N724 ? 7 : value < N823 ? 8 : value < N923 ? 9 : 10;
};
var varint23 = {
  encode: encode_123,
  decode: decode120,
  encodingLength: length25
};
var _brrp_varint23 = varint23;
var varint_default23 = _brrp_varint23;

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/varint.js
function decode121(data, offset = 0) {
  const code33 = varint_default23.decode(data, offset);
  return [code33, varint_default23.decode.bytes];
}
function encodeTo23(int, target, offset = 0) {
  varint_default23.encode(int, target, offset);
  return target;
}
function encodingLength24(int) {
  return varint_default23.encodingLength(int);
}

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/digest.js
function create25(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength24(code33);
  const digestOffset = sizeOffset + encodingLength24(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo23(code33, bytes3, 0);
  encodeTo23(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest23(code33, size, digest27, bytes3);
}
function decode122(multihash) {
  const bytes3 = coerce26(multihash);
  const [code33, sizeOffset] = decode121(bytes3);
  const [size, digestOffset] = decode121(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest23(code33, size, digest27, bytes3);
}
function equals62(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals61(a.bytes, data.bytes);
  }
}
var Digest23 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/identity.js
var code27 = 0;
var name21 = "identity";
var encode97 = coerce26;
function digest21(input) {
  return create25(code27, encode97(input));
}
var identity42 = { code: code27, name: name21, encode: encode97, digest: digest21 };

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports21 = {};
__export(sha2_browser_exports21, {
  sha256: () => sha25623,
  sha512: () => sha51223
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/hasher.js
function from48({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher22(name29, code33, encode116);
}
var Hasher22 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create25(this.code, result) : result.then((digest27) => create25(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha22(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25623 = from48({
  name: "sha2-256",
  code: 18,
  encode: sha22("SHA-256")
});
var sha51223 = from48({
  name: "sha2-512",
  code: 19,
  encode: sha22("SHA-512")
});

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/cid.js
function format23(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV023(bytes3, baseCache23(link), base45 ?? base58btc25.encoder);
    default:
      return toStringV123(bytes3, baseCache23(link), base45 ?? base3224.encoder);
  }
}
var cache25 = /* @__PURE__ */ new WeakMap();
function baseCache23(cid) {
  const baseCache28 = cache25.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache25.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID23 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE23) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE23) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create25(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals62(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format23(this, base45);
  }
  toJSON() {
    return { "/": format23(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID23(version3, code33, multihash.bytes));
    } else if (value[cidSymbol23] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode122(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE23) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE23}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID23(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE23, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce26(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest23(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode121(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE23;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes23(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache23(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes23(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc25;
      return [
        base58btc25.prefix,
        decoder.decode(`${base58btc25.prefix}${source}`)
      ];
    }
    case base58btc25.prefix: {
      const decoder = base45 ?? base58btc25;
      return [base58btc25.prefix, decoder.decode(source)];
    }
    case base3224.prefix: {
      const decoder = base45 ?? base3224;
      return [base3224.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV023(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc25.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV123(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE23 = 112;
var SHA_256_CODE23 = 18;
function encodeCID23(version3, code33, multihash) {
  const codeOffset = encodingLength24(version3);
  const hashOffset = codeOffset + encodingLength24(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo23(version3, bytes3, 0);
  encodeTo23(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol23 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webtransport/node_modules/multiformats/dist/src/basics.js
var bases21 = { ...identity_exports41, ...base2_exports21, ...base8_exports21, ...base10_exports21, ...base16_exports21, ...base32_exports22, ...base36_exports21, ...base58_exports22, ...base64_exports21, ...base256emoji_exports21 };
var hashes21 = { ...sha2_browser_exports21, ...identity_exports42 };

// node_modules/@libp2p/webtransport/dist/src/utils/parse-multiaddr.js
var multibaseDecoder = Object.values(bases21).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
function decodeCerthashStr(s2) {
  return digest_exports23.decode(multibaseDecoder.decode(s2));
}
function parseMultiaddr(ma) {
  if (!WebTransport.matches(ma)) {
    throw new CodeError("Invalid multiaddr, was not a WebTransport address", "ERR_INVALID_MULTIADDR");
  }
  const parts = ma.stringTuples();
  const certhashes = parts.filter(([name29, _]) => name29 === getProtocol("certhash").code).map(([_, value]) => decodeCerthashStr(value ?? ""));
  const remotePeer = parts.filter(([name29, _]) => name29 === getProtocol("p2p").code).map(([_, value]) => peerIdFromString(value ?? ""))[0];
  const opts = ma.toOptions();
  let host = opts.host;
  if (opts.family === 6 && host?.includes(":")) {
    host = `[${host}]`;
  }
  return {
    // All webtransport urls are https
    url: `https://${host}:${opts.port}`,
    certhashes,
    remotePeer
  };
}

// node_modules/@libp2p/webtransport/dist/src/webtransport.browser.js
var webtransport_browser_default = globalThis.WebTransport;

// node_modules/@libp2p/webtransport/dist/src/index.js
var WebTransportTransport = class {
  log;
  components;
  config;
  metrics;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:webtransport");
    this.components = components;
    this.config = {
      ...init,
      maxInboundStreams: init.maxInboundStreams ?? 1e3,
      certificates: init.certificates ?? []
    };
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total", {
          label: "event",
          help: "Total count of WebTransport dialer events by type"
        })
      };
    }
  }
  [Symbol.toStringTag] = "@libp2p/webtransport";
  [transportSymbol] = true;
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  async dial(ma, options2) {
    if (options2?.signal?.aborted === true) {
      throw new AbortError();
    }
    this.log("dialing %s", ma);
    const localPeer = this.components.peerId;
    if (localPeer === void 0) {
      throw new CodeError("Need a local peerid", "ERR_INVALID_PARAMETERS");
    }
    options2 = options2 ?? {};
    const { url, certhashes, remotePeer } = parseMultiaddr(ma);
    let abortListener;
    let maConn;
    let cleanUpWTSession = () => {
    };
    let closed = false;
    let ready = false;
    let authenticated = false;
    try {
      this.metrics?.dialerEvents.increment({ pending: true });
      const wt = new webtransport_browser_default(`${url}/.well-known/libp2p-webtransport?type=noise`, {
        serverCertificateHashes: certhashes.map((certhash3) => ({
          algorithm: "sha-256",
          value: certhash3.digest
        }))
      });
      cleanUpWTSession = (metric) => {
        if (closed) {
          return;
        }
        try {
          this.metrics?.dialerEvents.increment({ [metric]: true });
          wt.close();
        } catch (err) {
          this.log.error("error closing wt session", err);
        } finally {
          if (maConn != null) {
            maConn.timeline.close = Date.now();
          }
          closed = true;
        }
      };
      abortListener = () => {
        if (ready) {
          cleanUpWTSession("noise_timeout");
        } else {
          cleanUpWTSession("ready_timeout");
        }
      };
      options2.signal?.addEventListener("abort", abortListener, {
        once: true
      });
      this.log("wait for session to be ready");
      options2.onProgress?.(new CustomProgressEvent("webtransport:wait-for-session"));
      await Promise.race([
        wt.closed,
        wt.ready
      ]);
      this.log("session became ready");
      ready = true;
      this.metrics?.dialerEvents.increment({ ready: true });
      wt.closed.catch((err) => {
        this.log.error("error on remote wt session close", err);
      }).finally(() => {
        cleanUpWTSession("remote_close");
      });
      authenticated = await raceSignal(this.authenticateWebTransport({ wt, localPeer, remotePeer, certhashes, ...options2 }), options2.signal);
      if (!authenticated) {
        throw new CodeError("Failed to authenticate webtransport", "ERR_AUTHENTICATION_FAILED");
      }
      this.metrics?.dialerEvents.increment({ open: true });
      maConn = {
        close: async () => {
          this.log("closing webtransport");
          cleanUpWTSession("close");
        },
        abort: (err) => {
          this.log("aborting webtransport due to passed err", err);
          cleanUpWTSession("abort");
        },
        remoteAddr: ma,
        timeline: {
          open: Date.now()
        },
        log: this.components.logger.forComponent("libp2p:webtransport:maconn"),
        // This connection is never used directly since webtransport supports native streams.
        ...inertDuplex()
      };
      return await options2.upgrader.upgradeOutbound(maConn, {
        skipEncryption: true,
        muxerFactory: webtransportMuxer(wt, wt.incomingBidirectionalStreams.getReader(), this.components.logger, this.config),
        skipProtection: true,
        onProgress: options2.onProgress
      });
    } catch (err) {
      this.log.error("caught wt session err", err);
      if (authenticated) {
        cleanUpWTSession("upgrade_error");
      } else if (ready) {
        cleanUpWTSession("noise_error");
      } else {
        cleanUpWTSession("ready_error");
      }
      throw err;
    } finally {
      if (abortListener != null) {
        options2.signal?.removeEventListener("abort", abortListener);
      }
    }
  }
  async authenticateWebTransport({ wt, localPeer, remotePeer, certhashes, onProgress, signal }) {
    signal?.throwIfAborted();
    onProgress?.(new CustomProgressEvent("webtransport:open-authentication-stream"));
    const stream = await wt.createBidirectionalStream();
    const writer = stream.writable.getWriter();
    const reader = stream.readable.getReader();
    const duplex = {
      source: async function* () {
        while (true) {
          const val = await reader.read();
          if (val.value != null) {
            yield val.value;
          }
          if (val.done) {
            break;
          }
        }
      }(),
      sink: async (source) => {
        for await (const chunk of source) {
          await raceSignal(writer.ready, signal);
          const buf3 = chunk instanceof Uint8Array ? chunk : chunk.subarray();
          writer.write(buf3).catch((err) => {
            this.log.error("could not write chunk during authentication of WebTransport stream", err);
          });
        }
      }
    };
    const n = noise()(this.components);
    onProgress?.(new CustomProgressEvent("webtransport:secure-outbound-connection"));
    const { remoteExtensions } = await n.secureOutbound(localPeer, duplex, remotePeer);
    onProgress?.(new CustomProgressEvent("webtransport:close-authentication-stream"));
    writer.close().catch((err) => {
      this.log.error(`Failed to close authentication stream writer: ${err.message}`);
    });
    reader.cancel().catch((err) => {
      this.log.error(`Failed to close authentication stream reader: ${err.message}`);
    });
    if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map((ch) => ch.bytes))) {
      throw new Error("Our certhashes are not a subset of the remote's reported certhashes");
    }
    return true;
  }
  createListener(options2) {
    return createListener3(this.components, {
      ...options2,
      certificates: this.config.certificates,
      maxInboundStreams: this.config.maxInboundStreams
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter() {
    return [];
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    if (globalThis.WebTransport == null) {
      return [];
    }
    return multiaddrs.filter((ma) => {
      if (!WebTransport.exactMatch(ma)) {
        return false;
      }
      const { url, certhashes } = parseMultiaddr(ma);
      return url != null && certhashes.length > 0;
    });
  }
};
function webTransport(init = {}) {
  return (components) => new WebTransportTransport(components, init);
}

// node_modules/ipns/dist/src/selector.js
var import_timestamp_nano3 = __toESM(require_timestamp_min(), 1);
function ipnsSelector(key, data) {
  const entries = data.map((buf3, index) => ({
    record: unmarshal(buf3),
    index
  }));
  entries.sort((a, b) => {
    const aSeq = a.record.sequence;
    const bSeq = b.record.sequence;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    if (a.record.validityType === IpnsEntry.ValidityType.EOL && b.record.validityType === IpnsEntry.ValidityType.EOL) {
      const recordAValidityDate = import_timestamp_nano3.default.fromString(a.record.validity).toDate();
      const recordBValidityDate = import_timestamp_nano3.default.fromString(b.record.validity).toDate();
      if (recordAValidityDate.getTime() > recordBValidityDate.getTime()) {
        return -1;
      }
      if (recordAValidityDate.getTime() < recordBValidityDate.getTime()) {
        return 1;
      }
    }
    return 0;
  });
  return entries[0].index;
}

// node_modules/libp2p/dist/src/version.js
var version = "1.9.3";
var name22 = "libp2p";

// node_modules/helia/dist/src/version.js
var version2 = "4.2.5";
var name23 = "helia";

// node_modules/helia/dist/src/utils/bootstrappers.js
var bootstrapConfig = {
  list: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
  ]
};

// node_modules/helia/dist/src/utils/libp2p-defaults.browser.js
function libp2pDefaults(options2 = {}) {
  const agentVersion = `${name23}/${version2} ${name22}/${version} UserAgent=${globalThis.navigator.userAgent}`;
  return {
    peerId: options2.peerId,
    dns: options2.dns,
    addresses: {
      listen: [
        "/webrtc"
      ]
    },
    transports: [
      circuitRelayTransport({
        discoverRelays: 1
      }),
      webRTC(),
      webRTCDirect(),
      webTransport(),
      webSockets()
    ],
    connectionEncryption: [
      noise()
    ],
    streamMuxers: [
      yamux(),
      mplex()
    ],
    peerDiscovery: [
      bootstrap(bootstrapConfig)
    ],
    services: {
      autoNAT: autoNAT(),
      dcutr: dcutr(),
      delegatedRouting: () => createDelegatedRoutingV1HttpApiClient("https://delegated-ipfs.dev"),
      dht: kadDHT({
        clientMode: true,
        validators: {
          ipns: ipnsValidator
        },
        selectors: {
          ipns: ipnsSelector
        }
      }),
      identify: identify({
        agentVersion
      }),
      identifyPush: identifyPush({
        agentVersion
      }),
      keychain: keychain(options2.keychain),
      ping: ping()
    }
  };
}

// node_modules/helia/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports22 = {};
__export(base10_exports22, {
  base10: () => base1022
});
var base1022 = baseX14({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports22 = {};
__export(base16_exports22, {
  base16: () => base1622,
  base16upper: () => base16upper22
});
var base1622 = rfc464815({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper22 = rfc464815({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports22 = {};
__export(base2_exports22, {
  base2: () => base222
});
var base222 = rfc464815({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports22 = {};
__export(base256emoji_exports22, {
  base256emoji: () => base256emoji22
});
var alphabet22 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars22 = alphabet22.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes22 = alphabet22.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode98(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars22[c];
    return p;
  }, "");
}
function decode123(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes22[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji22 = from26({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode98,
  decode: decode123
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports22 = {};
__export(base36_exports22, {
  base36: () => base3622,
  base36upper: () => base36upper22
});
var base3622 = baseX14({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper22 = baseX14({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports22 = {};
__export(base64_exports22, {
  base64: () => base6425,
  base64pad: () => base64pad25,
  base64url: () => base64url25,
  base64urlpad: () => base64urlpad25
});
var base6425 = rfc464815({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad25 = rfc464815({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url25 = rfc464815({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad25 = rfc464815({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports22 = {};
__export(base8_exports22, {
  base8: () => base822
});
var base822 = rfc464815({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/helia/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports43 = {};
__export(identity_exports43, {
  identity: () => identity43
});
var identity43 = from26({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString24(buf3),
  decode: (str) => fromString23(str)
});

// node_modules/helia/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder26 = new TextEncoder();
var textDecoder25 = new TextDecoder();

// node_modules/helia/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports44 = {};
__export(identity_exports44, {
  identity: () => identity44
});
var code28 = 0;
var name24 = "identity";
var encode99 = coerce15;
function digest22(input) {
  return create14(code28, encode99(input));
}
var identity44 = { code: code28, name: name24, encode: encode99, digest: digest22 };

// node_modules/helia/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports22 = {};
__export(sha2_browser_exports22, {
  sha256: () => sha25624,
  sha512: () => sha51224
});

// node_modules/helia/node_modules/multiformats/dist/src/hashes/hasher.js
function from49({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher23(name29, code33, encode116);
}
var Hasher23 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create14(this.code, result) : result.then((digest27) => create14(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/helia/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha23(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25624 = from49({
  name: "sha2-256",
  code: 18,
  encode: sha23("SHA-256")
});
var sha51224 = from49({
  name: "sha2-512",
  code: 19,
  encode: sha23("SHA-512")
});

// node_modules/helia/node_modules/multiformats/dist/src/basics.js
var bases22 = { ...identity_exports43, ...base2_exports22, ...base8_exports22, ...base10_exports22, ...base16_exports22, ...base32_exports12, ...base36_exports22, ...base58_exports12, ...base64_exports22, ...base256emoji_exports22 };
var hashes22 = { ...sha2_browser_exports22, ...identity_exports44 };

// node_modules/helia/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe24(size = 0) {
  return new Uint8Array(size);
}

// node_modules/helia/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec22(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string22 = createCodec22("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii21 = createCodec22("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe24(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES21 = {
  utf8: string22,
  "utf-8": string22,
  hex: bases22.base16,
  latin1: ascii21,
  ascii: ascii21,
  binary: ascii21,
  ...bases22
};
var bases_default21 = BASES21;

// node_modules/helia/node_modules/uint8arrays/dist/src/from-string.js
function fromString43(string27, encoding = "utf8") {
  const base45 = bases_default21[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/helia/node_modules/uint8arrays/dist/src/to-string.js
function toString41(array, encoding = "utf8") {
  const base45 = bases_default21[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/helia/node_modules/interface-datastore/dist/src/key.js
var pathSepS6 = "/";
var pathSepB6 = new TextEncoder().encode(pathSepS6);
var pathSep6 = pathSepB6[0];
var Key6 = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString43(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep6) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString41(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS6));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB6;
    }
    if (this._buf[0] !== pathSep6) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep6, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep6) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS6).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType5(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue5(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS6)) {
      p += pathSepS6;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS6);
    }
    return new _Key(list.slice(0, -1).join(pathSepS6));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS6) {
      return key;
    } else if (key.toString() === pathSepS6) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten5(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType5(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue5(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten5(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports23 = {};
__export(base10_exports23, {
  base10: () => base1023
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bytes.js
var empty27 = new Uint8Array(0);
function equals63(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce27(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString44(str) {
  return new TextEncoder().encode(str);
}
function toString42(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/vendor/base-x.js
function base41(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src26 = base41;
var _brrp__multiformats_scope_baseX26 = src26;
var base_x_default27 = _brrp__multiformats_scope_baseX26;

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base.js
var Encoder28 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder29 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or29(this, decoder);
  }
};
var ComposedDecoder27 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or29(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or29(left, right) {
  return new ComposedDecoder27({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec27 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder28(name29, prefix, baseEncode);
    this.decoder = new Decoder29(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from50({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec27(name29, prefix, encode116, decode144);
}
function baseX26({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default27(alphabet27, name29);
  return from50({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce27(decode144(text))
  });
}
function decode124(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode100(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464827({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from50({
    prefix,
    name: name29,
    encode(input) {
      return encode100(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode124(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base10.js
var base1023 = baseX26({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports23 = {};
__export(base16_exports23, {
  base16: () => base1623,
  base16upper: () => base16upper23
});
var base1623 = rfc464827({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper23 = rfc464827({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports23 = {};
__export(base2_exports23, {
  base2: () => base223
});
var base223 = rfc464827({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports23 = {};
__export(base256emoji_exports23, {
  base256emoji: () => base256emoji23
});
var alphabet23 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars23 = alphabet23.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes23 = alphabet23.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode101(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars23[c];
    return p;
  }, "");
}
function decode125(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes23[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji23 = from50({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode101,
  decode: decode125
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports23 = {};
__export(base32_exports23, {
  base32: () => base3225,
  base32hex: () => base32hex25,
  base32hexpad: () => base32hexpad25,
  base32hexpadupper: () => base32hexpadupper25,
  base32hexupper: () => base32hexupper25,
  base32pad: () => base32pad25,
  base32padupper: () => base32padupper25,
  base32upper: () => base32upper25,
  base32z: () => base32z25
});
var base3225 = rfc464827({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper25 = rfc464827({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad25 = rfc464827({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper25 = rfc464827({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex25 = rfc464827({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper25 = rfc464827({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad25 = rfc464827({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper25 = rfc464827({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z25 = rfc464827({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports23 = {};
__export(base36_exports23, {
  base36: () => base3623,
  base36upper: () => base36upper23
});
var base3623 = baseX26({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper23 = baseX26({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports23 = {};
__export(base58_exports23, {
  base58btc: () => base58btc26,
  base58flickr: () => base58flickr26
});
var base58btc26 = baseX26({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr26 = baseX26({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports23 = {};
__export(base64_exports23, {
  base64: () => base6426,
  base64pad: () => base64pad26,
  base64url: () => base64url26,
  base64urlpad: () => base64urlpad26
});
var base6426 = rfc464827({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad26 = rfc464827({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url26 = rfc464827({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad26 = rfc464827({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports23 = {};
__export(base8_exports23, {
  base8: () => base823
});
var base823 = rfc464827({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports45 = {};
__export(identity_exports45, {
  identity: () => identity45
});
var identity45 = from50({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString42(buf3),
  decode: (str) => fromString44(str)
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder27 = new TextEncoder();
var textDecoder26 = new TextDecoder();

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports46 = {};
__export(identity_exports46, {
  identity: () => identity46
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/vendor/varint.js
var encode_124 = encode102;
var MSB26 = 128;
var REST26 = 127;
var MSBALL24 = ~REST26;
var INT24 = Math.pow(2, 31);
function encode102(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT24) {
    out[offset++] = num & 255 | MSB26;
    num /= 128;
  }
  while (num & MSBALL24) {
    out[offset++] = num & 255 | MSB26;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode102.bytes = offset - oldOffset + 1;
  return out;
}
var decode126 = read25;
var MSB$124 = 128;
var REST$124 = 127;
function read25(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read25.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$124) << shift : (b & REST$124) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$124);
  read25.bytes = counter - offset;
  return res;
}
var N125 = Math.pow(2, 7);
var N225 = Math.pow(2, 14);
var N325 = Math.pow(2, 21);
var N425 = Math.pow(2, 28);
var N525 = Math.pow(2, 35);
var N625 = Math.pow(2, 42);
var N725 = Math.pow(2, 49);
var N824 = Math.pow(2, 56);
var N924 = Math.pow(2, 63);
var length26 = function(value) {
  return value < N125 ? 1 : value < N225 ? 2 : value < N325 ? 3 : value < N425 ? 4 : value < N525 ? 5 : value < N625 ? 6 : value < N725 ? 7 : value < N824 ? 8 : value < N924 ? 9 : 10;
};
var varint24 = {
  encode: encode_124,
  decode: decode126,
  encodingLength: length26
};
var _brrp_varint24 = varint24;
var varint_default24 = _brrp_varint24;

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/varint.js
function decode127(data, offset = 0) {
  const code33 = varint_default24.decode(data, offset);
  return [code33, varint_default24.decode.bytes];
}
function encodeTo24(int, target, offset = 0) {
  varint_default24.encode(int, target, offset);
  return target;
}
function encodingLength25(int) {
  return varint_default24.encodingLength(int);
}

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/digest.js
function create26(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength25(code33);
  const digestOffset = sizeOffset + encodingLength25(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo24(code33, bytes3, 0);
  encodeTo24(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest24(code33, size, digest27, bytes3);
}
function decode128(multihash) {
  const bytes3 = coerce27(multihash);
  const [code33, sizeOffset] = decode127(bytes3);
  const [size, digestOffset] = decode127(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest24(code33, size, digest27, bytes3);
}
function equals64(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals63(a.bytes, data.bytes);
  }
}
var Digest24 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/identity.js
var code29 = 0;
var name25 = "identity";
var encode103 = coerce27;
function digest23(input) {
  return create26(code29, encode103(input));
}
var identity46 = { code: code29, name: name25, encode: encode103, digest: digest23 };

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports23 = {};
__export(sha2_browser_exports23, {
  sha256: () => sha25625,
  sha512: () => sha51225
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/hasher.js
function from51({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher24(name29, code33, encode116);
}
var Hasher24 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create26(this.code, result) : result.then((digest27) => create26(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha24(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25625 = from51({
  name: "sha2-256",
  code: 18,
  encode: sha24("SHA-256")
});
var sha51225 = from51({
  name: "sha2-512",
  code: 19,
  encode: sha24("SHA-512")
});

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/cid.js
function format24(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV024(bytes3, baseCache24(link), base45 ?? base58btc26.encoder);
    default:
      return toStringV124(bytes3, baseCache24(link), base45 ?? base3225.encoder);
  }
}
var cache26 = /* @__PURE__ */ new WeakMap();
function baseCache24(cid) {
  const baseCache28 = cache26.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache26.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID24 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE24) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE24) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create26(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals64(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format24(this, base45);
  }
  toJSON() {
    return { "/": format24(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID24(version3, code33, multihash.bytes));
    } else if (value[cidSymbol24] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode128(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE24) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE24}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID24(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE24, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce27(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest24(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode127(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE24;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes24(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache24(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes24(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc26;
      return [
        base58btc26.prefix,
        decoder.decode(`${base58btc26.prefix}${source}`)
      ];
    }
    case base58btc26.prefix: {
      const decoder = base45 ?? base58btc26;
      return [base58btc26.prefix, decoder.decode(source)];
    }
    case base3225.prefix: {
      const decoder = base45 ?? base3225;
      return [base3225.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV024(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc26.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV124(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE24 = 112;
var SHA_256_CODE24 = 18;
function encodeCID24(version3, code33, multihash) {
  const codeOffset = encodingLength25(version3);
  const hashOffset = codeOffset + encodingLength25(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo24(version3, bytes3, 0);
  encodeTo24(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol24 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id-factory/node_modules/multiformats/dist/src/basics.js
var bases23 = { ...identity_exports45, ...base2_exports23, ...base8_exports23, ...base10_exports23, ...base16_exports23, ...base32_exports23, ...base36_exports23, ...base58_exports23, ...base64_exports23, ...base256emoji_exports23 };
var hashes23 = { ...sha2_browser_exports23, ...identity_exports46 };

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe25(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec23(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string23 = createCodec23("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii22 = createCodec23("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe25(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES22 = {
  utf8: string23,
  "utf-8": string23,
  hex: bases23.base16,
  latin1: ascii22,
  ascii: ascii22,
  binary: ascii22,
  ...bases23
};

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = async () => {
  const key = await generateKeyPair4("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return peerIdFromKeys(marshalPublicKey2(privateKey.public), marshalPrivateKey(privateKey));
}

// node_modules/@libp2p/peer-store/node_modules/it-all/dist/src/index.js
function isAsyncIterable30(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all3(source) {
  if (isAsyncIterable30(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default36 = all3;

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports24 = {};
__export(base32_exports24, {
  base32: () => base3226,
  base32hex: () => base32hex26,
  base32hexpad: () => base32hexpad26,
  base32hexpadupper: () => base32hexpadupper26,
  base32hexupper: () => base32hexupper26,
  base32pad: () => base32pad26,
  base32padupper: () => base32padupper26,
  base32upper: () => base32upper26,
  base32z: () => base32z26
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bytes.js
var empty28 = new Uint8Array(0);
function equals65(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce28(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString46(str) {
  return new TextEncoder().encode(str);
}
function toString43(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/base-x.js
function base42(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src27 = base42;
var _brrp__multiformats_scope_baseX27 = src27;
var base_x_default28 = _brrp__multiformats_scope_baseX27;

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base.js
var Encoder29 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder30 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or30(this, decoder);
  }
};
var ComposedDecoder28 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or30(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or30(left, right) {
  return new ComposedDecoder28({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec28 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder29(name29, prefix, baseEncode);
    this.decoder = new Decoder30(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from52({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec28(name29, prefix, encode116, decode144);
}
function baseX27({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default28(alphabet27, name29);
  return from52({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce28(decode144(text))
  });
}
function decode129(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode104(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464828({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from52({
    prefix,
    name: name29,
    encode(input) {
      return encode104(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode129(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base32.js
var base3226 = rfc464828({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper26 = rfc464828({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad26 = rfc464828({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper26 = rfc464828({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex26 = rfc464828({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper26 = rfc464828({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad26 = rfc464828({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper26 = rfc464828({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z26 = rfc464828({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/equals.js
function equals66(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-store/dist/src/errors.js
var codes5 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
};

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer2;
(function(Peer3) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {
            key: "",
            value: new Uint8Array(0)
          };
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader.string();
                break;
              case 2:
                obj.value = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf3) => {
      return decodeMessage(buf3, Peer$metadataEntry2.codec());
    };
  })(Peer$metadataEntry = Peer3.Peer$metadataEntry || (Peer3.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w2.uint32(10);
            w2.string(obj.key);
          }
          if (obj.value != null) {
            w2.uint32(18);
            Tag.codec().encode(obj.value, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length30) => {
          const obj = {
            key: ""
          };
          const end = length30 == null ? reader.len : reader.pos + length30;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader.string();
                break;
              case 2:
                obj.value = Tag.codec().decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf3) => {
      return decodeMessage(buf3, Peer$tagsEntry2.codec());
    };
  })(Peer$tagsEntry = Peer3.Peer$tagsEntry || (Peer3.Peer$tagsEntry = {}));
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w2.uint32(10);
            Address.codec().encode(value, w2);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w2.uint32(18);
            w2.string(value);
          }
        }
        if (obj.publicKey != null) {
          w2.uint32(34);
          w2.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w2.uint32(42);
          w2.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w2.uint32(50);
            Peer3.Peer$metadataEntry.codec().encode({ key, value }, w2);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w2.uint32(58);
            Peer3.Peer$tagsEntry.codec().encode({ key, value }, w2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address.codec().decode(reader, reader.uint32()));
              break;
            case 2:
              obj.protocols.push(reader.string());
              break;
            case 4:
              obj.publicKey = reader.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader.bytes();
              break;
            case 6: {
              const entry = Peer3.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              const entry = Peer3.Peer$tagsEntry.codec().decode(reader, reader.uint32());
              obj.tags.set(entry.key, entry.value);
              break;
            }
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf3) => {
    return decodeMessage(buf3, Peer3.codec());
  };
})(Peer2 || (Peer2 = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w2.uint32(10);
          w2.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w2.uint32(16);
          w2.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader.bytes();
              break;
            case 2:
              obj.isCertified = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf3) => {
    return decodeMessage(buf3, Address2.codec());
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w2.uint32(8);
          w2.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w2.uint32(16);
          w2.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length30) => {
        const obj = {
          value: 0
        };
        const end = length30 == null ? reader.len : reader.pos + length30;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader.uint32();
              break;
            case 2:
              obj.expiry = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf3) => {
    return decodeMessage(buf3, Tag2.codec());
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function bytesToPeer(peerId2, buf3) {
  const peer = Peer2.decode(buf3);
  if (peer.publicKey != null && peerId2.publicKey == null) {
    peerId2 = peerIdFromPeerId({
      ...peerId2,
      publicKey: peerId2.publicKey
    });
  }
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: peerId2,
    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports24 = {};
__export(base10_exports24, {
  base10: () => base1024
});
var base1024 = baseX27({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports24 = {};
__export(base16_exports24, {
  base16: () => base1624,
  base16upper: () => base16upper24
});
var base1624 = rfc464828({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper24 = rfc464828({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports24 = {};
__export(base2_exports24, {
  base2: () => base224
});
var base224 = rfc464828({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports24 = {};
__export(base256emoji_exports24, {
  base256emoji: () => base256emoji24
});
var alphabet24 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars24 = alphabet24.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes24 = alphabet24.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode105(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars24[c];
    return p;
  }, "");
}
function decode130(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes24[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji24 = from52({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode105,
  decode: decode130
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports24 = {};
__export(base36_exports24, {
  base36: () => base3624,
  base36upper: () => base36upper24
});
var base3624 = baseX27({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper24 = baseX27({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports24 = {};
__export(base58_exports24, {
  base58btc: () => base58btc27,
  base58flickr: () => base58flickr27
});
var base58btc27 = baseX27({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr27 = baseX27({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports24 = {};
__export(base64_exports24, {
  base64: () => base6427,
  base64pad: () => base64pad27,
  base64url: () => base64url27,
  base64urlpad: () => base64urlpad27
});
var base6427 = rfc464828({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad27 = rfc464828({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url27 = rfc464828({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad27 = rfc464828({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports24 = {};
__export(base8_exports24, {
  base8: () => base824
});
var base824 = rfc464828({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports47 = {};
__export(identity_exports47, {
  identity: () => identity47
});
var identity47 = from52({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString43(buf3),
  decode: (str) => fromString46(str)
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder28 = new TextEncoder();
var textDecoder27 = new TextDecoder();

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports48 = {};
__export(identity_exports48, {
  identity: () => identity48
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/varint.js
var encode_125 = encode106;
var MSB27 = 128;
var REST27 = 127;
var MSBALL25 = ~REST27;
var INT25 = Math.pow(2, 31);
function encode106(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT25) {
    out[offset++] = num & 255 | MSB27;
    num /= 128;
  }
  while (num & MSBALL25) {
    out[offset++] = num & 255 | MSB27;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode106.bytes = offset - oldOffset + 1;
  return out;
}
var decode131 = read26;
var MSB$125 = 128;
var REST$125 = 127;
function read26(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read26.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$125) << shift : (b & REST$125) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$125);
  read26.bytes = counter - offset;
  return res;
}
var N126 = Math.pow(2, 7);
var N226 = Math.pow(2, 14);
var N326 = Math.pow(2, 21);
var N426 = Math.pow(2, 28);
var N526 = Math.pow(2, 35);
var N626 = Math.pow(2, 42);
var N726 = Math.pow(2, 49);
var N825 = Math.pow(2, 56);
var N925 = Math.pow(2, 63);
var length27 = function(value) {
  return value < N126 ? 1 : value < N226 ? 2 : value < N326 ? 3 : value < N426 ? 4 : value < N526 ? 5 : value < N626 ? 6 : value < N726 ? 7 : value < N825 ? 8 : value < N925 ? 9 : 10;
};
var varint25 = {
  encode: encode_125,
  decode: decode131,
  encodingLength: length27
};
var _brrp_varint25 = varint25;
var varint_default25 = _brrp_varint25;

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/varint.js
function decode132(data, offset = 0) {
  const code33 = varint_default25.decode(data, offset);
  return [code33, varint_default25.decode.bytes];
}
function encodeTo25(int, target, offset = 0) {
  varint_default25.encode(int, target, offset);
  return target;
}
function encodingLength26(int) {
  return varint_default25.encodingLength(int);
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/digest.js
function create27(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength26(code33);
  const digestOffset = sizeOffset + encodingLength26(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo25(code33, bytes3, 0);
  encodeTo25(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest25(code33, size, digest27, bytes3);
}
function decode133(multihash) {
  const bytes3 = coerce28(multihash);
  const [code33, sizeOffset] = decode132(bytes3);
  const [size, digestOffset] = decode132(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest25(code33, size, digest27, bytes3);
}
function equals67(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals65(a.bytes, data.bytes);
  }
}
var Digest25 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/identity.js
var code30 = 0;
var name26 = "identity";
var encode107 = coerce28;
function digest24(input) {
  return create27(code30, encode107(input));
}
var identity48 = { code: code30, name: name26, encode: encode107, digest: digest24 };

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports24 = {};
__export(sha2_browser_exports24, {
  sha256: () => sha25626,
  sha512: () => sha51226
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/hasher.js
function from53({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher25(name29, code33, encode116);
}
var Hasher25 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create27(this.code, result) : result.then((digest27) => create27(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha25(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25626 = from53({
  name: "sha2-256",
  code: 18,
  encode: sha25("SHA-256")
});
var sha51226 = from53({
  name: "sha2-512",
  code: 19,
  encode: sha25("SHA-512")
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/cid.js
function format25(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV025(bytes3, baseCache25(link), base45 ?? base58btc27.encoder);
    default:
      return toStringV125(bytes3, baseCache25(link), base45 ?? base3226.encoder);
  }
}
var cache27 = /* @__PURE__ */ new WeakMap();
function baseCache25(cid) {
  const baseCache28 = cache27.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache27.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID25 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE25) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE25) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create27(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals67(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format25(this, base45);
  }
  toJSON() {
    return { "/": format25(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID25(version3, code33, multihash.bytes));
    } else if (value[cidSymbol25] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode133(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE25) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE25}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID25(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE25, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce28(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest25(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode132(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE25;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes25(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache25(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes25(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc27;
      return [
        base58btc27.prefix,
        decoder.decode(`${base58btc27.prefix}${source}`)
      ];
    }
    case base58btc27.prefix: {
      const decoder = base45 ?? base58btc27;
      return [base58btc27.prefix, decoder.decode(source)];
    }
    case base3226.prefix: {
      const decoder = base45 ?? base3226;
      return [base3226.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV025(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc27.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV125(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE25 = 112;
var SHA_256_CODE25 = 18;
function encodeCID25(version3, code33, multihash) {
  const codeOffset = encodingLength26(version3);
  const hashOffset = codeOffset + encodingLength26(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo25(version3, bytes3, 0);
  encodeTo25(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol25 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/basics.js
var bases24 = { ...identity_exports47, ...base2_exports24, ...base8_exports24, ...base10_exports24, ...base16_exports24, ...base32_exports24, ...base36_exports24, ...base58_exports24, ...base64_exports24, ...base256emoji_exports24 };
var hashes24 = { ...sha2_browser_exports24, ...identity_exports48 };

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe26(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec24(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string24 = createCodec24("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii23 = createCodec24("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe26(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES23 = {
  utf8: string24,
  "utf-8": string24,
  hex: bases24.base16,
  latin1: ascii23,
  ascii: ascii23,
  binary: ascii23,
  ...bases24
};
var bases_default23 = BASES23;

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/from-string.js
function fromString47(string27, encoding = "utf8") {
  const base45 = bases_default23[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/to-string.js
function toString44(array, encoding = "utf8") {
  const base45 = bases_default23[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/peer-store/node_modules/interface-datastore/dist/src/key.js
var pathSepS7 = "/";
var pathSepB7 = new TextEncoder().encode(pathSepS7);
var pathSep7 = pathSepB7[0];
var Key7 = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString47(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep7) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString44(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS7));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB7;
    }
    if (this._buf[0] !== pathSep7) {
      const bytes3 = new Uint8Array(this._buf.byteLength + 1);
      bytes3.fill(pathSep7, 0, 1);
      bytes3.set(this._buf, 1);
      this._buf = bytes3;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep7) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS7).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType6(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue6(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS7)) {
      p += pathSepS7;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS7);
    }
    return new _Key(list.slice(0, -1).join(pathSepS7));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS7) {
      return key;
    } else if (key.toString() === pathSepS7) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten6(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType6(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue6(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten6(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId2) {
  if (!isPeerId(peerId2) || peerId2.type == null) {
    throw new CodeError("Invalid PeerId", codes5.ERR_INVALID_PARAMETERS);
  }
  const b32key = peerId2.toCID().toString();
  return new Key7(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId2, filter3, addresses) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new CodeError("Multiaddr was invalid", codes5.ERR_INVALID_PARAMETERS);
    }
    if (!await filter3(peerId2, addr.multiaddr)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
    isCertified,
    multiaddr: multiaddr2.bytes
  }));
}

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId2, data, strategy, options2) {
  if (data == null) {
    throw new CodeError("Invalid PeerData", codes5.ERR_INVALID_PARAMETERS);
  }
  if (data.publicKey != null && peerId2.publicKey != null && !equals66(data.publicKey, peerId2.publicKey)) {
    throw new CodeError("publicKey bytes do not match peer id publicKey bytes", codes5.ERR_INVALID_PARAMETERS);
  }
  const existingPeer = options2.existingPeer;
  if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
    throw new CodeError("peer id did not match existing peer id", codes5.ERR_INVALID_PARAMETERS);
  }
  let addresses = existingPeer?.addresses ?? [];
  let protocols = new Set(existingPeer?.protocols ?? []);
  let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
  let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope = existingPeer?.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  const output3 = {
    addresses: await dedupeFilterAndSortAddresses(peerId2, options2.addressFilter ?? (async () => true), addresses),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId2.publicKey,
    peerRecordEnvelope
  };
  if (peerId2.type !== "RSA") {
    delete output3.publicKey;
  }
  return output3;
}
function createSortedMap(entries, options2) {
  const output3 = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options2.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output3.set(key, options2.map?.(key, value) ?? value);
    }
  }
  return output3;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new CodeError("Metadata key must be a string", codes5.ERR_INVALID_PARAMETERS);
  }
  if (!(value instanceof Uint8Array)) {
    throw new CodeError("Metadata value must be a Uint8Array", codes5.ERR_INVALID_PARAMETERS);
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new CodeError("Tag name must be a string", codes5.ERR_INVALID_PARAMETERS);
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new CodeError("Tag value must be an integer", codes5.ERR_INVALID_PARAMETERS);
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new CodeError("Tag value must be between 0-100", codes5.ERR_INVALID_PARAMETERS);
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new CodeError("Tag ttl must be an integer", codes5.ERR_INVALID_PARAMETERS);
    }
    if (tag.ttl < 0) {
      throw new CodeError("Tag ttl must be between greater than 0", codes5.ERR_INVALID_PARAMETERS);
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  return {
    value: tag.value ?? 0,
    expiry
  };
}

// node_modules/@libp2p/peer-store/dist/src/store.js
function decodePeer(key, value, cache30) {
  const base32Str = key.toString().split("/")[2];
  const buf3 = base3226.decode(base32Str);
  const peerId2 = peerIdFromBytes(buf3);
  const cached = cache30.get(peerId2);
  if (cached != null) {
    return cached;
  }
  const peer = bytesToPeer(peerId2, value);
  cache30.set(peerId2, peer);
  return peer;
}
function mapQuery(query, cache30) {
  if (query == null) {
    return {};
  }
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, cache30));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, cache30), decodePeer(b.key, b.value, cache30));
    })
  };
}
var PersistentStore = class {
  peerId;
  datastore;
  lock;
  addressFilter;
  constructor(components, init = {}) {
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  async has(peerId2) {
    return this.datastore.has(peerIdToDatastoreKey(peerId2));
  }
  async delete(peerId2) {
    if (this.peerId.equals(peerId2)) {
      throw new CodeError("Cannot delete self peer", codes5.ERR_INVALID_PARAMETERS);
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId2));
  }
  async load(peerId2) {
    const buf3 = await this.datastore.get(peerIdToDatastoreKey(peerId2));
    return bytesToPeer(peerId2, buf3);
  }
  async save(peerId2, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      addressFilter: this.addressFilter
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingBuf, existingPeer);
  }
  async patch(peerId2, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingBuf, existingPeer);
  }
  async merge(peerId2, data) {
    const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId2);
    const peerPb = await toPeerPB(peerId2, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingBuf, existingPeer);
  }
  async *all(query) {
    const peerCache = new PeerMap();
    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {
      const peer = decodePeer(key, value, peerCache);
      if (peer.id.equals(this.peerId)) {
        continue;
      }
      yield peer;
    }
  }
  async #findExistingPeer(peerId2) {
    try {
      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId2));
      const existingPeer = bytesToPeer(peerId2, existingBuf);
      return {
        existingBuf,
        existingPeer
      };
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    return {};
  }
  async #saveIfDifferent(peerId2, peer, existingBuf, existingPeer) {
    const buf3 = Peer2.encode(peer);
    if (existingBuf != null && equals66(buf3, existingBuf)) {
      return {
        peer: bytesToPeer(peerId2, buf3),
        previous: existingPeer,
        updated: false
      };
    }
    await this.datastore.put(peerIdToDatastoreKey(peerId2), buf3);
    return {
      peer: bytesToPeer(peerId2, buf3),
      previous: existingPeer,
      updated: true
    };
  }
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var PersistentPeerStore = class {
  store;
  events;
  peerId;
  log;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  [Symbol.toStringTag] = "@libp2p/peer-store";
  async forEach(fn, query) {
    this.log.trace("forEach await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("forEach got read lock");
    try {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    } finally {
      this.log.trace("forEach release read lock");
      release();
    }
  }
  async all(query) {
    this.log.trace("all await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("all got read lock");
    try {
      return await src_default36(this.store.all(query));
    } finally {
      this.log.trace("all release read lock");
      release();
    }
  }
  async delete(peerId2) {
    this.log.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("delete got write lock");
    try {
      await this.store.delete(peerId2);
    } finally {
      this.log.trace("delete release write lock");
      release();
    }
  }
  async has(peerId2) {
    this.log.trace("has await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("has got read lock");
    try {
      return await this.store.has(peerId2);
    } finally {
      this.log.trace("has release read lock");
      release();
    }
  }
  async get(peerId2) {
    this.log.trace("get await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("get got read lock");
    try {
      return await this.store.load(peerId2);
    } finally {
      this.log.trace("get release read lock");
      release();
    }
  }
  async save(id, data) {
    this.log.trace("save await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("save got write lock");
    try {
      const result = await this.store.save(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      this.log.trace("save release write lock");
      release();
    }
  }
  async patch(id, data) {
    this.log.trace("patch await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("patch got write lock");
    try {
      const result = await this.store.patch(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      this.log.trace("patch release write lock");
      release();
    }
  }
  async merge(id, data) {
    this.log.trace("merge await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("merge got write lock");
    try {
      const result = await this.store.merge(id, data);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      this.log.trace("merge release write lock");
      release();
    }
  }
  async consumePeerRecord(buf3, expectedPeer) {
    const envelope = await RecordEnvelope.openAndCertify(buf3, PeerRecord2.DOMAIN);
    if (expectedPeer?.equals(envelope.peerId) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, envelope.peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(envelope.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (peer?.peerRecordEnvelope != null) {
      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf3,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    });
    return true;
  }
  #emitIfUpdated(id, result) {
    if (!result.updated) {
      return;
    }
    if (this.peerId.equals(id)) {
      this.events.safeDispatchEvent("self:peer:update", { detail: result });
    } else {
      this.events.safeDispatchEvent("peer:update", { detail: result });
    }
  }
};

// node_modules/libp2p/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe27(size = 0) {
  return new Uint8Array(size);
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array9(buf3) {
  return buf3;
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/concat.js
function concat12(arrays, length30) {
  if (length30 == null) {
    length30 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output3 = allocUnsafe27(length30);
  let offset = 0;
  for (const arr of arrays) {
    output3.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array9(output3);
}

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports25 = {};
__export(base10_exports25, {
  base10: () => base1025
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bytes.js
var empty29 = new Uint8Array(0);
function equals68(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce29(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString48(str) {
  return new TextEncoder().encode(str);
}
function toString45(b) {
  return new TextDecoder().decode(b);
}

// node_modules/libp2p/node_modules/multiformats/dist/src/vendor/base-x.js
function base43(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src28 = base43;
var _brrp__multiformats_scope_baseX28 = src28;
var base_x_default29 = _brrp__multiformats_scope_baseX28;

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base.js
var Encoder30 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder31 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or31(this, decoder);
  }
};
var ComposedDecoder29 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or31(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or31(left, right) {
  return new ComposedDecoder29({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec29 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder30(name29, prefix, baseEncode);
    this.decoder = new Decoder31(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from54({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec29(name29, prefix, encode116, decode144);
}
function baseX28({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default29(alphabet27, name29);
  return from54({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce29(decode144(text))
  });
}
function decode134(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode108(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464829({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from54({
    prefix,
    name: name29,
    encode(input) {
      return encode108(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode134(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base10.js
var base1025 = baseX28({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports25 = {};
__export(base16_exports25, {
  base16: () => base1625,
  base16upper: () => base16upper25
});
var base1625 = rfc464829({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper25 = rfc464829({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports25 = {};
__export(base2_exports25, {
  base2: () => base225
});
var base225 = rfc464829({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports25 = {};
__export(base256emoji_exports25, {
  base256emoji: () => base256emoji25
});
var alphabet25 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars25 = alphabet25.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes25 = alphabet25.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode109(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars25[c];
    return p;
  }, "");
}
function decode135(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes25[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji25 = from54({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode109,
  decode: decode135
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports25 = {};
__export(base32_exports25, {
  base32: () => base3227,
  base32hex: () => base32hex27,
  base32hexpad: () => base32hexpad27,
  base32hexpadupper: () => base32hexpadupper27,
  base32hexupper: () => base32hexupper27,
  base32pad: () => base32pad27,
  base32padupper: () => base32padupper27,
  base32upper: () => base32upper27,
  base32z: () => base32z27
});
var base3227 = rfc464829({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper27 = rfc464829({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad27 = rfc464829({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper27 = rfc464829({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex27 = rfc464829({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper27 = rfc464829({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad27 = rfc464829({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper27 = rfc464829({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z27 = rfc464829({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports25 = {};
__export(base36_exports25, {
  base36: () => base3625,
  base36upper: () => base36upper25
});
var base3625 = baseX28({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper25 = baseX28({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports25 = {};
__export(base58_exports25, {
  base58btc: () => base58btc28,
  base58flickr: () => base58flickr28
});
var base58btc28 = baseX28({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr28 = baseX28({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports25 = {};
__export(base64_exports25, {
  base64: () => base6428,
  base64pad: () => base64pad28,
  base64url: () => base64url28,
  base64urlpad: () => base64urlpad28
});
var base6428 = rfc464829({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad28 = rfc464829({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url28 = rfc464829({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad28 = rfc464829({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports25 = {};
__export(base8_exports25, {
  base8: () => base825
});
var base825 = rfc464829({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/libp2p/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports49 = {};
__export(identity_exports49, {
  identity: () => identity49
});
var identity49 = from54({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString45(buf3),
  decode: (str) => fromString48(str)
});

// node_modules/libp2p/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder29 = new TextEncoder();
var textDecoder28 = new TextDecoder();

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports50 = {};
__export(identity_exports50, {
  identity: () => identity50
});

// node_modules/libp2p/node_modules/multiformats/dist/src/vendor/varint.js
var encode_126 = encode110;
var MSB28 = 128;
var REST28 = 127;
var MSBALL26 = ~REST28;
var INT26 = Math.pow(2, 31);
function encode110(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT26) {
    out[offset++] = num & 255 | MSB28;
    num /= 128;
  }
  while (num & MSBALL26) {
    out[offset++] = num & 255 | MSB28;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode110.bytes = offset - oldOffset + 1;
  return out;
}
var decode136 = read27;
var MSB$126 = 128;
var REST$126 = 127;
function read27(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read27.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$126) << shift : (b & REST$126) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$126);
  read27.bytes = counter - offset;
  return res;
}
var N127 = Math.pow(2, 7);
var N227 = Math.pow(2, 14);
var N327 = Math.pow(2, 21);
var N427 = Math.pow(2, 28);
var N527 = Math.pow(2, 35);
var N627 = Math.pow(2, 42);
var N727 = Math.pow(2, 49);
var N826 = Math.pow(2, 56);
var N926 = Math.pow(2, 63);
var length28 = function(value) {
  return value < N127 ? 1 : value < N227 ? 2 : value < N327 ? 3 : value < N427 ? 4 : value < N527 ? 5 : value < N627 ? 6 : value < N727 ? 7 : value < N826 ? 8 : value < N926 ? 9 : 10;
};
var varint26 = {
  encode: encode_126,
  decode: decode136,
  encodingLength: length28
};
var _brrp_varint26 = varint26;
var varint_default26 = _brrp_varint26;

// node_modules/libp2p/node_modules/multiformats/dist/src/varint.js
function decode137(data, offset = 0) {
  const code33 = varint_default26.decode(data, offset);
  return [code33, varint_default26.decode.bytes];
}
function encodeTo26(int, target, offset = 0) {
  varint_default26.encode(int, target, offset);
  return target;
}
function encodingLength27(int) {
  return varint_default26.encodingLength(int);
}

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/digest.js
function create28(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength27(code33);
  const digestOffset = sizeOffset + encodingLength27(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo26(code33, bytes3, 0);
  encodeTo26(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest26(code33, size, digest27, bytes3);
}
function decode138(multihash) {
  const bytes3 = coerce29(multihash);
  const [code33, sizeOffset] = decode137(bytes3);
  const [size, digestOffset] = decode137(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest26(code33, size, digest27, bytes3);
}
function equals69(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals68(a.bytes, data.bytes);
  }
}
var Digest26 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/identity.js
var code31 = 0;
var name27 = "identity";
var encode111 = coerce29;
function digest25(input) {
  return create28(code31, encode111(input));
}
var identity50 = { code: code31, name: name27, encode: encode111, digest: digest25 };

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports25 = {};
__export(sha2_browser_exports25, {
  sha256: () => sha25627,
  sha512: () => sha51227
});

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/hasher.js
function from55({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher26(name29, code33, encode116);
}
var Hasher26 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create28(this.code, result) : result.then((digest27) => create28(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/libp2p/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha26(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25627 = from55({
  name: "sha2-256",
  code: 18,
  encode: sha26("SHA-256")
});
var sha51227 = from55({
  name: "sha2-512",
  code: 19,
  encode: sha26("SHA-512")
});

// node_modules/libp2p/node_modules/multiformats/dist/src/cid.js
function format26(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV026(bytes3, baseCache26(link), base45 ?? base58btc28.encoder);
    default:
      return toStringV126(bytes3, baseCache26(link), base45 ?? base3227.encoder);
  }
}
var cache28 = /* @__PURE__ */ new WeakMap();
function baseCache26(cid) {
  const baseCache28 = cache28.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache28.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID26 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE26) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE26) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create28(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals69(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format26(this, base45);
  }
  toJSON() {
    return { "/": format26(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID26(version3, code33, multihash.bytes));
    } else if (value[cidSymbol26] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode138(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE26) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE26}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID26(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE26, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce29(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest26(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode137(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE26;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes26(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache26(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes26(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc28;
      return [
        base58btc28.prefix,
        decoder.decode(`${base58btc28.prefix}${source}`)
      ];
    }
    case base58btc28.prefix: {
      const decoder = base45 ?? base58btc28;
      return [base58btc28.prefix, decoder.decode(source)];
    }
    case base3227.prefix: {
      const decoder = base45 ?? base3227;
      return [base3227.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV026(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc28.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV126(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE26 = 112;
var SHA_256_CODE26 = 18;
function encodeCID26(version3, code33, multihash) {
  const codeOffset = encodingLength27(version3);
  const hashOffset = codeOffset + encodingLength27(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo26(version3, bytes3, 0);
  encodeTo26(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol26 = Symbol.for("@ipld/js-cid/CID");

// node_modules/libp2p/node_modules/multiformats/dist/src/basics.js
var bases25 = { ...identity_exports49, ...base2_exports25, ...base8_exports25, ...base10_exports25, ...base16_exports25, ...base32_exports25, ...base36_exports25, ...base58_exports25, ...base64_exports25, ...base256emoji_exports25 };
var hashes25 = { ...sha2_browser_exports25, ...identity_exports50 };

// node_modules/libp2p/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec25(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string25 = createCodec25("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii24 = createCodec25("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe27(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES24 = {
  utf8: string25,
  "utf-8": string25,
  hex: bases25.base16,
  latin1: ascii24,
  ascii: ascii24,
  binary: ascii24,
  ...bases25
};
var bases_default24 = BASES24;

// node_modules/libp2p/node_modules/uint8arrays/dist/src/from-string.js
function fromString49(string27, encoding = "utf8") {
  const base45 = bases_default24[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/libp2p/dist/src/address-manager/utils.js
function debounce2(func2, wait) {
  let timeout;
  return function() {
    const later = function() {
      timeout = void 0;
      func2();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// node_modules/libp2p/dist/src/address-manager/index.js
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId2) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId2)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
    }
  }
  return ma;
}
var DefaultAddressManager = class {
  log;
  components;
  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
  listen;
  announce;
  observed;
  announceFilter;
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Map();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this._updatePeerStoreAddresses = debounce2(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  [Symbol.toStringTag] = "@libp2p/address-manager";
  _updatePeerStoreAddresses() {
    const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([_, metadata]) => metadata.confident).map(([str]) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return Array.from(this.observed).map(([a]) => multiaddr(a));
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.set(addrString, {
      confident: false
    });
  }
  confirmObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    const metadata = this.observed.get(addrString) ?? {
      confident: false
    };
    const startingConfidence = metadata.confident;
    this.observed.set(addrString, {
      confident: true
    });
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    this.observed.delete(addrString);
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata]) => metadata.confident).map(([ma]) => ma));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.protos().pop()?.path === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
};

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  components = {};
  _started = false;
  constructor(init = {}) {
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable[methodName]?.();
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new CodeError(`${prop} not set`, "ERR_SERVICE_MISSING");
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new CodeError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`, "ERR_UNMET_SERVICE_DEPENDENCIES");
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service?.[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service?.[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
}

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === 4 || tuples[0][0] === 41) {
        return Boolean(isPrivateIp(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    const { address } = ma.nodeAddress();
    return Boolean(isPrivateIp(address));
  } catch {
    return true;
  }
}

// node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit.exactMatch(a.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSort(a, b) {
  const publicResult = publicAddressesFirst(a, b);
  if (publicResult !== 0) {
    return publicResult;
  }
  const relayResult = circuitRelayAddressesLast(a, b);
  if (relayResult !== 0) {
    return relayResult;
  }
  const certifiedResult = certifiedAddressesFirst(a, b);
  return certifiedResult;
}

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
var MAX_RECURSIVE_DEPTH = 32;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
var dnsaddrResolver = async function dnsaddrResolver2(ma, options2 = {}) {
  const recursionLimit = options2.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
  if (recursionLimit === 0) {
    throw new CodeError("Max recursive depth reached", "ERR_MAX_RECURSIVE_DEPTH_REACHED");
  }
  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  const resolver = options2?.dns ?? dns();
  const result = await resolver.query(`_dnsaddr.${hostname}`, {
    signal: options2?.signal,
    types: [
      RecordType.TXT
    ]
  });
  const peerId2 = ma.getPeerId();
  const output3 = [];
  for (const answer of result.Answer) {
    const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
    if (addr == null) {
      continue;
    }
    if (peerId2 != null && !addr.includes(peerId2)) {
      continue;
    }
    const ma2 = multiaddr(addr);
    if (addr.startsWith("/dnsaddr")) {
      const resolved = await ma2.resolve({
        ...options2,
        maxRecursiveDepth: recursionLimit - 1
      });
      output3.push(...resolved.map((ma3) => ma3.toString()));
    } else {
      output3.push(ma2.toString());
    }
  }
  return output3;
};

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes6;
(function(codes7) {
  codes7["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes7["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes7["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes7["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes7["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes7["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes7["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes7["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes7["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes7["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes7["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes7["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes7["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes7["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes7["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes7["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes7["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes7["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes7["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes7["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes7["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes7["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes7["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes7["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes7["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes7["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes7["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes7["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes7["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes7["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes7["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes7["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes7["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes7["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes7["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes7["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes7["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes7["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes7["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes7["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes7["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes7["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes7["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes7["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes7["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes7["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes7["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes7["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes7["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes7["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes7["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes7["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes7["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes7["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes7["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes7["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes7["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes7["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
  codes7["ERR_TRANSFER_LIMIT_EXCEEDED"] = "ERR_TRANSFER_LIMIT_EXCEEDED";
})(codes6 || (codes6 = {}));

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: defaultAddressSort
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
async function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes6.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.privateKey != null && !(await peerIdFromKeys(resultingOptions.privateKey.public.bytes, resultingOptions.privateKey.bytes)).equals(resultingOptions.peerId)) {
    throw new CodeError("Private key doesn't match peer id", codes6.ERR_INVALID_KEY);
  }
  return resultingOptions;
}

// node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  if (!Array.isArray(peer)) {
    peer = [peer];
  }
  let peerId2;
  if (peer.length > 0) {
    const peerIdStr = peer[0].getPeerId();
    peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    peer.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new CodeError("Invalid Multiaddr", codes6.ERR_INVALID_MULTIADDR);
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId2 != null) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes6.ERR_INVALID_PARAMETERS);
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if (peerId2?.equals(maPeerId) !== true) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes6.ERR_INVALID_PARAMETERS);
        }
      }
    });
  }
  return {
    peerId: peerId2,
    multiaddrs: peer
  };
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/to-string.js
function toString46(array, encoding = "utf8") {
  const base45 = bases_default24[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 5e3;
var INBOUND_UPGRADE_TIMEOUT = 2e3;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var AUTO_DIAL_INTERVAL = 5e3;
var AUTO_DIAL_CONCURRENCY = 25;
var AUTO_DIAL_PRIORITY = 0;
var AUTO_DIAL_MAX_QUEUE_LENGTH = 100;
var AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var MAX_DIAL_QUEUE_LENGTH = 500;

// node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MIN_CONNECTIONS = 5;
var MAX_CONNECTIONS2 = 100;
var MAX_PARALLEL_DIALS = 50;
var AUTO_DIAL_PEER_RETRY_THRESHOLD = 1e3 * 60 * 7;

// node_modules/libp2p/dist/src/connection-manager/auto-dial.js
var defaultOptions4 = {
  minConnections: MIN_CONNECTIONS,
  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialInterval: AUTO_DIAL_INTERVAL,
  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,
  autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE
};
var AutoDial = class {
  connectionManager;
  peerStore;
  queue;
  minConnections;
  autoDialPriority;
  autoDialIntervalMs;
  autoDialMaxQueueLength;
  autoDialPeerRetryThresholdMs;
  autoDialDiscoveredPeersDebounce;
  autoDialInterval;
  started;
  running;
  log;
  /**
   * Proactively tries to connect to known peers stored in the PeerStore.
   * It will keep the number of connections below the upper limit and sort
   * the peers to connect based on whether we know their keys and protocols.
   */
  constructor(components, init) {
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.minConnections = init.minConnections ?? defaultOptions4.minConnections;
    this.autoDialPriority = init.autoDialPriority ?? defaultOptions4.autoDialPriority;
    this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions4.autoDialInterval;
    this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions4.maxQueueLength;
    this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions4.autoDialPeerRetryThreshold;
    this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions4.autoDialDiscoveredPeersDebounce;
    this.log = components.logger.forComponent("libp2p:connection-manager:auto-dial");
    this.started = false;
    this.running = false;
    this.queue = new PeerQueue({
      concurrency: init.autoDialConcurrency ?? defaultOptions4.autoDialConcurrency,
      metricName: "libp2p_autodial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (evt) => {
      this.log.error("error during auto-dial", evt.detail);
    });
    components.events.addEventListener("connection:close", () => {
      this.autoDial().catch((err) => {
        this.log.error(err);
      });
    });
    let debounce3;
    components.events.addEventListener("peer:discovery", () => {
      clearTimeout(debounce3);
      debounce3 = setTimeout(() => {
        this.autoDial().catch((err) => {
          this.log.error(err);
        });
      }, this.autoDialDiscoveredPeersDebounce);
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    this.autoDial().catch((err) => {
      this.log.error("error while autodialing", err);
    });
  }
  stop() {
    this.queue.clear();
    clearTimeout(this.autoDialInterval);
    this.started = false;
    this.running = false;
  }
  async autoDial() {
    if (!this.started || this.running) {
      return;
    }
    const connections = this.connectionManager.getConnectionsMap();
    const numConnections = connections.size;
    if (numConnections >= this.minConnections) {
      if (this.minConnections > 0) {
        this.log.trace("have enough connections %d/%d", numConnections, this.minConnections);
      }
      return;
    }
    if (this.queue.size > this.autoDialMaxQueueLength) {
      this.log("not enough connections %d/%d but auto dial queue is full", numConnections, this.minConnections);
      this.sheduleNextAutodial();
      return;
    }
    this.running = true;
    this.log("not enough connections %d/%d - will dial peers to increase the number of connections", numConnections, this.minConnections);
    const dialQueue = new PeerSet(
      // @ts-expect-error boolean filter removes falsy peer IDs
      this.connectionManager.getDialQueue().map((queue) => queue.peerId).filter(Boolean)
    );
    const peers = await this.peerStore.all({
      filters: [
        // remove some peers
        (peer) => {
          if (peer.addresses.length === 0) {
            this.log.trace("not autodialing %p because they have no addresses", peer.id);
            return false;
          }
          if (connections.has(peer.id)) {
            this.log.trace("not autodialing %p because they are already connected", peer.id);
            return false;
          }
          if (dialQueue.has(peer.id)) {
            this.log.trace("not autodialing %p because they are already being dialed", peer.id);
            return false;
          }
          if (this.queue.has(peer.id)) {
            this.log.trace("not autodialing %p because they are already being autodialed", peer.id);
            return false;
          }
          return true;
        }
      ]
    });
    const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);
    const peerValues = new PeerMap();
    for (const peer of shuffledPeers) {
      if (peerValues.has(peer.id)) {
        continue;
      }
      peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedPeers = shuffledPeers.sort((a, b) => {
      const peerAValue = peerValues.get(a.id) ?? 0;
      const peerBValue = peerValues.get(b.id) ?? 0;
      if (peerAValue > peerBValue) {
        return -1;
      }
      if (peerAValue < peerBValue) {
        return 1;
      }
      return 0;
    });
    const peersThatHaveNotFailed = sortedPeers.filter((peer) => {
      const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY);
      if (lastDialFailure == null) {
        return true;
      }
      const lastDialFailureTimestamp = parseInt(toString46(lastDialFailure));
      if (isNaN(lastDialFailureTimestamp)) {
        return true;
      }
      return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;
    });
    this.log("selected %d/%d peers to dial", peersThatHaveNotFailed.length, peers.length);
    for (const peer of peersThatHaveNotFailed) {
      this.queue.add(async () => {
        const numConnections2 = this.connectionManager.getConnectionsMap().size;
        if (numConnections2 >= this.minConnections) {
          this.log("got enough connections now %d/%d", numConnections2, this.minConnections);
          this.queue.clear();
          return;
        }
        this.log("connecting to a peerStore stored peer %p", peer.id);
        await this.connectionManager.openConnection(peer.id, {
          priority: this.autoDialPriority
        });
      }, {
        peerId: peer.id
      }).catch((err) => {
        this.log.error("could not connect to peerStore stored peer", err);
      });
    }
    this.running = false;
    this.sheduleNextAutodial();
  }
  sheduleNextAutodial() {
    if (!this.started) {
      return;
    }
    this.autoDialInterval = setTimeout(() => {
      this.autoDial().catch((err) => {
        this.log.error("error while autodialing", err);
      });
    }, this.autoDialIntervalMs);
  }
};

// node_modules/@libp2p/utils/dist/src/close.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options2) {
  const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
  const closableProtocols = options2?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await connection?.close(options2);
  } catch (err) {
    connection?.abort(err);
  }
}

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var defaultOptions5 = {
  maxConnections: MAX_CONNECTIONS2,
  allow: []
};
var ConnectionPruner = class {
  maxConnections;
  connectionManager;
  peerStore;
  allow;
  events;
  log;
  constructor(components, init = {}) {
    this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
    this.allow = init.allow ?? defaultOptions5.allow;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    components.events.addEventListener("connection:open", () => {
      this.maybePruneConnections().catch((err) => {
        this.log.error(err);
      });
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    this.log("checking max connections limit %d/%d", numConnections, this.maxConnections);
    if (numConnections <= this.maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          this.log.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - this.maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ma) => {
        return connection.remoteAddr.toString().startsWith(ma.toString());
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a, b) => {
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.streams.length > b.streams.length) {
        return 1;
      }
      if (a.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue2 = class extends Queue {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a, b) => {
        if (a.options.priority > b.options.priority) {
          return -1;
        }
        if (a.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// node_modules/libp2p/node_modules/any-signal/dist/src/index.js
function anySignal7(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/libp2p/dist/src/connection-manager/utils.js
async function resolveMultiaddrs(ma, options2) {
  let resolvable = false;
  for (const key of resolvers.keys()) {
    resolvable = ma.protoNames().includes(key);
    if (resolvable) {
      break;
    }
  }
  if (!resolvable) {
    return [ma];
  }
  const output3 = await ma.resolve(options2);
  options2.log("resolved %s to", ma, output3.map((ma2) => ma2.toString()));
  return output3;
}

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions6 = {
  addressSorter: defaultAddressSort,
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  queue;
  components;
  addressSorter;
  maxPeerAddrsToDial;
  maxDialQueueLength;
  dialTimeout;
  shutDownController;
  connections;
  log;
  constructor(components, init = {}) {
    this.addressSorter = init.addressSorter ?? defaultOptions6.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions6.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions6.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions6.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.shutDownController = new AbortController();
    setMaxListeners2(Infinity, this.shutDownController.signal);
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new PriorityQueue2({
      concurrency: init.maxParallelDials ?? defaultOptions6.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (event) => {
      this.log.error("error in dial queue", event.detail);
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners2(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options2 = {}) {
    const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options2.force === true) {
        return false;
      }
      if (conn.remotePeer.equals(peerId2)) {
        return true;
      }
      return multiaddrs.find((addr) => {
        return addr.equals(conn.remoteAddr);
      });
    });
    if (existingConnection != null) {
      this.log("already connected to %a", existingConnection.remoteAddr);
      options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
      return existingConnection;
    }
    const existingDial = this.queue.queue.find((job) => {
      if (peerId2?.equals(job.options.peerId) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId2);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      options2.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options2);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new CodeError("Dial queue is full", "ERR_DIAL_QUEUE_FULL");
    }
    this.log("creating dial target for %p", peerId2, multiaddrs.map((ma) => ma.toString()));
    options2.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options3) => {
      options3?.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
      const signal = this.createDialAbortController(options3?.signal);
      let addrsToDial;
      try {
        addrsToDial = await this.calculateMultiaddrs(peerId2, options3?.multiaddrs, {
          ...options3,
          signal
        });
        options3?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
        addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()).forEach((addr) => {
          options3?.multiaddrs.add(addr);
        });
      } catch (err) {
        signal.clear();
        throw err;
      }
      try {
        let dialed = 0;
        const errors = [];
        for (const address of addrsToDial) {
          if (dialed === this.maxPeerAddrsToDial) {
            this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, peerId2);
            throw new CodeError("Peer had more than maxPeerAddrsToDial", codes6.ERR_TOO_MANY_ADDRESSES);
          }
          dialed++;
          try {
            const conn = await this.components.transportManager.dial(address.multiaddr, {
              ...options3,
              signal
            });
            this.log("dial to %a succeeded", address.multiaddr);
            return conn;
          } catch (err) {
            this.log.error("dial failed to %a", address.multiaddr, err);
            if (peerId2 != null) {
              try {
                await this.components.peerStore.patch(peerId2, {
                  metadata: {
                    [LAST_DIAL_FAILURE_KEY]: fromString49(Date.now().toString())
                  }
                });
              } catch (err2) {
                this.log.error("could not update last dial failure key for %p", peerId2, err2);
              }
            }
            if (signal.aborted) {
              throw new CodeError(err.message, ERR_TIMEOUT);
            }
            errors.push(err);
          }
        }
        if (errors.length === 1) {
          throw errors[0];
        }
        throw new AggregateCodeError(errors, "All multiaddr dials failed", codes6.ERR_TRANSPORT_DIAL_FAILED);
      } finally {
        signal.clear();
      }
    }, {
      peerId: peerId2,
      priority: options2.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options2.signal,
      onProgress: options2.onProgress
    });
  }
  createDialAbortController(userSignal) {
    const signal = anySignal7([
      AbortSignal.timeout(this.dialTimeout),
      this.shutDownController.signal,
      userSignal
    ]);
    setMaxListeners2(Infinity, signal);
    return signal;
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId2, multiaddrs = /* @__PURE__ */ new Set(), options2 = {}) {
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId2 != null) {
      if (this.components.peerId.equals(peerId2)) {
        throw new CodeError("Tried to dial self", codes6.ERR_DIALED_SELF);
      }
      if (await this.components.connectionGater.denyDialPeer?.(peerId2) === true) {
        throw new CodeError("The dial request is blocked by gater.allowDialPeer", codes6.ERR_PEER_DIAL_INTERCEPTED);
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId2);
        try {
          const peer = await this.components.peerStore.get(peerId2);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.code !== codes6.ERR_NOT_FOUND) {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId2);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId2);
          this.log("found multiaddrs for %p in the peer routing", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.code !== codes6.ERR_NO_ROUTERS_AVAILABLE) {
            this.log.error("looking up multiaddrs for %p in the peer routing failed", peerId2, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, {
        dns: this.components.dns,
        ...options2,
        log: this.log
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId2 != null) {
      const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastProto = addr.multiaddr.protos().pop();
        if (lastProto?.path === true) {
          return addr;
        }
        if (addr.multiaddr.getPeerId() == null) {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId2 != null && addrPeerId != null) {
        return peerId2.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new CodeError("The dial request has no valid addresses", codes6.ERR_NO_VALID_ADDRESSES);
    }
    const gatedAdrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAdrs.push(addr);
    }
    const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new CodeError("The connection gater denied all addresses in the dial request", codes6.ERR_NO_VALID_ADDRESSES);
    }
    this.log.trace("addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId2 ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options2 = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options2);
      if (options2.runOnTransientConnection === false) {
        return addresses.find((addr) => {
          return !Circuit.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
};

// node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions7 = {
  minConnections: MIN_CONNECTIONS,
  maxConnections: MAX_CONNECTIONS2,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,
  autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE
};
var DefaultConnectionManager = class {
  started;
  connections;
  allow;
  deny;
  maxIncomingPendingConnections;
  incomingPendingConnections;
  maxConnections;
  dialQueue;
  autoDial;
  connectionPruner;
  inboundConnectionRateLimiter;
  peerStore;
  metrics;
  events;
  log;
  constructor(components, init = {}) {
    this.maxConnections = init.maxConnections ?? defaultOptions7.maxConnections;
    const minConnections = init.minConnections ?? defaultOptions7.minConnections;
    if (this.maxConnections < minConnections) {
      throw new CodeError("Connection Manager maxConnections must be greater than minConnections", codes6.ERR_INVALID_PARAMETERS);
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    this.allow = (init.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init.deny ?? []).map((ma) => multiaddr(ma));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions7.maxIncomingPendingConnections;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions7.inboundConnectionThreshold,
      duration: 1
    });
    this.autoDial = new AutoDial({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      minConnections,
      autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions7.autoDialConcurrency,
      autoDialPriority: init.autoDialPriority ?? defaultOptions7.autoDialPriority,
      autoDialPeerRetryThreshold: init.autoDialPeerRetryThreshold ?? defaultOptions7.autoDialPeerRetryThreshold,
      autoDialDiscoveredPeersDebounce: init.autoDialDiscoveredPeersDebounce ?? defaultOptions7.autoDialDiscoveredPeersDebounce,
      maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions7.autoDialMaxQueueLength
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      maxConnections: this.maxConnections,
      allow: this.allow
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter ?? defaultAddressSort,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-manager";
  isStarted() {
    return this.started;
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.dialQueue.start();
    this.autoDial.start();
    this.started = true;
    this.log("started");
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE);
        }]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer.id).catch((err) => {
          this.log.error(err);
        });
      }));
    }).catch((err) => {
      this.log.error(err);
    });
    this.autoDial.afterStart();
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.dialQueue.stop();
    this.autoDial.stop();
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            this.log.error(err);
          }
        })());
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId2 = connection.remotePeer;
    const storedConns = this.connections.get(peerId2);
    let isNewPeer = false;
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      isNewPeer = true;
      this.connections.set(peerId2, [connection]);
    }
    if (peerId2.publicKey != null && peerId2.type === "RSA") {
      await this.peerStore.patch(peerId2, {
        publicKey: peerId2.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId2 = connection.remotePeer;
    let storedConn = this.connections.get(peerId2);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId2, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId2);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId2) {
    if (peerId2 != null) {
      return this.connections.get(peerId2) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options2 = {}) {
    if (!this.isStarted()) {
      throw new CodeError("Not started", codes6.ERR_NODE_NOT_STARTED);
    }
    options2.signal?.throwIfAborted();
    const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId2 != null && options2.force !== true) {
      this.log("dial %p", peerId2);
      const existingConnection = this.getConnections(peerId2).find((conn) => !conn.transient);
      if (existingConnection != null) {
        this.log("had an existing non-transient connection to %p", peerId2);
        options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
    }
    const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
      ...options2,
      priority: options2.priority ?? DEFAULT_DIAL_PRIORITY
    });
    let peerConnections = this.connections.get(connection.remotePeer);
    if (peerConnections == null) {
      peerConnections = [];
      this.connections.set(connection.remotePeer, peerConnections);
    }
    let trackedConnection = false;
    for (const conn of peerConnections) {
      if (conn.id === connection.id) {
        trackedConnection = true;
      }
    }
    if (!trackedConnection) {
      peerConnections.push(connection);
    }
    return connection;
  }
  async closeConnections(peerId2, options2 = {}) {
    const connections = this.connections.get(peerId2) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options2);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.dialQueue.isDialable(multiaddr2, options2);
  }
};

// node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION3 = "1.0.0";
var PROTOCOL_NAME3 = "ping";
var PROTOCOL_PREFIX3 = "ipfs";
var PING_LENGTH2 = 32;
var ConnectionMonitor = class {
  protocol;
  components;
  log;
  heartbeatInterval;
  pingIntervalMs;
  abortController;
  timeout;
  constructor(components, init = {}) {
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX3}/${PROTOCOL_NAME3}/${PROTOCOL_VERSION3}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-monitor";
  [serviceCapabilities] = [
    "@libp2p/connection-monitor"
  ];
  start() {
    this.abortController = new AbortController();
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: this.abortController?.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnTransientConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes2(PING_LENGTH2), {
                signal
              }),
              bs.read(PING_LENGTH2, {
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await bs.unwrap().close({
              signal
            });
          } catch (err) {
            if (err.code !== "ERR_UNSUPPORTED_PROTOCOL") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat, aborting connection", err);
          conn.abort(err);
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    this.abortController?.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// node_modules/libp2p/dist/src/content-routing.js
var CompoundContentRouting = class {
  routers;
  started;
  components;
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  [Symbol.toStringTag] = "@libp2p/content-routing";
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes6.ERR_NO_ROUTERS_AVAILABLE);
    }
    const self2 = this;
    const seen = new PeerSet();
    for await (const peer of src_default4(...self2.routers.map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes6.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options2) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes6.ERR_NODE_NOT_STARTED);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.put(key, value, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes6.ERR_NODE_NOT_STARTED);
    }
    return Promise.any(this.routers.map(async (router) => {
      return router.get(key, options2);
    }));
  }
};

// node_modules/libp2p/dist/src/peer-routing.js
var DefaultPeerRouting = class {
  log;
  peerId;
  peerStore;
  routers;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
  }
  [Symbol.toStringTag] = "@libp2p/peer-routing";
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes6.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.peerId.toString()) {
      throw new CodeError("Should not try to find self", codes6.ERR_FIND_SELF);
    }
    const self2 = this;
    const source = src_default4(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      return peer;
    }
    throw new CodeError(messages.NOT_FOUND, codes6.ERR_NOT_FOUND);
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes6.ERR_NO_ROUTERS_AVAILABLE);
    }
    const self2 = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = src_default4(...self2.routers.map((router) => router.getClosestPeers(key, options2)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self2.findPeer(peer2.id, {
                ...options2,
                useCache: false
              });
            } catch (err) {
              self2.log.error("could not find peer multiaddrs", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id.toBytes())) {
        continue;
      }
      seen.add(peer.id.toBytes());
      yield peer;
    }
  }
};

// node_modules/libp2p/node_modules/p-defer/index.js
function pDefer12() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/libp2p/dist/src/random-walk.js
var RandomWalk = class extends TypedEventEmitter {
  peerRouting;
  log;
  walking;
  walkers;
  shutdownController;
  walkController;
  needNext;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners2(Infinity, this.shutdownController.signal);
  }
  [Symbol.toStringTag] = "@libp2p/random-walk";
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners2(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options2) {
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal7([this.shutdownController.signal, options2?.signal]);
    setMaxListeners2(Infinity, signal);
    try {
      while (true) {
        this.needNext?.resolve();
        this.needNext = pDefer12();
        const event = await raceEvent(this, "walk:peer", signal, {
          errorEvent: "walk:error"
        });
        yield event.detail;
      }
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        this.walkController?.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners2(Infinity, this.walkController.signal);
    const signal = anySignal7([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners2(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes2(32);
          let s2 = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s2 = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("randomwalk errored", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("randomwalk errored", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 64;
var DefaultRegistrar = class {
  log;
  topologies;
  handlers;
  components;
  constructor(components) {
    this.log = components.logger.forComponent("libp2p:registrar");
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  [Symbol.toStringTag] = "@libp2p/registrar";
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new CodeError(`No handler registered for protocol ${protocol}`, codes6.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw new CodeError(`Handler already registered for protocol ${protocol}`, codes6.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options2 = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS3,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS3
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options: options2
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new CodeError("invalid topology", codes6.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (topology.filter?.has(remotePeer) === false) {
            continue;
          }
          topology.filter?.remove(remotePeer);
          topology.onDisconnect?.(remotePeer);
        }
      }
    }).catch((err) => {
      if (err.code === codes6.ERR_NOT_FOUND) {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (topology.filter?.has(peer.id) === false) {
          continue;
        }
        topology.filter?.remove(peer.id);
        topology.onDisconnect?.(peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId2 = evt.detail.peerId;
    for (const protocol of protocols) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.transient && topology.notifyOnTransient !== true) {
          continue;
        }
        if (topology.filter?.has(peerId2) === true) {
          continue;
        }
        topology.filter?.add(peerId2);
        topology.onConnect?.(peerId2, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/transport-manager.js
var DefaultTransportManager = class {
  log;
  components;
  transports;
  listeners;
  faultTolerance;
  started;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  [Symbol.toStringTag] = "@libp2p/transport-manager";
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new CodeError("Transport must have a valid tag", codes6.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw new CodeError(`There is already a transport with the tag ${tag}`, codes6.ERR_DUPLICATE_TRANSPORT);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options2) {
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new CodeError(`No transport available for address ${String(ma)}`, codes6.ERR_TRANSPORT_UNAVAILABLE);
    }
    options2?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    try {
      return await transport.dial(ma, {
        ...options2,
        upgrader: this.components.upgrader
      });
    } catch (err) {
      if (err.code == null) {
        err.code = codes6.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err;
    }
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new CodeError("Not started", codes6.ERR_NODE_NOT_STARTED);
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await Promise.allSettled(tasks);
      const isListening = results.find((r) => r.status === "fulfilled");
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw new CodeError(`Transport (${key}) could not listen on any available address`, codes6.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw new CodeError(message2, codes6.ERR_NO_VALID_ADDRESSES);
      }
      this.log(`libp2p in dial mode only: ${message2}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/@libp2p/multistream-select/node_modules/p-defer/index.js
function pDefer13() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports26 = {};
__export(base10_exports26, {
  base10: () => base1026
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bytes.js
var empty30 = new Uint8Array(0);
function equals70(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce30(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString50(str) {
  return new TextEncoder().encode(str);
}
function toString47(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/vendor/base-x.js
function base44(ALPHABET, name29) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode116(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length30 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length30) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      pbegin++;
    }
    var it2 = size - length30;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length30 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length30) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length30 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length30;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode144(string27) {
    var buffer3 = decodeUnsafe(string27);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name29} character`);
  }
  return {
    encode: encode116,
    decodeUnsafe,
    decode: decode144
  };
}
var src29 = base44;
var _brrp__multiformats_scope_baseX29 = src29;
var base_x_default30 = _brrp__multiformats_scope_baseX29;

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base.js
var Encoder31 = class {
  name;
  prefix;
  baseEncode;
  constructor(name29, prefix, baseEncode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder32 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name29, prefix, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or32(this, decoder);
  }
};
var ComposedDecoder30 = class {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or32(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or32(left, right) {
  return new ComposedDecoder30({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec30 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name29, prefix, baseEncode, baseDecode) {
    this.name = name29;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder31(name29, prefix, baseEncode);
    this.decoder = new Decoder32(name29, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from56({ name: name29, prefix, encode: encode116, decode: decode144 }) {
  return new Codec30(name29, prefix, encode116, decode144);
}
function baseX29({ name: name29, prefix, alphabet: alphabet27 }) {
  const { encode: encode116, decode: decode144 } = base_x_default30(alphabet27, name29);
  return from56({
    prefix,
    name: name29,
    encode: encode116,
    decode: (text) => coerce30(decode144(text))
  });
}
function decode139(string27, alphabet27, bitsPerChar, name29) {
  const codes7 = {};
  for (let i = 0; i < alphabet27.length; ++i) {
    codes7[alphabet27[i]] = i;
  }
  let end = string27.length;
  while (string27[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes7[string27[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name29} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer3 >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || (255 & buffer3 << 8 - bits2) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode112(data, alphabet27, bitsPerChar) {
  const pad = alphabet27[alphabet27.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet27[mask & buffer3 >> bits2];
    }
  }
  if (bits2 !== 0) {
    out += alphabet27[mask & buffer3 << bitsPerChar - bits2];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc464830({ name: name29, prefix, bitsPerChar, alphabet: alphabet27 }) {
  return from56({
    prefix,
    name: name29,
    encode(input) {
      return encode112(input, alphabet27, bitsPerChar);
    },
    decode(input) {
      return decode139(input, alphabet27, bitsPerChar, name29);
    }
  });
}

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base10.js
var base1026 = baseX29({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports26 = {};
__export(base16_exports26, {
  base16: () => base1626,
  base16upper: () => base16upper26
});
var base1626 = rfc464830({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper26 = rfc464830({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports26 = {};
__export(base2_exports26, {
  base2: () => base226
});
var base226 = rfc464830({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports26 = {};
__export(base256emoji_exports26, {
  base256emoji: () => base256emoji26
});
var alphabet26 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars26 = alphabet26.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes26 = alphabet26.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode113(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars26[c];
    return p;
  }, "");
}
function decode140(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes26[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji26 = from56({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode113,
  decode: decode140
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports26 = {};
__export(base32_exports26, {
  base32: () => base3228,
  base32hex: () => base32hex28,
  base32hexpad: () => base32hexpad28,
  base32hexpadupper: () => base32hexpadupper28,
  base32hexupper: () => base32hexupper28,
  base32pad: () => base32pad28,
  base32padupper: () => base32padupper28,
  base32upper: () => base32upper28,
  base32z: () => base32z28
});
var base3228 = rfc464830({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper28 = rfc464830({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad28 = rfc464830({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper28 = rfc464830({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex28 = rfc464830({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper28 = rfc464830({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad28 = rfc464830({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper28 = rfc464830({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z28 = rfc464830({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports26 = {};
__export(base36_exports26, {
  base36: () => base3626,
  base36upper: () => base36upper26
});
var base3626 = baseX29({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper26 = baseX29({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports26 = {};
__export(base58_exports26, {
  base58btc: () => base58btc29,
  base58flickr: () => base58flickr29
});
var base58btc29 = baseX29({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr29 = baseX29({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports26 = {};
__export(base64_exports26, {
  base64: () => base6429,
  base64pad: () => base64pad29,
  base64url: () => base64url29,
  base64urlpad: () => base64urlpad29
});
var base6429 = rfc464830({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad29 = rfc464830({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url29 = rfc464830({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad29 = rfc464830({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports26 = {};
__export(base8_exports26, {
  base8: () => base826
});
var base826 = rfc464830({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports51 = {};
__export(identity_exports51, {
  identity: () => identity51
});
var identity51 = from56({
  prefix: "\0",
  name: "identity",
  encode: (buf3) => toString47(buf3),
  decode: (str) => fromString50(str)
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder30 = new TextEncoder();
var textDecoder29 = new TextDecoder();

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports52 = {};
__export(identity_exports52, {
  identity: () => identity52
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/vendor/varint.js
var encode_127 = encode114;
var MSB29 = 128;
var REST29 = 127;
var MSBALL27 = ~REST29;
var INT27 = Math.pow(2, 31);
function encode114(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT27) {
    out[offset++] = num & 255 | MSB29;
    num /= 128;
  }
  while (num & MSBALL27) {
    out[offset++] = num & 255 | MSB29;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode114.bytes = offset - oldOffset + 1;
  return out;
}
var decode141 = read28;
var MSB$127 = 128;
var REST$127 = 127;
function read28(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read28.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$127) << shift : (b & REST$127) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$127);
  read28.bytes = counter - offset;
  return res;
}
var N128 = Math.pow(2, 7);
var N228 = Math.pow(2, 14);
var N328 = Math.pow(2, 21);
var N428 = Math.pow(2, 28);
var N528 = Math.pow(2, 35);
var N628 = Math.pow(2, 42);
var N728 = Math.pow(2, 49);
var N827 = Math.pow(2, 56);
var N927 = Math.pow(2, 63);
var length29 = function(value) {
  return value < N128 ? 1 : value < N228 ? 2 : value < N328 ? 3 : value < N428 ? 4 : value < N528 ? 5 : value < N628 ? 6 : value < N728 ? 7 : value < N827 ? 8 : value < N927 ? 9 : 10;
};
var varint27 = {
  encode: encode_127,
  decode: decode141,
  encodingLength: length29
};
var _brrp_varint27 = varint27;
var varint_default27 = _brrp_varint27;

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/varint.js
function decode142(data, offset = 0) {
  const code33 = varint_default27.decode(data, offset);
  return [code33, varint_default27.decode.bytes];
}
function encodeTo27(int, target, offset = 0) {
  varint_default27.encode(int, target, offset);
  return target;
}
function encodingLength28(int) {
  return varint_default27.encodingLength(int);
}

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/digest.js
function create29(code33, digest27) {
  const size = digest27.byteLength;
  const sizeOffset = encodingLength28(code33);
  const digestOffset = sizeOffset + encodingLength28(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo27(code33, bytes3, 0);
  encodeTo27(size, bytes3, sizeOffset);
  bytes3.set(digest27, digestOffset);
  return new Digest27(code33, size, digest27, bytes3);
}
function decode143(multihash) {
  const bytes3 = coerce30(multihash);
  const [code33, sizeOffset] = decode142(bytes3);
  const [size, digestOffset] = decode142(bytes3.subarray(sizeOffset));
  const digest27 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest27.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest27(code33, size, digest27, bytes3);
}
function equals71(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals70(a.bytes, data.bytes);
  }
}
var Digest27 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code33, size, digest27, bytes3) {
    this.code = code33;
    this.size = size;
    this.digest = digest27;
    this.bytes = bytes3;
  }
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/identity.js
var code32 = 0;
var name28 = "identity";
var encode115 = coerce30;
function digest26(input) {
  return create29(code32, encode115(input));
}
var identity52 = { code: code32, name: name28, encode: encode115, digest: digest26 };

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports26 = {};
__export(sha2_browser_exports26, {
  sha256: () => sha25628,
  sha512: () => sha51228
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/hasher.js
function from57({ name: name29, code: code33, encode: encode116 }) {
  return new Hasher27(name29, code33, encode116);
}
var Hasher27 = class {
  name;
  code;
  encode;
  constructor(name29, code33, encode116) {
    this.name = name29;
    this.code = code33;
    this.encode = encode116;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create29(this.code, result) : result.then((digest27) => create29(this.code, digest27));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha27(name29) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name29, data));
}
var sha25628 = from57({
  name: "sha2-256",
  code: 18,
  encode: sha27("SHA-256")
});
var sha51228 = from57({
  name: "sha2-512",
  code: 19,
  encode: sha27("SHA-512")
});

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/cid.js
function format27(link, base45) {
  const { bytes: bytes3, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV027(bytes3, baseCache27(link), base45 ?? base58btc29.encoder);
    default:
      return toStringV127(bytes3, baseCache27(link), base45 ?? base3228.encoder);
  }
}
var cache29 = /* @__PURE__ */ new WeakMap();
function baseCache27(cid) {
  const baseCache28 = cache29.get(cid);
  if (baseCache28 == null) {
    const baseCache29 = /* @__PURE__ */ new Map();
    cache29.set(cid, baseCache29);
    return baseCache29;
  }
  return baseCache28;
}
var CID27 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code33, multihash, bytes3) {
    this.code = code33;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code33, multihash } = this;
        if (code33 !== DAG_PB_CODE27) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE27) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code33, digest: digest27 } = this.multihash;
        const multihash = create29(code33, digest27);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals71(self2.multihash, unknown.multihash);
  }
  toString(base45) {
    return format27(this, base45);
  }
  toJSON() {
    return { "/": format27(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code33, multihash, bytes: bytes3 } = value;
      return new _CID(version3, code33, multihash, bytes3 ?? encodeCID27(version3, code33, multihash.bytes));
    } else if (value[cidSymbol27] === true) {
      const { version: version3, multihash, code: code33 } = value;
      const digest27 = decode143(multihash);
      return _CID.create(version3, code33, digest27);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code33, digest27) {
    if (typeof code33 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest27.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code33 !== DAG_PB_CODE27) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE27}) block encoding`);
        } else {
          return new _CID(version3, code33, digest27, digest27.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID27(version3, code33, digest27.bytes);
        return new _CID(version3, code33, digest27, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest27) {
    return _CID.create(0, DAG_PB_CODE27, digest27);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code33, digest27) {
    return _CID.create(1, code33, digest27);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce30(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest27 = new Digest27(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest27) : _CID.createV1(specs.codec, digest27);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length30] = decode142(initialBytes.subarray(offset));
      offset += length30;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE27;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base45) {
    const [prefix, bytes3] = parseCIDtoBytes27(source, base45);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache27(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes27(source, base45) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base45 ?? base58btc29;
      return [
        base58btc29.prefix,
        decoder.decode(`${base58btc29.prefix}${source}`)
      ];
    }
    case base58btc29.prefix: {
      const decoder = base45 ?? base58btc29;
      return [base58btc29.prefix, decoder.decode(source)];
    }
    case base3228.prefix: {
      const decoder = base45 ?? base3228;
      return [base3228.prefix, decoder.decode(source)];
    }
    default: {
      if (base45 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base45.decode(source)];
    }
  }
}
function toStringV027(bytes3, cache30, base45) {
  const { prefix } = base45;
  if (prefix !== base58btc29.prefix) {
    throw Error(`Cannot string encode V0 in ${base45.name} encoding`);
  }
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3).slice(1);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV127(bytes3, cache30, base45) {
  const { prefix } = base45;
  const cid = cache30.get(prefix);
  if (cid == null) {
    const cid2 = base45.encode(bytes3);
    cache30.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE27 = 112;
var SHA_256_CODE27 = 18;
function encodeCID27(version3, code33, multihash) {
  const codeOffset = encodingLength28(version3);
  const hashOffset = codeOffset + encodingLength28(code33);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo27(version3, bytes3, 0);
  encodeTo27(code33, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol27 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/basics.js
var bases26 = { ...identity_exports51, ...base2_exports26, ...base8_exports26, ...base10_exports26, ...base16_exports26, ...base32_exports26, ...base36_exports26, ...base58_exports26, ...base64_exports26, ...base256emoji_exports26 };
var hashes26 = { ...sha2_browser_exports26, ...identity_exports52 };

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe28(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec26(name29, prefix, encode116, decode144) {
  return {
    name: name29,
    prefix,
    encoder: {
      name: name29,
      prefix,
      encode: encode116
    },
    decoder: {
      decode: decode144
    }
  };
}
var string26 = createCodec26("utf8", "u", (buf3) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf3);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii25 = createCodec26("ascii", "a", (buf3) => {
  let string27 = "a";
  for (let i = 0; i < buf3.length; i++) {
    string27 += String.fromCharCode(buf3[i]);
  }
  return string27;
}, (str) => {
  str = str.substring(1);
  const buf3 = allocUnsafe28(str.length);
  for (let i = 0; i < str.length; i++) {
    buf3[i] = str.charCodeAt(i);
  }
  return buf3;
});
var BASES25 = {
  utf8: string26,
  "utf-8": string26,
  hex: bases26.base16,
  latin1: ascii25,
  ascii: ascii25,
  binary: ascii25,
  ...bases26
};
var bases_default25 = BASES25;

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/from-string.js
function fromString51(string27, encoding = "utf8") {
  const base45 = bases_default25[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.decoder.decode(`${base45.prefix}${string27}`);
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/to-string.js
function toString48(array, encoding = "utf8") {
  const base45 = bases_default25[encoding];
  if (base45 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base45.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString51("\n");
async function write2(writer, buffer3, options2) {
  await writer.write(buffer3, options2);
}
async function writeAll(writer, buffers, options2) {
  await writer.writeV(buffers, options2);
}
async function read29(reader, options2) {
  const buf3 = await reader.read(options2);
  if (buf3.byteLength === 0 || buf3.get(buf3.byteLength - 1) !== NewLine[0]) {
    options2.log.error("Invalid mss message - missing newline", buf3);
    throw new CodeError("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf3.sublist(0, -1);
}
async function readString(reader, options2) {
  const buf3 = await read29(reader, options2);
  return toString48(buf3.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols, options2) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 1 && options2.negotiateFully === false) {
    return optimisticSelect(stream, protocols[0], options2);
  }
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  options2.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString51(`${PROTOCOL_ID}
`);
  const p2 = fromString51(`${protocol}
`);
  await writeAll(lp, [p1, p2], options2);
  options2.log.trace("select: reading multistream-select header");
  let response = await readString(lp, options2);
  options2.log.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    options2.log.trace("select: reading protocol response");
    response = await readString(lp, options2);
    options2.log.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    return { stream: lp.unwrap(), protocol };
  }
  for (const protocol2 of protocols) {
    options2.log.trace('select: write "%s"', protocol2);
    await write2(lp, fromString51(`${protocol2}
`), options2);
    options2.log.trace("select: reading protocol response");
    const response2 = await readString(lp, options2);
    options2.log.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      return { stream: lp.unwrap(), protocol: protocol2 };
    }
  }
  throw new CodeError("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
}
function optimisticSelect(stream, protocol, options2) {
  const originalSink = stream.sink.bind(stream);
  const originalSource = stream.source;
  let negotiated = false;
  let negotiating = false;
  const doneNegotiating = pDefer13();
  let sentProtocol = false;
  let sendingProtocol = false;
  const doneSendingProtocol = pDefer13();
  let readProtocol = false;
  let readingProtocol = false;
  const doneReadingProtocol = pDefer13();
  const lp = lpStream({
    sink: originalSink,
    source: originalSource
  }, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  stream.sink = async (source) => {
    const { sink } = lp.unwrap();
    await sink(async function* () {
      let sentData = false;
      for await (const buf3 of source) {
        if (sendingProtocol) {
          await doneSendingProtocol.promise;
        }
        if (!sentProtocol) {
          sendingProtocol = true;
          options2.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf3.byteLength);
          const protocolString = `${protocol}
`;
          yield new Uint8ArrayList(
            Uint8Array.from([19]),
            // length of PROTOCOL_ID plus newline
            fromString51(`${PROTOCOL_ID}
`),
            encode(protocolString.length),
            fromString51(protocolString),
            buf3
          ).subarray();
          options2.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf3.byteLength);
          sentProtocol = true;
          sendingProtocol = false;
          doneSendingProtocol.resolve();
          negotiate().catch((err) => {
            options2.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
          });
        } else {
          yield buf3;
        }
        sentData = true;
      }
      if (!sentData) {
        await negotiate();
      }
    }());
  };
  async function negotiate() {
    if (negotiating) {
      options2.log.trace("optimistic: already negotiating %s stream", protocol);
      await doneNegotiating.promise;
      return;
    }
    negotiating = true;
    try {
      if (!sentProtocol) {
        options2.log.trace("optimistic: doing send protocol for %s stream", protocol);
        await doSendProtocol();
      }
      if (!readProtocol) {
        options2.log.trace("optimistic: doing read protocol for %s stream", protocol);
        await doReadProtocol();
      }
    } finally {
      negotiating = false;
      negotiated = true;
      doneNegotiating.resolve();
    }
  }
  async function doSendProtocol() {
    if (sendingProtocol) {
      await doneSendingProtocol.promise;
      return;
    }
    sendingProtocol = true;
    try {
      options2.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      await lp.writeV([
        fromString51(`${PROTOCOL_ID}
`),
        fromString51(`${protocol}
`)
      ]);
      options2.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
    } finally {
      sentProtocol = true;
      sendingProtocol = false;
      doneSendingProtocol.resolve();
    }
  }
  async function doReadProtocol() {
    if (readingProtocol) {
      await doneReadingProtocol.promise;
      return;
    }
    readingProtocol = true;
    try {
      options2.log.trace("optimistic: reading multistream select header");
      let response = await readString(lp, options2);
      options2.log.trace('optimistic: read multistream select header "%s"', response);
      if (response === PROTOCOL_ID) {
        response = await readString(lp, options2);
      }
      options2.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
      if (response !== protocol) {
        throw new CodeError("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
      }
    } finally {
      readProtocol = true;
      readingProtocol = false;
      doneReadingProtocol.resolve();
    }
  }
  stream.source = async function* () {
    await negotiate();
    options2.log.trace('optimistic: reading data from "%s" stream', protocol);
    yield* lp.unwrap().source;
  }();
  if (stream.closeRead != null) {
    const originalCloseRead = stream.closeRead.bind(stream);
    stream.closeRead = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options2.log.error("could not negotiate protocol before close read", err);
        });
      }
      await originalCloseRead(opts);
    };
  }
  if (stream.closeWrite != null) {
    const originalCloseWrite = stream.closeWrite.bind(stream);
    stream.closeWrite = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options2.log.error("could not negotiate protocol before close write", err);
        });
      }
      await originalCloseWrite(opts);
    };
  }
  if (stream.close != null) {
    const originalClose = stream.close.bind(stream);
    stream.close = async (opts) => {
      const tasks = [];
      if (sendingProtocol) {
        tasks.push(doneSendingProtocol.promise);
      }
      if (readingProtocol) {
        tasks.push(doneReadingProtocol.promise);
      }
      if (tasks.length > 0) {
        await raceSignal(Promise.all(tasks), opts?.signal);
      } else {
        negotiated = true;
        negotiating = false;
        doneNegotiating.resolve();
      }
      await originalClose(opts);
    };
  }
  return {
    stream,
    protocol
  };
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols, options2) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  options2.log.trace("handle: available protocols %s", protocols);
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    options2.log.trace("handle: reading incoming string");
    const protocol = await readString(lp, options2);
    options2.log.trace('handle: read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      options2.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await write2(lp, fromString51(`${PROTOCOL_ID}
`), options2);
      options2.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols.includes(protocol)) {
      options2.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
      await write2(lp, fromString51(`${protocol}
`), options2);
      options2.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
      return { stream: lp.unwrap(), protocol };
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p) => encode2.single(fromString51(`${p}
`))), fromString51("\n"));
      options2.log.trace('handle: respond with "%s" for %s', protocols, protocol);
      await write2(lp, protos, options2);
      options2.log.trace('handle: responded with "%s" for %s', protocols, protocol);
      continue;
    }
    options2.log('handle: respond with "na" for "%s"', protocol);
    await write2(lp, fromString51("na\n"), options2);
    options2.log('handle: responded with "na" for "%s"', protocol);
  }
}

// node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT4 = 500;
var ConnectionImpl = class {
  /**
   * Connection identifier.
   */
  id;
  /**
   * Observed multiaddr of the remote peer
   */
  remoteAddr;
  /**
   * Remote peer id
   */
  remotePeer;
  direction;
  timeline;
  multiplexer;
  encryption;
  status;
  transient;
  log;
  /**
   * User provided tags
   *
   */
  tags;
  /**
   * Reference to the new stream function of the multiplexer
   */
  _newStream;
  /**
   * Reference to the close function of the raw connection
   */
  _close;
  _abort;
  /**
   * Reference to the getStreams function of the muxer
   */
  _getStreams;
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.transient = init.transient ?? false;
    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  [Symbol.toStringTag] = "Connection";
  [connectionSymbol] = true;
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options2) {
    if (this.status === "closing") {
      throw new CodeError("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.status === "closed") {
      throw new CodeError("the connection is closed", "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    if (this.transient && options2?.runOnTransientConnection !== true) {
      throw new CodeError("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    }
    const stream = await this._newStream(protocols, options2);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options2 = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.log("closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT4);
      setMaxListeners2(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      this.log.trace("closing all streams");
      await Promise.all(this.streams.map(async (s2) => s2.close(options2)));
      this.log.trace("closing underlying transport");
      await this._close(options2);
      this.log.trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this.streams.forEach((s2) => {
      s2.abort(err);
    });
    this.log.error("all streams aborted", this.streams.length);
    this._abort(err);
    this.timeline.close = Date.now();
    this.status = "closed";
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/upgrader.js
var DEFAULT_PROTOCOL_SELECT_TIMEOUT = 3e4;
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    return options2.maxInboundStreams;
  } catch (err) {
    if (err.code !== codes6.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS3;
}
function findOutgoingStreamLimit(protocol, registrar, options2 = {}) {
  try {
    const { options: options3 } = registrar.getHandler(protocol);
    if (options3.maxOutboundStreams != null) {
      return options3.maxOutboundStreams;
    }
  } catch (err) {
    if (err.code !== codes6.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return options2.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var DefaultUpgrader = class {
  components;
  connectionEncryption;
  muxers;
  inboundUpgradeTimeout;
  events;
  constructor(components, init) {
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.events = components.events;
  }
  [Symbol.toStringTag] = "@libp2p/upgrader";
  async shouldBlockConnection(remotePeer, maConn, connectionType) {
    const connectionGater2 = this.components.connectionGater[connectionType];
    if (connectionGater2 !== void 0) {
      if (await connectionGater2(remotePeer, maConn)) {
        throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes6.ERR_CONNECTION_INTERCEPTED);
      }
    }
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw new CodeError("connection denied", codes6.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);
    const onAbort = () => {
      maConn.abort(new CodeError("inbound upgrade timeout", ERR_TIMEOUT));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    setMaxListeners2(Infinity, signal);
    try {
      if (await this.components.connectionGater.denyInboundConnection?.(maConn) === true) {
        throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection", codes6.ERR_CONNECTION_INTERCEPTED);
      }
      this.components.metrics?.trackMultiaddrConnection(maConn);
      maConn.log("starting the inbound connection upgrade");
      let protectedConn = maConn;
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          maConn.log("protecting the inbound connection");
          protectedConn = await protector.protect(maConn);
        }
      }
      try {
        encryptedConn = protectedConn;
        if (opts?.skipEncryption !== true) {
          opts?.onProgress?.(new CustomProgressEvent("upgrader:encrypt-inbound-connection"));
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(protectedConn));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(remotePeer, maConn2, "denyInboundEncryptedConnection");
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw new CodeError("inbound connection that skipped encryption must have a peer id", codes6.ERR_INVALID_MULTIADDR);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        upgradedConn = encryptedConn;
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (this.muxers.size > 0) {
          opts?.onProgress?.(new CustomProgressEvent("upgrader:multiplex-inbound-connection"));
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        maConn.log.error("failed to upgrade inbound connection", err);
        throw err;
      }
      await this.shouldBlockConnection(remotePeer, maConn, "denyInboundUpgradedConnection");
      maConn.log("successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer,
        transient: opts?.transient
      });
    } finally {
      signal.removeEventListener("abort", onAbort);
      this.components.connectionManager.afterUpgradeInbound();
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    const idStr = maConn.remoteAddr.getPeerId();
    let remotePeerId;
    if (idStr != null) {
      remotePeerId = peerIdFromString(idStr);
      await this.shouldBlockConnection(remotePeerId, maConn, "denyOutboundConnection");
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    this.components.metrics?.trackMultiaddrConnection(maConn);
    maConn.log("starting the outbound connection upgrade");
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(remotePeer, maConn2, "denyOutboundEncryptedConnection");
      } else {
        if (remotePeerId == null) {
          throw new CodeError("Encryption was skipped but no peer id was passed", codes6.ERR_INVALID_PEER);
        }
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      maConn.log.error("failed to upgrade outbound connection", err);
      await maConn.close(err);
      throw err;
    }
    await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundUpgradedConnection");
    maConn.log("successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      transient: opts?.transient
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols, {
              log: muxedStream.log,
              yieldBytes: false
            });
            if (connection == null) {
              return;
            }
            connection.log("incoming stream opened on %s", protocol);
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new CodeError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`, codes6.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            connection.log.error("error handling incoming stream id %s", muxedStream.id, err.message, err.code, err.stack);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close();
            }
          });
        }
      });
      newStream = async (protocols, options2 = {}) => {
        if (muxer == null) {
          throw new CodeError("Stream is not multiplexed", codes6.ERR_MUXER_UNAVAILABLE);
        }
        connection.log("starting new stream for protocols %s", protocols);
        const muxedStream = await muxer.newStream();
        connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
        try {
          if (options2.signal == null) {
            muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT);
            setMaxListeners2(Infinity, signal);
            options2 = {
              ...options2,
              signal
            };
          }
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          const { stream, protocol } = await select(muxedStream, protocols, {
            ...options2,
            log: muxedStream.log,
            yieldBytes: true
          });
          muxedStream.log("selected protocol %s", protocol);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options2);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new CodeError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`, codes6.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          if (stream.closeWrite != null) {
            muxedStream.closeWrite = stream.closeWrite;
          }
          if (stream.closeRead != null) {
            muxedStream.closeRead = stream.closeRead;
          }
          if (stream.close != null) {
            muxedStream.close = stream.close;
          }
          this.components.metrics?.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          connection.log.error("could not create new stream for protocols %s", protocols, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          if (err.code != null) {
            throw err;
          }
          throw new CodeError(String(err), codes6.ERR_UNSUPPORTED_PROTOCOL);
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        connection.log.error("error piping data through muxer", err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              connection.log.error("error closing connection after timeline close", err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            connection.log.error("error thrown while dispatching connection:close event", err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new CodeError("connection is not multiplexed", codes6.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer?.protocol,
      encryption: cryptoProtocol,
      transient,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        if (muxer != null) {
          return muxer.streams;
        } else {
          return [];
        }
      },
      close: async (options2) => {
        if (muxer != null) {
          connection.log.trace("close muxer");
          await muxer.close(options2);
        }
        connection.log.trace("close maconn");
        await maConn.close(options2);
        connection.log.trace("closed maconn");
      },
      abort: (err) => {
        maConn.abort(err);
        if (muxer != null) {
          muxer.abort(err);
        }
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options: options2 } = this.components.registrar.getHandler(protocol);
    if (connection.transient && options2.runOnTransientConnection !== true) {
      throw new CodeError("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    connection.log("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        log: connection.log
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection using", protocol);
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting inbound connection failed", err);
      throw new CodeError(err.message, codes6.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    connection.log("selecting outbound crypto protocol", protocols);
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        log: connection.log,
        yieldBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection to %p using %s", remotePeerId, encrypter);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting outbound connection to %p failed", remotePeerId, err);
      throw new CodeError(err.message, codes6.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    connection.log("outbound selecting muxer %s", protocols);
    try {
      connection.log.trace("selecting stream muxer from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        log: connection.log,
        yieldBytes: true
      });
      connection.log("selected %s as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing outbound connection", err);
      throw new CodeError(String(err), codes6.ERR_MUXER_UNAVAILABLE);
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    connection.log("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        log: connection.log
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing inbound connection", err);
      throw new CodeError(String(err), codes6.ERR_MUXER_UNAVAILABLE);
    }
  }
};

// node_modules/libp2p/dist/src/libp2p.js
var Libp2pNode = class extends TypedEventEmitter {
  peerId;
  peerStore;
  contentRouting;
  peerRouting;
  metrics;
  services;
  logger;
  status;
  components;
  log;
  constructor(init) {
    super();
    this.status = "stopped";
    const events2 = new TypedEventEmitter();
    const originalDispatch = events2.dispatchEvent.bind(events2);
    events2.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners2(Infinity, events2);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: init.nodeInfo ?? {
        name: name22,
        version
      },
      logger: this.logger,
      events: events2,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    this.peerStore = this.configureComponent("peerStore", new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (init.connectionMonitor?.enabled !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new DefaultRegistrar(this.components));
    this.configureComponent("addressManager", new DefaultAddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.#onDiscoveryPeer(evt);
      });
    });
    init.transports?.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name29 of Object.keys(init.services)) {
        const createService = init.services[name29];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name29);
          continue;
        }
        this.services[name29] = service;
        this.configureComponent(name29, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name29);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name29);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name29);
          service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
            this.#onDiscoveryPeer(evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name29, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name29);
    }
    this.components[name29] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await this.components.beforeStart?.();
      await this.components.start();
      await this.components.afterStart?.();
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started");
    } catch (err) {
      this.log.error("An error occurred starting libp2p", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await this.components.beforeStop?.();
    await this.components.stop();
    await this.components.afterStop?.();
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId2) {
    return this.components.connectionManager.getConnections(peerId2);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options2 = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options2
    });
  }
  async dialProtocol(peer, protocols, options2 = {}) {
    if (protocols == null) {
      throw new CodeError("no protocols were provided to open a stream", codes6.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new CodeError("no protocols were provided to open a stream", codes6.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options2);
    return connection.newStream(protocols, options2);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options2 = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options2);
  }
  /**
   * Get the public key for the given peer id
   */
  async getPublicKey(peer, options2 = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.code !== codes6.ERR_NOT_FOUND) {
        throw err;
      }
    }
    const peerKey = concat12([
      fromString49("/pk/"),
      peer.multihash.digest
    ]);
    const bytes3 = await this.contentRouting.get(peerKey, options2);
    unmarshalPublicKey2(bytes3);
    await this.peerStore.patch(peer, {
      publicKey: bytes3
    });
    return bytes3;
  }
  async handle(protocols, handler, options2) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options2);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  async register(protocol, topology) {
    return this.components.registrar.register(protocol, topology);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options2);
  }
  /**
   * Called whenever peer discovery services emit `peer` events and adds peers
   * to the peer store.
   */
  #onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      this.log.error(new Error(codes6.ERR_DISCOVERED_SELF));
      return;
    }
    void this.components.peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs
    }).catch((err) => {
      this.log.error(err);
    });
  }
};
async function createLibp2pNode(options2 = {}) {
  const peerId2 = options2.peerId ??= await createEd25519PeerId();
  if (peerId2.privateKey == null) {
    throw new CodeError("peer id was missing private key", "ERR_MISSING_PRIVATE_KEY");
  }
  options2.privateKey ??= await unmarshalPrivateKey3(peerId2.privateKey);
  return new Libp2pNode(await validateConfig(options2));
}

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options2 = {}) {
  const node = await createLibp2pNode(options2);
  if (options2.start !== false) {
    await node.start();
  }
  return node;
}

// node_modules/helia/dist/src/utils/libp2p.js
async function createLibp2p2(options2) {
  const peerId2 = options2.libp2p?.peerId;
  const logger2 = options2.logger ?? defaultLogger();
  const selfKey = new Key6("/pkcs8/self");
  let chain;
  if (peerId2 == null && options2.datastore != null) {
    chain = keychain(options2.keychain)({
      datastore: options2.datastore,
      logger: logger2
    });
    if (await options2.datastore.has(selfKey)) {
      options2.libp2p = options2.libp2p ?? {};
      options2.libp2p.peerId = await chain.exportPeerId("self");
    }
  }
  const defaults2 = libp2pDefaults(options2);
  defaults2.datastore = defaults2.datastore ?? options2.datastore;
  options2 = options2 ?? {};
  const node = await createLibp2p({
    ...defaults2,
    ...options2.libp2p,
    start: false
  });
  if (peerId2 == null && chain != null && !await options2.datastore.has(selfKey)) {
    await chain.importPeer("self", node.peerId);
  }
  return node;
}

// node_modules/helia/dist/src/index.js
async function createHelia(init = {}) {
  const datastore = init.datastore ?? new MemoryDatastore();
  const blockstore = init.blockstore ?? new MemoryBlockstore2();
  let libp2p;
  if (isLibp2p(init.libp2p)) {
    libp2p = init.libp2p;
  } else {
    libp2p = await createLibp2p2({
      ...init,
      libp2p: {
        dns: init.dns,
        ...init.libp2p,
        // ignore the libp2p start parameter as it should be on the main init
        // object instead
        start: void 0
      },
      datastore
    });
  }
  const helia = new HeliaP2P({
    ...init,
    libp2p,
    datastore,
    blockstore,
    blockBrokers: init.blockBrokers ?? [
      trustlessGateway(),
      bitswap()
    ],
    routers: [
      libp2pRouting(libp2p),
      httpGatewayRouting()
    ],
    metrics: libp2p.metrics
  });
  if (init.start !== false) {
    await helia.start();
  }
  return helia;
}
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  const funcs = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
  return funcs.every((m2) => typeof obj[m2] === "function");
}
/*! Bundled license information:

pvtsutils/build/index.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@libp2p/webtransport/dist/src/muxer.js:
  (*! TODO unclear how to add backpressure here? *)
*/
